{
  "name": "smart-open",
  "description": "======================================================\nsmart_open \u2014 utils for streaming large files in Python\n======================================================\n\n\n|License|_ |GHA|_ |Coveralls|_ |Downloads|_\n\n.. |License| image:: https://img.shields.io/pypi/l/smart_open.svg\n.. |GHA| image:: https://github.com/RaRe-Technologies/smart_open/workflows/Test/badge.svg\n.. |Coveralls| image:: https://coveralls.io/repos/github/RaRe-Technologies/smart_open/badge.svg?branch=develop\n.. |Downloads| image:: https://pepy.tech/badge/smart-open/month\n.. _License: https://github.com/RaRe-Technologies/smart_open/blob/master/LICENSE\n.. _GHA: https://github.com/RaRe-Technologies/smart_open/actions?query=workflow%3ATest\n.. _Coveralls: https://coveralls.io/github/RaRe-Technologies/smart_open?branch=HEAD\n.. _Downloads: https://pypi.org/project/smart-open/\n\n\nWhat?\n=====\n\n``smart_open`` is a Python 3 library for **efficient streaming of very large files** from/to storages such as S3, GCS, Azure Blob Storage, HDFS, WebHDFS, HTTP, HTTPS, SFTP, or local filesystem. It supports transparent, on-the-fly (de-)compression for a variety of different formats.\n\n``smart_open`` is a drop-in replacement for Python's built-in ``open()``: it can do anything ``open`` can (100% compatible, falls back to native ``open`` wherever possible), plus lots of nifty extra stuff on top.\n\n**Python 2.7 is no longer supported. If you need Python 2.7, please use** `smart_open 1.10.1 <https://github.com/RaRe-Technologies/smart_open/releases/tag/1.10.0>`_, **the last version to support Python 2.**\n\nWhy?\n====\n\nWorking with large remote files, for example using Amazon's `boto3 <https://boto3.amazonaws.com/v1/documentation/api/latest/index.html>`_ Python library, is a pain.\n``boto3``'s ``Object.upload_fileobj()`` and ``Object.download_fileobj()`` methods require gotcha-prone boilerplate to use successfully, such as constructing file-like object wrappers.\n``smart_open`` shields you from that. It builds on boto3 and other remote storage libraries, but offers a **clean unified Pythonic API**. The result is less code for you to write and fewer bugs to make.\n\n\nHow?\n=====\n\n``smart_open`` is well-tested, well-documented, and has a simple Pythonic API:\n\n\n.. _doctools_before_examples:\n\n.. code-block:: python\n\n  >>> from smart_open import open\n  >>>\n  >>> # stream lines from an S3 object\n  >>> for line in open('s3://commoncrawl/robots.txt'):\n  ...    print(repr(line))\n  ...    break\n  'User-Agent: *\\n'\n\n  >>> # stream from/to compressed files, with transparent (de)compression:\n  >>> for line in open('smart_open/tests/test_data/1984.txt.gz', encoding='utf-8'):\n  ...    print(repr(line))\n  'It was a bright cold day in April, and the clocks were striking thirteen.\\n'\n  'Winston Smith, his chin nuzzled into his breast in an effort to escape the vile\\n'\n  'wind, slipped quickly through the glass doors of Victory Mansions, though not\\n'\n  'quickly enough to prevent a swirl of gritty dust from entering along with him.\\n'\n\n  >>> # can use context managers too:\n  >>> with open('smart_open/tests/test_data/1984.txt.gz') as fin:\n  ...    with open('smart_open/tests/test_data/1984.txt.bz2', 'w') as fout:\n  ...        for line in fin:\n  ...           fout.write(line)\n\n  >>> # can use any IOBase operations, like seek\n  >>> with open('s3://commoncrawl/robots.txt', 'rb') as fin:\n  ...     for line in fin:\n  ...         print(repr(line.decode('utf-8')))\n  ...         break\n  ...     offset = fin.seek(0)  # seek to the beginning\n  ...     print(fin.read(4))\n  'User-Agent: *\\n'\n  b'User'\n\n  >>> # stream from HTTP\n  >>> for line in open('http://example.com/index.html'):\n  ...     print(repr(line))\n  ...     break\n  '<!doctype html>\\n'\n\n.. _doctools_after_examples:\n\nOther examples of URLs that ``smart_open`` accepts::\n\n    s3://my_bucket/my_key\n    s3://my_key:my_secret@my_bucket/my_key\n    s3://my_key:my_secret@my_server:my_port@my_bucket/my_key\n    gs://my_bucket/my_blob\n    azure://my_bucket/my_blob\n    hdfs:///path/file\n    hdfs://path/file\n    webhdfs://host:port/path/file\n    ./local/path/file\n    ~/local/path/file\n    local/path/file\n    ./local/path/file.gz\n    file:///home/user/file\n    file:///home/user/file.bz2\n    [ssh|scp|sftp]://username@host//path/file\n    [ssh|scp|sftp]://username@host/path/file\n    [ssh|scp|sftp]://username:password@host/path/file\n\n\nDocumentation\n=============\n\nInstallation\n------------\n\n``smart_open`` supports a wide range of storage solutions, including AWS S3, Google Cloud and Azure.\nEach individual solution has its own dependencies.\nBy default, ``smart_open`` does not install any dependencies, in order to keep the installation size small.\nYou can install these dependencies explicitly using::\n\n    pip install smart_open[azure] # Install Azure deps\n    pip install smart_open[gcs] # Install GCS deps\n    pip install smart_open[s3] # Install S3 deps\n\nOr, if you don't mind installing a large number of third party libraries, you can install all dependencies using::\n\n    pip install smart_open[all]\n\nBe warned that this option increases the installation size significantly, e.g. over 100MB.\n\nIf you're upgrading from ``smart_open`` versions 2.x and below, please check out the `Migration Guide <MIGRATING_FROM_OLDER_VERSIONS.rst>`_.\n\nBuilt-in help\n-------------\n\nFor detailed API info, see the online help:\n\n.. code-block:: python\n\n    help('smart_open')\n\nor click `here <https://github.com/RaRe-Technologies/smart_open/blob/master/help.txt>`__ to view the help in your browser.\n\nMore examples\n-------------\n\nFor the sake of simplicity, the examples below assume you have all the dependencies installed, i.e. you have done::\n\n    pip install smart_open[all]\n\n.. code-block:: python\n\n    >>> import os, boto3\n    >>>\n    >>> # stream content *into* S3 (write mode) using a custom session\n    >>> session = boto3.Session(\n    ...     aws_access_key_id=os.environ['AWS_ACCESS_KEY_ID'],\n    ...     aws_secret_access_key=os.environ['AWS_SECRET_ACCESS_KEY'],\n    ... )\n    >>> url = 's3://smart-open-py37-benchmark-results/test.txt'\n    >>> with open(url, 'wb', transport_params={'client': session.client('s3')}) as fout:\n    ...     bytes_written = fout.write(b'hello world!')\n    ...     print(bytes_written)\n    12\n\n.. code-block:: python\n\n    # stream from HDFS\n    for line in open('hdfs://user/hadoop/my_file.txt', encoding='utf8'):\n        print(line)\n\n    # stream from WebHDFS\n    for line in open('webhdfs://host:port/user/hadoop/my_file.txt'):\n        print(line)\n\n    # stream content *into* HDFS (write mode):\n    with open('hdfs://host:port/user/hadoop/my_file.txt', 'wb') as fout:\n        fout.write(b'hello world')\n\n    # stream content *into* WebHDFS (write mode):\n    with open('webhdfs://host:port/user/hadoop/my_file.txt', 'wb') as fout:\n        fout.write(b'hello world')\n\n    # stream from a completely custom s3 server, like s3proxy:\n    for line in open('s3u://user:secret@host:port@mybucket/mykey.txt'):\n        print(line)\n\n    # Stream to Digital Ocean Spaces bucket providing credentials from boto3 profile\n    session = boto3.Session(profile_name='digitalocean')\n    client = session.client('s3', endpoint_url='https://ams3.digitaloceanspaces.com')\n    transport_params = {'client': client}\n    with open('s3://bucket/key.txt', 'wb', transport_params=transport_params) as fout:\n        fout.write(b'here we stand')\n\n    # stream from GCS\n    for line in open('gs://my_bucket/my_file.txt'):\n        print(line)\n\n    # stream content *into* GCS (write mode):\n    with open('gs://my_bucket/my_file.txt', 'wb') as fout:\n        fout.write(b'hello world')\n\n    # stream from Azure Blob Storage\n    connect_str = os.environ['AZURE_STORAGE_CONNECTION_STRING']\n    transport_params = {\n        'client': azure.storage.blob.BlobServiceClient.from_connection_string(connect_str),\n    }\n    for line in open('azure://mycontainer/myfile.txt', transport_params=transport_params):\n        print(line)\n\n    # stream content *into* Azure Blob Storage (write mode):\n    connect_str = os.environ['AZURE_STORAGE_CONNECTION_STRING']\n    transport_params = {\n        'client': azure.storage.blob.BlobServiceClient.from_connection_string(connect_str),\n    }\n    with open('azure://mycontainer/my_file.txt', 'wb', transport_params=transport_params) as fout:\n        fout.write(b'hello world')\n\nSupported Compression Formats\n-----------------------------\n\n``smart_open`` allows reading and writing gzip and bzip2 files.\nThey are transparently handled over HTTP, S3, and other protocols, too, based on the extension of the file being opened.\nYou can easily add support for other file extensions and compression formats.\nFor example, to open xz-compressed files:\n\n.. code-block:: python\n\n    >>> import lzma, os\n    >>> from smart_open import open, register_compressor\n\n    >>> def _handle_xz(file_obj, mode):\n    ...      return lzma.LZMAFile(filename=file_obj, mode=mode, format=lzma.FORMAT_XZ)\n\n    >>> register_compressor('.xz', _handle_xz)\n\n    >>> with open('smart_open/tests/test_data/crime-and-punishment.txt.xz') as fin:\n    ...     text = fin.read()\n    >>> print(len(text))\n    1696\n\n``lzma`` is in the standard library in Python 3.3 and greater.\nFor 2.7, use `backports.lzma`_.\n\n.. _backports.lzma: https://pypi.org/project/backports.lzma/\n\n\nTransport-specific Options\n--------------------------\n\n``smart_open`` supports a wide range of transport options out of the box, including:\n\n- S3\n- HTTP, HTTPS (read-only)\n- SSH, SCP and SFTP\n- WebHDFS\n- GCS\n- Azure Blob Storage\n\nEach option involves setting up its own set of parameters.\nFor example, for accessing S3, you often need to set up authentication, like API keys or a profile name.\n``smart_open``'s ``open`` function accepts a keyword argument ``transport_params`` which accepts additional parameters for the transport layer.\nHere are some examples of using this parameter:\n\n.. code-block:: python\n\n  >>> import boto3\n  >>> fin = open('s3://commoncrawl/robots.txt', transport_params=dict(client=boto3.client('s3')))\n  >>> fin = open('s3://commoncrawl/robots.txt', transport_params=dict(buffer_size=1024))\n\nFor the full list of keyword arguments supported by each transport option, see the documentation:\n\n.. code-block:: python\n\n  help('smart_open.open')\n\nS3 Credentials\n--------------\n\n``smart_open`` uses the ``boto3`` library to talk to S3.\n``boto3`` has several `mechanisms <https://boto3.amazonaws.com/v1/documentation/api/latest/guide/configuration.html>`__ for determining the credentials to use.\nBy default, ``smart_open`` will defer to ``boto3`` and let the latter take care of the credentials.\nThere are several ways to override this behavior.\n\nThe first is to pass a ``boto3.Client`` object as a transport parameter to the ``open`` function.\nYou can customize the credentials when constructing the session for the client.\n``smart_open`` will then use the session when talking to S3.\n\n.. code-block:: python\n\n    session = boto3.Session(\n        aws_access_key_id=ACCESS_KEY,\n        aws_secret_access_key=SECRET_KEY,\n        aws_session_token=SESSION_TOKEN,\n    )\n    client = session.client('s3', endpoint_url=..., config=...)\n    fin = open('s3://bucket/key', transport_params=dict(client=client))\n\nYour second option is to specify the credentials within the S3 URL itself:\n\n.. code-block:: python\n\n    fin = open('s3://aws_access_key_id:aws_secret_access_key@bucket/key', ...)\n\n*Important*: The two methods above are **mutually exclusive**. If you pass an AWS client *and* the URL contains credentials, ``smart_open`` will ignore the latter.\n\n*Important*: ``smart_open`` ignores configuration files from the older ``boto`` library.\nPort your old ``boto`` settings to ``boto3`` in order to use them with ``smart_open``.\n\nIterating Over an S3 Bucket's Contents\n--------------------------------------\n\nSince going over all (or select) keys in an S3 bucket is a very common operation, there's also an extra function ``smart_open.s3.iter_bucket()`` that does this efficiently, **processing the bucket keys in parallel** (using multiprocessing):\n\n.. code-block:: python\n\n  >>> from smart_open import s3\n  >>> # get data corresponding to 2010 and later under \"silo-open-data/annual/monthly_rain\"\n  >>> # we use workers=1 for reproducibility; you should use as many workers as you have cores\n  >>> bucket = 'silo-open-data'\n  >>> prefix = 'annual/monthly_rain/'\n  >>> for key, content in s3.iter_bucket(bucket, prefix=prefix, accept_key=lambda key: '/201' in key, workers=1, key_limit=3):\n  ...     print(key, round(len(content) / 2**20))\n  annual/monthly_rain/2010.monthly_rain.nc 13\n  annual/monthly_rain/2011.monthly_rain.nc 13\n  annual/monthly_rain/2012.monthly_rain.nc 13\n\nGCS Credentials\n---------------\n``smart_open`` uses the ``google-cloud-storage`` library to talk to GCS.\n``google-cloud-storage`` uses the ``google-cloud`` package under the hood to handle authentication.\nThere are several `options <https://googleapis.dev/python/google-api-core/latest/auth.html>`__ to provide\ncredentials.\nBy default, ``smart_open`` will defer to ``google-cloud-storage`` and let it take care of the credentials.\n\nTo override this behavior, pass a ``google.cloud.storage.Client`` object as a transport parameter to the ``open`` function.\nYou can `customize the credentials <https://googleapis.dev/python/storage/latest/client.html>`__\nwhen constructing the client. ``smart_open`` will then use the client when talking to GCS. To follow allow with\nthe example below, `refer to Google's guide <https://cloud.google.com/storage/docs/reference/libraries#setting_up_authentication>`__\nto setting up GCS authentication with a service account.\n\n.. code-block:: python\n\n    import os\n    from google.cloud.storage import Client\n    service_account_path = os.environ['GOOGLE_APPLICATION_CREDENTIALS']\n    client = Client.from_service_account_json(service_account_path)\n    fin = open('gs://gcp-public-data-landsat/index.csv.gz', transport_params=dict(client=client))\n\nIf you need more credential options, you can create an explicit ``google.auth.credentials.Credentials`` object\nand pass it to the Client. To create an API token for use in the example below, refer to the\n`GCS authentication guide <https://cloud.google.com/storage/docs/authentication#apiauth>`__.\n\n.. code-block:: python\n\n\timport os\n\tfrom google.auth.credentials import Credentials\n\tfrom google.cloud.storage import Client\n\ttoken = os.environ['GOOGLE_API_TOKEN']\n\tcredentials = Credentials(token=token)\n\tclient = Client(credentials=credentials)\n\tfin = open('gs://gcp-public-data-landsat/index.csv.gz', transport_params=dict(client=client))\n\nAzure Credentials\n-----------------\n\n``smart_open`` uses the ``azure-storage-blob`` library to talk to Azure Blob Storage.\nBy default, ``smart_open`` will defer to ``azure-storage-blob`` and let it take care of the credentials.\n\nAzure Blob Storage does not have any ways of inferring credentials therefore, passing a ``azure.storage.blob.BlobServiceClient``\nobject as a transport parameter to the ``open`` function is required.\nYou can `customize the credentials <https://docs.microsoft.com/en-us/azure/storage/common/storage-samples-python#authentication>`__\nwhen constructing the client. ``smart_open`` will then use the client when talking to. To follow allow with\nthe example below, `refer to Azure's guide <https://docs.microsoft.com/en-us/azure/storage/blobs/storage-quickstart-blobs-python#copy-your-credentials-from-the-azure-portal>`__\nto setting up authentication.\n\n.. code-block:: python\n\n    import os\n    from azure.storage.blob import BlobServiceClient\n    azure_storage_connection_string = os.environ['AZURE_STORAGE_CONNECTION_STRING']\n    client = BlobServiceClient.from_connection_string(azure_storage_connection_string)\n    fin = open('azure://my_container/my_blob.txt', transport_params=dict(client=client))\n\nIf you need more credential options, refer to the\n`Azure Storage authentication guide <https://docs.microsoft.com/en-us/azure/storage/common/storage-samples-python#authentication>`__.\n\nFile-like Binary Streams\n------------------------\n\nThe ``open`` function also accepts file-like objects.\nThis is useful when you already have a `binary file <https://docs.python.org/3/glossary.html#term-binary-file>`_ open, and would like to wrap it with transparent decompression:\n\n\n.. code-block:: python\n\n    >>> import io, gzip\n    >>>\n    >>> # Prepare some gzipped binary data in memory, as an example.\n    >>> # Any binary file will do; we're using BytesIO here for simplicity.\n    >>> buf = io.BytesIO()\n    >>> with gzip.GzipFile(fileobj=buf, mode='w') as fout:\n    ...     _ = fout.write(b'this is a bytestring')\n    >>> _ = buf.seek(0)\n    >>>\n    >>> # Use case starts here.\n    >>> buf.name = 'file.gz'  # add a .name attribute so smart_open knows what compressor to use\n    >>> import smart_open\n    >>> smart_open.open(buf, 'rb').read()  # will gzip-decompress transparently!\n    b'this is a bytestring'\n\n\nIn this case, ``smart_open`` relied on the ``.name`` attribute of our `binary I/O stream <https://docs.python.org/3/library/io.html#binary-i-o>`_ ``buf`` object to determine which decompressor to use.\nIf your file object doesn't have one, set the ``.name`` attribute to an appropriate value.\nFurthermore, that value has to end with a **known** file extension (see the ``register_compressor`` function).\nOtherwise, the transparent decompression will not occur.\n\nDrop-in replacement of ``pathlib.Path.open``\n--------------------------------------------\n\n``smart_open.open`` can also be used with ``Path`` objects.\nThe built-in `Path.open()` is not able to read text from compressed files, so use ``patch_pathlib`` to replace it with `smart_open.open()` instead.\nThis can be helpful when e.g. working with compressed files.\n\n.. code-block:: python\n\n    >>> from pathlib import Path\n    >>> from smart_open.smart_open_lib import patch_pathlib\n    >>>\n    >>> _ = patch_pathlib()  # replace `Path.open` with `smart_open.open`\n    >>>\n    >>> path = Path(\"smart_open/tests/test_data/crime-and-punishment.txt.gz\")\n    >>>\n    >>> with path.open(\"r\") as infile:\n    ...     print(infile.readline()[:41])\n    \u0412 \u043d\u0430\u0447\u0430\u043b\u0435 \u0438\u044e\u043b\u044f, \u0432 \u0447\u0440\u0435\u0437\u0432\u044b\u0447\u0430\u0439\u043d\u043e \u0436\u0430\u0440\u043a\u043e\u0435 \u0432\u0440\u0435\u043c\u044f\n\nHow do I ...?\n=============\n\nSee `this document <howto.md>`__.\n\nExtending ``smart_open``\n========================\n\nSee `this document <extending.md>`__.\n\nTesting ``smart_open``\n======================\n\n``smart_open`` comes with a comprehensive suite of unit tests.\nBefore you can run the test suite, install the test dependencies::\n\n    pip install -e .[test]\n\nNow, you can run the unit tests::\n\n    pytest smart_open\n\nThe tests are also run automatically with `Travis CI <https://travis-ci.org/RaRe-Technologies/smart_open>`_ on every commit push & pull request.\n\nComments, bug reports\n=====================\n\n``smart_open`` lives on `Github <https://github.com/RaRe-Technologies/smart_open>`_. You can file\nissues or pull requests there. Suggestions, pull requests and improvements welcome!\n\n----------------\n\n``smart_open`` is open source software released under the `MIT license <https://github.com/piskvorky/smart_open/blob/master/LICENSE>`_.\nCopyright (c) 2015-now `Radim \u0158eh\u016f\u0159ek <https://radimrehurek.com>`_.",
  "requires_dist": null,
  "requires_python": ">=3.6.*",
  "current_version": "5.0.0",
  "released_versions": [
    "0.1.0",
    "0.1.1",
    "1.0.1",
    "1.0.2",
    "1.1.0",
    "1.10.0",
    "1.10.1",
    "1.11.0",
    "1.11.1",
    "1.2.0",
    "1.2.1",
    "1.3.0",
    "1.3.0rc1",
    "1.3.1",
    "1.3.2",
    "1.3.3",
    "1.3.4",
    "1.3.5",
    "1.4.0",
    "1.5.0",
    "1.5.1",
    "1.5.2",
    "1.5.3",
    "1.5.4",
    "1.5.5",
    "1.5.6",
    "1.5.7",
    "1.6.0",
    "1.7.0",
    "1.7.1",
    "1.8.0",
    "1.8.1",
    "1.8.2",
    "1.8.3",
    "1.8.4",
    "1.9.0",
    "2.0.0",
    "2.1.0",
    "2.1.1",
    "2.2.0",
    "2.2.1",
    "3.0.0",
    "4.0.0",
    "4.0.1",
    "4.1.0",
    "4.1.2",
    "4.2.0",
    "5.0.0"
  ]
}