{
  "name": "vistir",
  "description": "===============================================================================\nvistir: Setup / utilities which most projects eventually need\n===============================================================================\n\n.. image:: https://img.shields.io/pypi/v/vistir.svg\n    :target: https://pypi.python.org/pypi/vistir\n\n.. image:: https://img.shields.io/pypi/l/vistir.svg\n    :target: https://pypi.python.org/pypi/vistir\n\n.. image:: https://travis-ci.com/sarugaku/vistir.svg?branch=master\n    :target: https://travis-ci.com/sarugaku/vistir\n\n.. image:: https://img.shields.io/pypi/pyversions/vistir.svg\n    :target: https://pypi.python.org/pypi/vistir\n\n.. image:: https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg\n    :target: https://saythanks.io/to/techalchemy\n\n.. image:: https://readthedocs.org/projects/vistir/badge/?version=latest\n    :target: https://vistir.readthedocs.io/en/latest/?badge=latest\n    :alt: Documentation Status\n\n.. image:: https://dev.azure.com/sarugaku/vistir/_apis/build/status/Vistir%20Build%20Pipeline?branchName=master\n    :target: https://dev.azure.com/sarugaku/vistir/_build/latest?definitionId=2&branchName=master\n\n\n\ud83d\udc09 Installation\n=================\n\nInstall from `PyPI`_:\n\n  ::\n\n    $ pipenv install vistir\n\nInstall from `Github`_:\n\n  ::\n\n    $ pipenv install -e git+https://github.com/sarugaku/vistir.git#egg=vistir\n\n\n.. _PyPI: https://www.pypi.org/project/vistir\n.. _Github: https://github.com/sarugaku/vistir\n\n\n.. _`Summary`:\n\n\ud83d\udc09 Summary\n===========\n\n**vistir** is a library full of utility functions designed to make life easier. Here are\nsome of the places where these functions are used:\n\n  * `pipenv`_\n  * `requirementslib`_\n  * `pip-tools`_\n  * `passa`_\n  * `pythonfinder`_\n\n.. _passa: https://github.com/sarugaku/passa\n.. _pipenv: https://github.com/pypa/pipenv\n.. _pip-tools: https://github.com/jazzband/pip-tools\n.. _requirementslib: https://github.com/sarugaku/requirementslib\n.. _pythonfinder: https://github.com/sarugaku/pythonfinder\n\n\n.. _`Usage`:\n\n\ud83d\udc09 Usage\n==========\n\nImporting a utility\n--------------------\n\nYou can import utilities directly from **vistir**:\n\n.. code:: python\n\n    from vistir import cd\n    with cd('/path/to/somedir'):\n        do_stuff_in('somedir')\n\n\n.. _`Functionality`:\n\n\ud83d\udc09 Functionality\n==================\n\n**vistir** provides several categories of functionality, including:\n\n    * Backports\n    * Compatibility Shims\n    * Context Managers\n    * Miscellaneous Utilities\n    * Path Utilities\n\n.. note::\n\n   The backports should be imported via ``vistir.compat`` which will provide the\n   native versions of the backported items if possible.\n\n\n\ud83d\udc09 Compatibility Shims\n-----------------------\n\nShims are provided for full API compatibility from python 2.7 through 3.7 for the following:\n\n    * ``weakref.finalize``\n    * ``functools.partialmethod`` (via ``vistir.backports.functools.partialmethod``)\n    * ``tempfile.TemporaryDirectory`` (via ``vistir.backports.tempfile.TemporaryDirectory``)\n    * ``tempfile.NamedTemporaryFile`` (via ``vistir.backports.tempfile.NamedTemporaryFile``)\n    * ``vistir.compat.Path``\n    * ``vistir.compat.get_terminal_size``\n    * ``vistir.compat.JSONDecodeError``\n    * ``vistir.compat.ResourceWarning``\n    * ``vistir.compat.FileNotFoundError``\n    * ``vistir.compat.PermissionError``\n    * ``vistir.compat.IsADirectoryError``\n\nThe following additional functions are provided for encoding strings to the filesystem\ndefault encoding:\n\n    * ``vistir.compat.fs_str``\n    * ``vistir.compat.to_native_string``\n    * ``vistir.compat.fs_encode``\n    * ``vistir.compat.fs_decode``\n\n\n\ud83d\udc09 Context Managers\n--------------------\n\n**vistir** provides the following context managers as utility contexts:\n\n    * ``vistir.contextmanagers.atomic_open_for_write``\n    * ``vistir.contextmanagers.cd``\n    * ``vistir.contextmanagers.open_file``\n    * ``vistir.contextmanagers.replaced_stream``\n    * ``vistir.contextmanagers.replaced_streams``\n    * ``vistir.contextmanagers.spinner``\n    * ``vistir.contextmanagers.temp_environ``\n    * ``vistir.contextmanagers.temp_path``\n\n\n.. _`atomic_open_for_write`:\n\n**atomic_open_for_write**\n///////////////////////////\n\nThis context manager ensures that a file only gets overwritten if the contents can be\nsuccessfully written in its place.  If you open a file for writing and then fail in the\nmiddle under normal circumstances, your original file is already gone.\n\n.. code:: python\n\n    >>> fn = \"test_file.txt\"\n    >>> with open(fn, \"w\") as fh:\n            fh.write(\"this is some test text\")\n    >>> read_test_file()\n    this is some test text\n    >>> def raise_exception_while_writing(filename):\n            with vistir.contextmanagers.atomic_open_for_write(filename) as fh:\n                fh.write(\"Overwriting all the text from before with even newer text\")\n                raise RuntimeError(\"But did it get overwritten now?\")\n    >>> raise_exception_while_writing(fn)\n        Traceback (most recent call last):\n            ...\n        RuntimeError: But did it get overwritten now?\n    >>> read_test_file()\n    this is some test text\n\n\n.. _`cd`:\n\n**cd**\n///////\n\nA context manager for temporarily changing the working directory.\n\n\n.. code:: python\n\n    >>> os.path.abspath(os.curdir)\n    '/tmp/test'\n    >>> with vistir.contextmanagers.cd('/tmp/vistir_test'):\n            print(os.path.abspath(os.curdir))\n    /tmp/vistir_test\n\n\n.. _`open_file`:\n\n**open_file**\n///////////////\n\nA context manager for streaming file contents, either local or remote. It is recommended\nto pair this with an iterator which employs a sensible chunk size.\n\n\n.. code:: python\n\n    >>> filecontents = b\"\"\n        with vistir.contextmanagers.open_file(\"https://norvig.com/big.txt\") as fp:\n            for chunk in iter(lambda: fp.read(16384), b\"\"):\n                filecontents.append(chunk)\n    >>> import io\n    >>> import shutil\n    >>> filecontents = io.BytesIO(b\"\")\n    >>> with vistir.contextmanagers.open_file(\"https://norvig.com/big.txt\") as fp:\n            shutil.copyfileobj(fp, filecontents)\n\n\n**replaced_stream**\n////////////////////\n\n.. _`replaced_stream`:\n\nA context manager to temporarily swap out *stream_name* with a stream wrapper.  This will\ncapture the stream output and prevent it from being written as normal.\n\n.. code-block:: python\n\n    >>> orig_stdout = sys.stdout\n    >>> with replaced_stream(\"stdout\") as stdout:\n    ...     sys.stdout.write(\"hello\")\n    ...     assert stdout.getvalue() == \"hello\"\n    ...     assert orig_stdout.getvalue() != \"hello\"\n\n    >>> sys.stdout.write(\"hello\")\n    'hello'\n\n\n.. _`replaced_streams`:\n\n**replaced_streams**\n/////////////////////\n\n\nTemporarily replaces both *sys.stdout* and *sys.stderr* and captures anything written\nto these respective targets.\n\n\n.. code-block:: python\n\n    >>> import sys\n    >>> with vistir.contextmanagers.replaced_streams() as streams:\n    >>>     stdout, stderr = streams\n    >>>     sys.stderr.write(\"test\")\n    >>>     sys.stdout.write(\"hello\")\n    >>>     assert stdout.getvalue() == \"hello\"\n    >>>     assert stderr.getvalue() == \"test\"\n\n    >>> stdout.getvalue()\n    'hello'\n\n    >>> stderr.getvalue()\n    'test'\n\n\n.. _`spinner`:\n\n**spinner**\n////////////\n\nA context manager for wrapping some actions with a threaded, interrupt-safe spinner. The\nspinner is fully compatible with all terminals (you can use ``bouncingBar`` on non-utf8\nterminals) and will allow you to update the text of the spinner itself by simply setting\n``spinner.text`` or write lines to the screen above the spinner by using\n``spinner.write(line)``. Success text can be indicated using ``spinner.ok(\"Text\")`` and\nfailure text can be indicated with ``spinner.fail(\"Fail text\")``.\n\n.. code:: python\n\n    >>> lines = [\"a\", \"b\"]\n    >>> with vistir.contextmanagers.spinner(spinner_name=\"dots\", text=\"Running...\", handler_map={}, nospin=False) as sp:\n            for line in lines:\n            sp.write(line + \"\\n\")\n            while some_variable = some_queue.pop():\n                sp.text = \"Consuming item: %s\" % some_variable\n            if success_condition:\n                sp.ok(\"Succeeded!\")\n            else:\n                sp.fail(\"Failed!\")\n\n\n.. _`temp_environ`:\n\n**temp_environ**\n/////////////////\n\nSets a temporary environment context to freely manipulate ``os.environ`` which will\nbe reset upon exiting the context.\n\n\n.. code:: python\n\n    >>> os.environ['MY_KEY'] = \"test\"\n    >>> os.environ['MY_KEY']\n    'test'\n    >>> with vistir.contextmanagers.temp_environ():\n            os.environ['MY_KEY'] = \"another thing\"\n            print(\"New key: %s\" % os.environ['MY_KEY'])\n    New key: another thing\n    >>> os.environ['MY_KEY']\n    'test'\n\n\n.. _`temp_path`:\n\n**temp_path**\n//////////////\n\nSets a temporary environment context to freely manipulate ``sys.path`` which will\nbe reset upon exiting the context.\n\n\n.. code:: python\n\n    >>> path_from_virtualenv = load_path(\"/path/to/venv/bin/python\")\n    >>> print(sys.path)\n    ['/home/user/.pyenv/versions/3.7.0/bin', '/home/user/.pyenv/versions/3.7.0/lib/python37.zip', '/home/user/.pyenv/versions/3.7.0/lib/python3.7', '/home/user/.pyenv/versions/3.7.0/lib/python3.7/lib-dynload', '/home/user/.pyenv/versions/3.7.0/lib/python3.7/site-packages']\n    >>> with temp_path():\n            sys.path = path_from_virtualenv\n            # Running in the context of the path above\n            run([\"pip\", \"install\", \"stuff\"])\n    >>> print(sys.path)\n    ['/home/user/.pyenv/versions/3.7.0/bin', '/home/user/.pyenv/versions/3.7.0/lib/python37.zip', '/home/user/.pyenv/versions/3.7.0/lib/python3.7', '/home/user/.pyenv/versions/3.7.0/lib/python3.7/lib-dynload', '/home/user/.pyenv/versions/3.7.0/lib/python3.7/site-packages']\n\n\n\ud83d\udc09 Cursor Utilities\n--------------------------\n\nThe following Cursor utilities are available to manipulate the console cursor:\n\n    * ``vistir.cursor.hide_cursor``\n    * ``vistir.cursor.show_cursor``\n\n\n.. _`hide_cursor`:\n\n**hide_cursor**\n/////////////////\n\nHide the console cursor in the given stream.\n\n.. code:: python\n\n    >>> vistir.cursor.hide_cursor(stream=sys.stdout)\n\n\n.. _`show_cursor`:\n\n**show_cursor**\n/////////////////\n\nShow the console cursor in the given stream.\n\n.. code:: python\n\n    >>> vistir.cursor.show_cursor(stream=sys.stdout)\n\n\n\ud83d\udc09 Miscellaneous Utilities\n--------------------------\n\nThe following Miscellaneous utilities are available as helper methods:\n\n    * ``vistir.misc.shell_escape``\n    * ``vistir.misc.unnest``\n    * ``vistir.misc.dedup``\n    * ``vistir.misc.run``\n    * ``vistir.misc.load_path``\n    * ``vistir.misc.partialclass``\n    * ``vistir.misc.to_text``\n    * ``vistir.misc.to_bytes``\n    * ``vistir.misc.divide``\n    * ``vistir.misc.take``\n    * ``vistir.misc.chunked``\n    * ``vistir.misc.decode_for_output``\n    * ``vistir.misc.get_canonical_encoding_name``\n    * ``vistir.misc.get_wrapped_stream``\n    * ``vistir.misc.StreamWrapper``\n    * ``vistir.misc.get_text_stream``\n    * ``vistir.misc.replace_with_text_stream``\n    * ``vistir.misc.get_text_stdin``\n    * ``vistir.misc.get_text_stdout``\n    * ``vistir.misc.get_text_stderr``\n    * ``vistir.misc.echo``\n\n\n.. _`shell_escape`:\n\n**shell_escape**\n/////////////////\n\nEscapes a string for use as shell input when passing *shell=True* to ``os.Popen``.\n\n.. code:: python\n\n    >>> vistir.misc.shell_escape(\"/tmp/test/test script.py hello\")\n    '/tmp/test/test script.py hello'\n\n\n.. _`unnest`:\n\n**unnest**\n///////////\n\nUnnests nested iterables into a flattened one.\n\n.. code:: python\n\n    >>> nested_iterable = (1234, (3456, 4398345, (234234)), (2396, (23895750, 9283798, 29384, (289375983275, 293759, 2347, (2098, 7987, 27599)))))\n    >>> list(vistir.misc.unnest(nested_iterable))\n    [1234, 3456, 4398345, 234234, 2396, 23895750, 9283798, 29384, 289375983275, 293759, 2347, 2098, 7987, 27599]\n\n\n.. _`dedup`:\n\n**dedup**\n//////////\n\nDeduplicates an iterable (like a ``set``, but preserving order).\n\n.. code:: python\n\n    >>> iterable = [\"repeatedval\", \"uniqueval\", \"repeatedval\", \"anotherval\", \"somethingelse\"]\n    >>> list(vistir.misc.dedup(iterable))\n    ['repeatedval', 'uniqueval', 'anotherval', 'somethingelse']\n\n.. _`run`:\n\n**run**\n////////\n\nRuns the given command using ``subprocess.Popen`` and passing sane defaults.\n\n.. code:: python\n\n    >>> out, err = vistir.run([\"cat\", \"/proc/version\"])\n    >>> out\n    'Linux version 4.15.0-27-generic (buildd@lgw01-amd64-044) (gcc version 7.3.0 (Ubuntu 7.3.0-16ubuntu3)) #29-Ubuntu SMP Wed Jul 11 08:21:57 UTC 2018'\n\n\n.. _`load_path`:\n\n**load_path**\n//////////////\n\nLoad the ``sys.path`` from the given python executable's environment as json.\n\n.. code:: python\n\n    >>> load_path(\"/home/user/.virtualenvs/requirementslib-5MhGuG3C/bin/python\")\n    ['', '/home/user/.virtualenvs/requirementslib-5MhGuG3C/lib/python37.zip', '/home/user/.virtualenvs/requirementslib-5MhGuG3C/lib/python3.7', '/home/user/.virtualenvs/requirementslib-5MhGuG3C/lib/python3.7/lib-dynload', '/home/user/.pyenv/versions/3.7.0/lib/python3.7', '/home/user/.virtualenvs/requirementslib-5MhGuG3C/lib/python3.7/site-packages', '/home/user/git/requirementslib/src']\n\n\n.. _`partialclass`:\n\n**partialclass**\n/////////////////\n\nCreate a partially instantiated class.\n\n.. code:: python\n\n    >>> source = partialclass(Source, url=\"https://pypi.org/simple\")\n    >>> new_source = source(name=\"pypi\")\n    >>> new_source\n    <__main__.Source object at 0x7f23af189b38>\n    >>> new_source.__dict__\n    {'url': 'https://pypi.org/simple', 'verify_ssl': True, 'name': 'pypi'}\n\n\n.. _`to_text`:\n\n**to_text**\n////////////\n\nConvert arbitrary text-formattable input to text while handling errors.\n\n.. code:: python\n\n    >>> vistir.misc.to_text(b\"these are bytes\")\n    'these are bytes'\n\n\n.. _`to_bytes`:\n\n**to_bytes**\n/////////////\n\nConverts arbitrary byte-convertable input to bytes while handling errors.\n\n.. code:: python\n\n    >>> vistir.misc.to_bytes(\"this is some text\")\n    b'this is some text'\n    >>> vistir.misc.to_bytes(u\"this is some text\")\n    b'this is some text'\n\n\n.. _`chunked`:\n\n**chunked**\n////////////\n\nSplits an iterable up into groups *of the specified length*, per `more itertools`_.  Returns an iterable.\n\nThis example will create groups of chunk size **5**, which means there will be *6 groups*.\n\n.. code-block:: python\n\n    >>> chunked_iterable = vistir.misc.chunked(5, range(30))\n    >>> for chunk in chunked_iterable:\n    ...     add_to_some_queue(chunk)\n\n.. _more itertools: https://more-itertools.readthedocs.io/en/latest/api.html#grouping\n\n\n.. _`take`:\n\n**take**\n/////////\n\nTake elements from the supplied iterable without consuming it.\n\n.. code-block:: python\n\n    >>> iterable = range(30)\n    >>> first_10 = take(10, iterable)\n    >>> [i for i in first_10]\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    >>> [i for i in iterable]\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]\n\n\n.. _`divide`:\n\n**divide**\n////////////\n\nSplits an iterable up into the *specified number of groups*, per `more itertools`_.  Returns an iterable.\n\n.. code-block:: python\n\n    >>> iterable = range(30)\n    >>> groups = []\n    >>> for grp in vistir.misc.divide(3, iterable):\n    ...     groups.append(grp)\n    >>> groups\n    [<tuple_iterator object at 0x7fb7966006a0>, <tuple_iterator object at 0x7fb796652780>, <tuple_iterator object at 0x7fb79650a2b0>]\n\n\n.. _more itertools: https://more-itertools.readthedocs.io/en/latest/api.html#grouping\n\n\n.. _`decode_for_output`:\n\n**decode_for_output**\n//////////////////////\n\nConverts an arbitrary text input to output which is encoded for printing to terminal\noutputs using the system preferred locale using ``locale.getpreferredencoding(False)``\nwith some additional hackery on linux systems.\n\n\n.. _`get_canonical_encoding_name`:\n\n**get_canonical_encoding_name**\n////////////////////////////////\n\nGiven an encoding name, get the canonical name from a codec lookup.\n\n.. code-block:: python\n\n    >>> vistir.misc.get_canonical_encoding_name(\"utf8\")\n    \"utf-8\"\n\n\n.. _`get_wrapped_stream`:\n\n**get_wrapped_stream**\n//////////////////////\n\nGiven a stream, wrap it in a `StreamWrapper` instance and return the wrapped stream.\n\n.. code-block:: python\n\n    >>> stream = sys.stdout\n    >>> wrapped_stream = vistir.misc.get_wrapped_stream(sys.stdout)\n    >>> wrapped_stream.write(\"unicode\\u0141\")\n    >>> wrapped_stream.seek(0)\n    >>> wrapped_stream.read()\n    \"unicode\\u0141\"\n\n\n.. _`StreamWrapper`:\n\n**StreamWrapper**\n//////////////////\n\nA stream wrapper and compatibility class for handling wrapping file-like stream objects\nwhich may be used in place of ``sys.stdout`` and other streams.\n\n.. code-block:: python\n\n    >>> wrapped_stream = vistir.misc.StreamWrapper(sys.stdout, encoding=\"utf-8\", errors=\"replace\", line_buffering=True)\n    >>> wrapped_stream = vistir.misc.StreamWrapper(io.StringIO(), encoding=\"utf-8\", errors=\"replace\", line_buffering=True)\n\n\n.. _`get_text_stream`:\n\n**get_text_stream**\n////////////////////\n\nAn implementation of the **StreamWrapper** for the purpose of wrapping **sys.stdin** or **sys.stdout**.\n\nOn Windows, this returns the appropriate handle to the requested output stream.\n\n.. code-block:: python\n\n    >>> text_stream = vistir.misc.get_text_stream(\"stdout\")\n    >>> sys.stdout = text_stream\n    >>> sys.stdin = vistir.misc.get_text_stream(\"stdin\")\n    >>> vistir.misc.echo(u\"\\0499\", fg=\"green\")\n    \u0499\n\n\n.. _`replace_with_text_stream`:\n\n**replace_with_text_stream**\n/////////////////////////////\n\nGiven a text stream name, replaces the text stream with a **StreamWrapper** instance.\n\n\n.. code-block:: python\n\n    >>> vistir.misc.replace_with_text_stream(\"stdout\")\n\nOnce invoked, the standard stream in question is replaced with the required wrapper,\nturning it into a ``TextIOWrapper`` compatible stream (which ensures that unicode\ncharacters can be written to it).\n\n\n.. _`get_text_stdin`:\n\n**get_text_stdin**\n///////////////////\n\nA helper function for calling **get_text_stream(\"stdin\")**.\n\n\n.. _`get_text_stdout`:\n\n**get_text_stdout**\n////////////////////\n\nA helper function for calling **get_text_stream(\"stdout\")**.\n\n\n.. _`get_text_stderr`:\n\n**get_text_stderr**\n////////////////////\n\nA helper function for calling **get_text_stream(\"stderr\")**.\n\n\n.. _`echo`:\n\n**echo**\n/////////\n\nWrites colored, stream-compatible output to the desired handle (``sys.stdout`` by default).\n\n.. code-block:: python\n\n    >>> vistir.misc.echo(\"some text\", fg=\"green\", bg=\"black\", style=\"bold\", err=True)  # write to stderr\n    some text\n    >>> vistir.misc.echo(\"some other text\", fg=\"cyan\", bg=\"white\", style=\"underline\")  # write to stdout\n    some other text\n\n\n\ud83d\udc09 Path Utilities\n------------------\n\n**vistir** provides utilities for interacting with filesystem paths:\n\n    * ``vistir.path.get_converted_relative_path``\n    * ``vistir.path.normalize_path``\n    * ``vistir.path.is_in_path``\n    * ``vistir.path.handle_remove_readonly``\n    * ``vistir.path.is_file_url``\n    * ``vistir.path.is_readonly_path``\n    * ``vistir.path.is_valid_url``\n    * ``vistir.path.mkdir_p``\n    * ``vistir.path.ensure_mkdir_p``\n    * ``vistir.path.create_tracked_tempdir``\n    * ``vistir.path.create_tracked_tempfile``\n    * ``vistir.path.path_to_url``\n    * ``vistir.path.rmtree``\n    * ``vistir.path.safe_expandvars``\n    * ``vistir.path.set_write_bit``\n    * ``vistir.path.url_to_path``\n    * ``vistir.path.walk_up``\n\n\n.. _`normalize_path`:\n\n**normalize_path**\n//////////////////\n\nReturn a case-normalized absolute variable-expanded path.\n\n\n.. code:: python\n\n    >>> vistir.path.normalize_path(\"~/${USER}\")\n    /home/user/user\n\n\n.. _`is_in_path`:\n\n**is_in_path**\n//////////////\n\nDetermine if the provided full path is in the given parent root.\n\n\n.. code:: python\n\n    >>> vistir.path.is_in_path(\"~/.pyenv/versions/3.7.1/bin/python\", \"${PYENV_ROOT}/versions\")\n    True\n\n\n.. _`get_converted_relative_path`:\n\n**get_converted_relative_path**\n////////////////////////////////\n\nConvert the supplied path to a relative path (relative to ``os.curdir``)\n\n\n.. code:: python\n\n    >>> os.chdir('/home/user/code/myrepo/myfolder')\n    >>> vistir.path.get_converted_relative_path('/home/user/code/file.zip')\n    './../../file.zip'\n    >>> vistir.path.get_converted_relative_path('/home/user/code/myrepo/myfolder/mysubfolder')\n    './mysubfolder'\n    >>> vistir.path.get_converted_relative_path('/home/user/code/myrepo/myfolder')\n    '.'\n\n\n.. _`handle_remove_readonly`:\n\n**handle_remove_readonly**\n///////////////////////////\n\nError handler for shutil.rmtree.\n\nWindows source repo folders are read-only by default, so this error handler attempts to\nset them as writeable and then proceed with deletion.\n\nThis function will call check ``vistir.path.is_readonly_path`` before attempting to\ncall ``vistir.path.set_write_bit`` on the target path and try again.\n\n\n.. _`is_file_url`:\n\n**is_file_url**\n////////////////\n\nChecks whether the given url is a properly formatted ``file://`` uri.\n\n.. code:: python\n\n    >>> vistir.path.is_file_url('file:///home/user/somefile.zip')\n    True\n    >>> vistir.path.is_file_url('/home/user/somefile.zip')\n    False\n\n\n.. _`is_readonly_path`:\n\n**is_readonly_path**\n/////////////////////\n\nCheck if a provided path exists and is readonly by checking for ``bool(path.stat & stat.S_IREAD) and not os.access(path, os.W_OK)``\n\n.. code:: python\n\n    >>> vistir.path.is_readonly_path('/etc/passwd')\n    True\n    >>> vistir.path.is_readonly_path('/home/user/.bashrc')\n    False\n\n\n.. _`is_valid_url`:\n\n**is_valid_url**\n/////////////////\n\nChecks whether a URL is valid and parseable by checking for the presence of a scheme and\na netloc.\n\n.. code:: python\n\n    >>> vistir.path.is_valid_url(\"https://google.com\")\n    True\n    >>> vistir.path.is_valid_url(\"/home/user/somefile\")\n    False\n\n\n.. _`mkdir_p`:\n\n**mkdir_p**\n/////////////\n\nRecursively creates the target directory and all of its parents if they do not\nalready exist.  Fails silently if they do.\n\n.. code:: python\n\n    >>> os.mkdir('/tmp/test_dir')\n    >>> os.listdir('/tmp/test_dir')\n    []\n    >>> vistir.path.mkdir_p('/tmp/test_dir/child/subchild/subsubchild')\n    >>> os.listdir('/tmp/test_dir/child/subchild')\n    ['subsubchild']\n\n\n.. _`ensure_mkdir_p`:\n\n**ensure_mkdir_p**\n///////////////////\n\nA decorator which ensures that the caller function's return value is created as a\ndirectory on the filesystem.\n\n.. code:: python\n\n    >>> @ensure_mkdir_p\n    def return_fake_value(path):\n        return path\n    >>> return_fake_value('/tmp/test_dir')\n    >>> os.listdir('/tmp/test_dir')\n    []\n    >>> return_fake_value('/tmp/test_dir/child/subchild/subsubchild')\n    >>> os.listdir('/tmp/test_dir/child/subchild')\n    ['subsubchild']\n\n\n.. _`create_tracked_tempdir`:\n\n**create_tracked_tempdir**\n////////////////////////////\n\nCreates a tracked temporary directory using ``vistir.path.TemporaryDirectory``, but does\nnot remove the directory when the return value goes out of scope, instead registers a\nhandler to cleanup on program exit.\n\n.. code:: python\n\n    >>> temp_dir = vistir.path.create_tracked_tempdir(prefix=\"test_dir\")\n    >>> assert temp_dir.startswith(\"test_dir\")\n    True\n    >>> with vistir.path.create_tracked_tempdir(prefix=\"test_dir\") as temp_dir:\n        with io.open(os.path.join(temp_dir, \"test_file.txt\"), \"w\") as fh:\n            fh.write(\"this is a test\")\n    >>> os.listdir(temp_dir)\n\n\n.. _`create_tracked_tempfile`:\n\n**create_tracked_tempfile**\n////////////////////////////\n\nCreates a tracked temporary file using ``vistir.compat.NamedTemporaryFile``, but creates\na ``weakref.finalize`` call which will detach on garbage collection to close and delete\nthe file.\n\n.. code:: python\n\n    >>> temp_file = vistir.path.create_tracked_tempfile(prefix=\"requirements\", suffix=\"txt\")\n    >>> temp_file.write(\"some\\nstuff\")\n    >>> exit()\n\n\n.. _`path_to_url`:\n\n**path_to_url**\n////////////////\n\nConvert the supplied local path to a file uri.\n\n.. code:: python\n\n    >>> path_to_url(\"/home/user/code/myrepo/myfile.zip\")\n    'file:///home/user/code/myrepo/myfile.zip'\n\n\n.. _`rmtree`:\n\n**rmtree**\n///////////\n\nStand-in for ``shutil.rmtree`` with additional error-handling.\n\nThis version of `rmtree` handles read-only paths, especially in the case of index files\nwritten by certain source control systems.\n\n.. code:: python\n\n    >>> vistir.path.rmtree('/tmp/test_dir')\n    >>> [d for d in os.listdir('/tmp') if 'test_dir' in d]\n    []\n\n.. note::\n\n    Setting `ignore_errors=True` may cause this to silently fail to delete the path\n\n\n.. _`safe_expandvars`:\n\n**safe_expandvars**\n////////////////////\n\nCall ``os.path.expandvars`` if value is a string, otherwise do nothing.\n\n.. code:: python\n\n    >>> os.environ['TEST_VAR'] = \"MY_TEST_VALUE\"\n    >>> vistir.path.safe_expandvars(\"https://myuser:${TEST_VAR}@myfakewebsite.com\")\n    'https://myuser:MY_TEST_VALUE@myfakewebsite.com'\n\n\n.. _`set_write_bit`:\n\n**set_write_bit**\n//////////////////\n\nSet read-write permissions for the current user on the target path.  Fail silently\nif the path doesn't exist.\n\n.. code:: python\n\n    >>> vistir.path.set_write_bit('/path/to/some/file')\n    >>> with open('/path/to/some/file', 'w') as fh:\n            fh.write(\"test text!\")\n\n\n.. _`url_to_path`:\n\n**url_to_path**\n////////////////\n\nConvert a valid file url to a local filesystem path. Follows logic taken from pip.\n\n.. code:: python\n\n    >>> vistir.path.url_to_path(\"file:///home/user/somefile.zip\")\n    '/home/user/somefile.zip'\n\n\n",
  "requires_dist": [
    "colorama (!=0.4.2,>=0.3.4)",
    "six",
    "pathlib2 ; python_version < \"3.6\"",
    "backports.functools-lru-cache ; python_version == \"2.7\"",
    "backports.shutil-get-terminal-size ; python_version == \"2.7\"",
    "backports.weakref ; python_version == \"2.7\"",
    "pre-commit ; extra == 'dev'",
    "coverage ; extra == 'dev'",
    "isort ; extra == 'dev'",
    "flake8 ; extra == 'dev'",
    "rope ; extra == 'dev'",
    "invoke ; extra == 'dev'",
    "parver ; extra == 'dev'",
    "sphinx ; extra == 'dev'",
    "sphinx-rtd-theme ; extra == 'dev'",
    "flake8-bugbear ; (python_version >= \"3.5\") and extra == 'dev'",
    "black ; (python_version >= \"3.6\") and extra == 'dev'",
    "requests ; extra == 'requests'",
    "yaspin ; extra == 'spinner'",
    "hypothesis ; extra == 'tests'",
    "hypothesis-fspaths ; extra == 'tests'",
    "pytest ; extra == 'tests'",
    "pytest-rerunfailures (<9.0) ; extra == 'tests'",
    "pytest-xdist ; extra == 'tests'",
    "pytest-timeout ; extra == 'tests'",
    "readme-renderer[md] ; extra == 'tests'",
    "twine ; extra == 'tests'",
    "mock ; (python_version < \"3.3\") and extra == 'tests'",
    "typing ; (python_version <= \"3.4\") and extra == 'typing'",
    "mypy ; (python_version >= \"3.4\") and extra == 'typing'",
    "mypy-extensions ; (python_version >= \"3.4\") and extra == 'typing'",
    "mypytools ; (python_version >= \"3.4\") and extra == 'typing'",
    "pytype ; (python_version >= \"3.4\") and extra == 'typing'",
    "typed-ast ; (python_version >= \"3.4\") and extra == 'typing'"
  ],
  "requires_python": "!=3.0,!=3.1,!=3.2,!=3.3,>=2.7",
  "current_version": "0.5.2",
  "released_versions": [
    "0.1.0",
    "0.1.1",
    "0.1.2",
    "0.1.3",
    "0.1.4",
    "0.1.5",
    "0.1.6",
    "0.1.7",
    "0.2.0",
    "0.2.1",
    "0.2.2",
    "0.2.3",
    "0.2.4",
    "0.2.5",
    "0.3.0",
    "0.3.1",
    "0.4.0",
    "0.4.1",
    "0.4.2",
    "0.4.3",
    "0.5.0",
    "0.5.1",
    "0.5.2"
  ]
}