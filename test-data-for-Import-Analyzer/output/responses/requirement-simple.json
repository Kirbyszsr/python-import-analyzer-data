{
  "name": "responses",
  "description": "Responses\n=========\n\n.. image:: https://img.shields.io/pypi/v/responses.svg\n    :target: https://pypi.python.org/pypi/responses/\n\n..  image:: https://travis-ci.org/getsentry/responses.svg?branch=master\n    :target: https://travis-ci.org/getsentry/responses\n\n.. image:: https://img.shields.io/pypi/pyversions/responses.svg\n    :target: https://pypi.org/project/responses/\n\nA utility library for mocking out the ``requests`` Python library.\n\n..  note::\n\n    Responses requires Python 2.7 or newer, and requests >= 2.0\n\n\nInstalling\n----------\n\n``pip install responses``\n\n\nBasics\n------\n\nThe core of ``responses`` comes from registering mock responses:\n\n..  code-block:: python\n\n    import responses\n    import requests\n\n    @responses.activate\n    def test_simple():\n        responses.add(responses.GET, 'http://twitter.com/api/1/foobar',\n                      json={'error': 'not found'}, status=404)\n\n        resp = requests.get('http://twitter.com/api/1/foobar')\n\n        assert resp.json() == {\"error\": \"not found\"}\n\n        assert len(responses.calls) == 1\n        assert responses.calls[0].request.url == 'http://twitter.com/api/1/foobar'\n        assert responses.calls[0].response.text == '{\"error\": \"not found\"}'\n\nIf you attempt to fetch a url which doesn't hit a match, ``responses`` will raise\na ``ConnectionError``:\n\n..  code-block:: python\n\n    import responses\n    import requests\n\n    from requests.exceptions import ConnectionError\n\n    @responses.activate\n    def test_simple():\n        with pytest.raises(ConnectionError):\n            requests.get('http://twitter.com/api/1/foobar')\n\nLastly, you can pass an ``Exception`` as the body to trigger an error on the request:\n\n..  code-block:: python\n\n    import responses\n    import requests\n\n    @responses.activate\n    def test_simple():\n        responses.add(responses.GET, 'http://twitter.com/api/1/foobar',\n                      body=Exception('...'))\n        with pytest.raises(Exception):\n            requests.get('http://twitter.com/api/1/foobar')\n\n\nResponse Parameters\n-------------------\n\nResponses are automatically registered via params on ``add``, but can also be\npassed directly:\n\n..  code-block:: python\n\n    import responses\n\n    responses.add(\n        responses.Response(\n            method='GET',\n            url='http://example.com',\n        )\n    )\n\nThe following attributes can be passed to a Response mock:\n\nmethod (``str``)\n    The HTTP method (GET, POST, etc).\n\nurl (``str`` or compiled regular expression)\n    The full resource URL.\n\nmatch_querystring (``bool``)\n    Include the query string when matching requests.\n    Enabled by default if the response URL contains a query string,\n    disabled if it doesn't or the URL is a regular expression.\n\nbody (``str`` or ``BufferedReader``)\n    The response body.\n\njson\n    A Python object representing the JSON response body. Automatically configures\n    the appropriate Content-Type.\n\nstatus (``int``)\n    The HTTP status code.\n\ncontent_type (``content_type``)\n    Defaults to ``text/plain``.\n\nheaders (``dict``)\n    Response headers.\n\nstream (``bool``)\n    Disabled by default. Indicates the response should use the streaming API.\n\nmatch (``list``)\n    A list of callbacks to match requests based on request body contents.\n\n\nMatching Request Parameters\n---------------------------\n\nWhen adding responses for endpoints that are sent request data you can add\nmatchers to ensure your code is sending the right parameters and provide\ndifferent responses based on the request body contents. Responses provides\nmatchers for JSON and URLencoded request bodies and you can supply your own for\nother formats.\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n    @responses.activate\n    def test_calc_api():\n        responses.add(\n            responses.POST,\n            url='http://calc.com/sum',\n            body=\"4\",\n            match=[\n                responses.urlencoded_params_matcher({\"left\": \"1\", \"right\": \"3\"})\n            ]\n        )\n        requests.post(\"http://calc.com/sum\", data={\"left\": 1, \"right\": 3})\n\nMatching JSON encoded data can be done with ``responses.json_params_matcher()``.\nIf your application uses other encodings you can build your own matcher that\nreturns ``True`` or ``False`` if the request parameters match. Your matcher can\nexpect a ``request_body`` parameter to be provided by responses.\n\nDynamic Responses\n-----------------\n\nYou can utilize callbacks to provide dynamic responses. The callback must return\na tuple of (``status``, ``headers``, ``body``).\n\n..  code-block:: python\n\n    import json\n\n    import responses\n    import requests\n\n    @responses.activate\n    def test_calc_api():\n\n        def request_callback(request):\n            payload = json.loads(request.body)\n            resp_body = {'value': sum(payload['numbers'])}\n            headers = {'request-id': '728d329e-0e86-11e4-a748-0c84dc037c13'}\n            return (200, headers, json.dumps(resp_body))\n\n        responses.add_callback(\n            responses.POST, 'http://calc.com/sum',\n            callback=request_callback,\n            content_type='application/json',\n        )\n\n        resp = requests.post(\n            'http://calc.com/sum',\n            json.dumps({'numbers': [1, 2, 3]}),\n            headers={'content-type': 'application/json'},\n        )\n\n        assert resp.json() == {'value': 6}\n\n        assert len(responses.calls) == 1\n        assert responses.calls[0].request.url == 'http://calc.com/sum'\n        assert responses.calls[0].response.text == '{\"value\": 6}'\n        assert (\n            responses.calls[0].response.headers['request-id'] ==\n            '728d329e-0e86-11e4-a748-0c84dc037c13'\n        )\n\nYou can also pass a compiled regex to ``add_callback`` to match multiple urls:\n\n..  code-block:: python\n\n    import re, json\n\n    from functools import reduce\n\n    import responses\n    import requests\n\n    operators = {\n      'sum': lambda x, y: x+y,\n      'prod': lambda x, y: x*y,\n      'pow': lambda x, y: x**y\n    }\n\n    @responses.activate\n    def test_regex_url():\n\n        def request_callback(request):\n            payload = json.loads(request.body)\n            operator_name = request.path_url[1:]\n\n            operator = operators[operator_name]\n\n            resp_body = {'value': reduce(operator, payload['numbers'])}\n            headers = {'request-id': '728d329e-0e86-11e4-a748-0c84dc037c13'}\n            return (200, headers, json.dumps(resp_body))\n\n        responses.add_callback(\n            responses.POST,\n            re.compile('http://calc.com/(sum|prod|pow|unsupported)'),\n            callback=request_callback,\n            content_type='application/json',\n        )\n\n        resp = requests.post(\n            'http://calc.com/prod',\n            json.dumps({'numbers': [2, 3, 4]}),\n            headers={'content-type': 'application/json'},\n        )\n        assert resp.json() == {'value': 24}\n\n    test_regex_url()\n\n\nIf you want to pass extra keyword arguments to the callback function, for example when reusing\na callback function to give a slightly different result, you can use ``functools.partial``:\n\n.. code-block:: python\n\n    from functools import partial\n\n    ...\n\n        def request_callback(request, id=None):\n            payload = json.loads(request.body)\n            resp_body = {'value': sum(payload['numbers'])}\n            headers = {'request-id': id}\n            return (200, headers, json.dumps(resp_body))\n\n        responses.add_callback(\n            responses.POST, 'http://calc.com/sum',\n            callback=partial(request_callback, id='728d329e-0e86-11e4-a748-0c84dc037c13'),\n            content_type='application/json',\n        )\n\n\nYou can see params passed in the original ``request`` in ``responses.calls[].request.params``:\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n    @responses.activate\n    def test_request_params():\n        responses.add(\n            method=responses.GET,\n            url=\"http://example.com?hello=world\",\n            body=\"test\",\n            match_querystring=False,\n        )\n\n        resp = requests.get('http://example.com', params={\"hello\": \"world\"})\n        assert responses.calls[0].request.params == {\"hello\": \"world\"}\n\nResponses as a context manager\n------------------------------\n\n..  code-block:: python\n\n    import responses\n    import requests\n\n    def test_my_api():\n        with responses.RequestsMock() as rsps:\n            rsps.add(responses.GET, 'http://twitter.com/api/1/foobar',\n                     body='{}', status=200,\n                     content_type='application/json')\n            resp = requests.get('http://twitter.com/api/1/foobar')\n\n            assert resp.status_code == 200\n\n        # outside the context manager requests will hit the remote server\n        resp = requests.get('http://twitter.com/api/1/foobar')\n        resp.status_code == 404\n\nResponses as a pytest fixture\n-----------------------------\n\n.. code-block:: python\n\n    @pytest.fixture\n    def mocked_responses():\n        with responses.RequestsMock() as rsps:\n            yield rsps\n\n    def test_api(mocked_responses):\n        mocked_responses.add(\n            responses.GET, 'http://twitter.com/api/1/foobar',\n            body='{}', status=200,\n            content_type='application/json')\n        resp = requests.get('http://twitter.com/api/1/foobar')\n        assert resp.status_code == 200\n\nResponses inside a unittest setUp()\n-----------------------------------\n\nWhen run with unittest tests, this can be used to set up some\ngeneric class-level responses, that may be complemented by each test\n\n.. code-block:: python\n\n    def setUp():\n        self.responses = responses.RequestsMock()\n        self.responses.start()\n\n        # self.responses.add(...)\n\n        self.addCleanup(self.responses.stop)\n        self.addCleanup(self.responses.reset)\n\n    def test_api(self):\n        self.responses.add(\n            responses.GET, 'http://twitter.com/api/1/foobar',\n            body='{}', status=200,\n            content_type='application/json')\n        resp = requests.get('http://twitter.com/api/1/foobar')\n        assert resp.status_code == 200\n\nAssertions on declared responses\n--------------------------------\n\nWhen used as a context manager, Responses will, by default, raise an assertion\nerror if a url was registered but not accessed. This can be disabled by passing\nthe ``assert_all_requests_are_fired`` value:\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n    def test_my_api():\n        with responses.RequestsMock(assert_all_requests_are_fired=False) as rsps:\n            rsps.add(responses.GET, 'http://twitter.com/api/1/foobar',\n                     body='{}', status=200,\n                     content_type='application/json')\n\nassert_call_count\n-----------------\n\nAssert that the request was called exactly n times.\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n    @responses.activate\n    def test_assert_call_count():\n        responses.add(responses.GET, \"http://example.com\")\n\n        requests.get(\"http://example.com\")\n        assert responses.assert_call_count(\"http://example.com\", 1) is True\n\n        requests.get(\"http://example.com\")\n        with pytest.raises(AssertionError) as excinfo:\n            responses.assert_call_count(\"http://example.com\", 1)\n        assert \"Expected URL 'http://example.com' to be called 1 times. Called 2 times.\" in str(excinfo.value)\n\n\nMultiple Responses\n------------------\n\nYou can also add multiple responses for the same url:\n\n..  code-block:: python\n\n    import responses\n    import requests\n\n    @responses.activate\n    def test_my_api():\n        responses.add(responses.GET, 'http://twitter.com/api/1/foobar', status=500)\n        responses.add(responses.GET, 'http://twitter.com/api/1/foobar',\n                      body='{}', status=200,\n                      content_type='application/json')\n\n        resp = requests.get('http://twitter.com/api/1/foobar')\n        assert resp.status_code == 500\n        resp = requests.get('http://twitter.com/api/1/foobar')\n        assert resp.status_code == 200\n\n\nUsing a callback to modify the response\n---------------------------------------\n\nIf you use customized processing in `requests` via subclassing/mixins, or if you\nhave library tools that interact with `requests` at a low level, you may need\nto add extended processing to the mocked Response object to fully simulate the\nenvironment for your tests.  A `response_callback` can be used, which will be\nwrapped by the library before being returned to the caller.  The callback\naccepts a `response` as it's single argument, and is expected to return a\nsingle `response` object.\n\n..  code-block:: python\n\n    import responses\n    import requests\n\n    def response_callback(resp):\n        resp.callback_processed = True\n        return resp\n\n    with responses.RequestsMock(response_callback=response_callback) as m:\n        m.add(responses.GET, 'http://example.com', body=b'test')\n        resp = requests.get('http://example.com')\n        assert resp.text == \"test\"\n        assert hasattr(resp, 'callback_processed')\n        assert resp.callback_processed is True\n\n\nPassing through real requests\n-----------------------------\n\nIn some cases you may wish to allow for certain requests to pass through responses\nand hit a real server. This can be done with the ``add_passthru`` methods:\n\n.. code-block:: python\n\n    import responses\n\n    @responses.activate\n    def test_my_api():\n        responses.add_passthru('https://percy.io')\n\nThis will allow any requests matching that prefix, that is otherwise not registered\nas a mock response, to passthru using the standard behavior.\n\nRegex can be used like:\n\n.. code-block:: python\n\n    responses.add_passthru(re.compile('https://percy.io/\\\\w+'))\n\n\nViewing/Modifying registered responses\n--------------------------------------\n\nRegistered responses are available as a public method of the RequestMock\ninstance. It is sometimes useful for debugging purposes to view the stack of\nregistered responses which can be accessed via ``responses.registered()``.\n\nThe ``replace`` function allows a previously registered ``response`` to be\nchanged. The method signature is identical to ``add``. ``response`` s are\nidentified using ``method`` and ``url``. Only the first matched ``response`` is\nreplaced.\n\n..  code-block:: python\n\n    import responses\n    import requests\n\n    @responses.activate\n    def test_replace():\n\n        responses.add(responses.GET, 'http://example.org', json={'data': 1})\n        responses.replace(responses.GET, 'http://example.org', json={'data': 2})\n\n        resp = requests.get('http://example.org')\n\n        assert resp.json() == {'data': 2}\n\n\nThe ``upsert`` function allows a previously registered ``response`` to be\nchanged like ``replace``. If the response is registered, the ``upsert`` function\nwill registered it like ``add``.\n\n``remove`` takes a ``method`` and ``url`` argument and will remove **all**\nmatched responses from the registered list.\n\nFinally, ``reset`` will reset all registered responses.\n\nContributing\n------------\n\nResponses uses several linting and autoformatting utilities, so it's important that when\nsubmitting patches you use the appropriate toolchain:\n\nClone the repository:\n\n.. code-block:: shell\n\n    git clone https://github.com/getsentry/responses.git\n\nCreate an environment (e.g. with ``virtualenv``):\n\n.. code-block:: shell\n\n    virtualenv .env && source .env/bin/activate\n\nConfigure development requirements:\n\n.. code-block:: shell\n\n    make develop\n\nResponses uses `Pytest <https://docs.pytest.org/en/latest/>`_ for\ntesting. You can run all tests by:\n\n.. code-block:: shell\n\n    pytest\n\nAnd run a single test by:\n\n.. code-block:: shell\n\n    pytest -k '<test_function_name>'\n\n\n",
  "requires_dist": [
    "requests (>=2.0)",
    "urllib3 (>=1.25.10)",
    "six",
    "mock ; python_version < \"3.3\"",
    "cookies ; python_version < \"3.4\"",
    "coverage (<6.0.0,>=3.7.1) ; extra == 'tests'",
    "pytest-cov ; extra == 'tests'",
    "pytest-localserver ; extra == 'tests'",
    "flake8 ; extra == 'tests'",
    "pytest (<5.0,>=4.6) ; (python_version < \"3.5\") and extra == 'tests'",
    "pytest (>=4.6) ; (python_version >= \"3.5\") and extra == 'tests'",
    "mypy ; (python_version >= \"3.5\") and extra == 'tests'"
  ],
  "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*",
  "current_version": "0.13.3",
  "released_versions": [
    "0.1.0",
    "0.1.1",
    "0.10.0",
    "0.10.1",
    "0.10.11",
    "0.10.12",
    "0.10.14",
    "0.10.15",
    "0.10.16",
    "0.10.2",
    "0.10.3",
    "0.10.4",
    "0.10.5",
    "0.10.6",
    "0.10.7",
    "0.10.8",
    "0.10.9",
    "0.11.0",
    "0.12.0",
    "0.12.1",
    "0.13.0",
    "0.13.1",
    "0.13.2",
    "0.13.3",
    "0.2.0",
    "0.2.1",
    "0.2.2",
    "0.3.0",
    "0.4.0",
    "0.5.0",
    "0.5.1",
    "0.6.0",
    "0.6.1",
    "0.6.2",
    "0.7.0",
    "0.8.0",
    "0.8.1",
    "0.9.0"
  ]
}