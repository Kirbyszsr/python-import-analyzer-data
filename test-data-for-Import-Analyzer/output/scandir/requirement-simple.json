{
  "name": "scandir",
  "description": "scandir, a better directory iterator and faster os.walk()\r\n=========================================================\r\n\r\n.. image:: https://img.shields.io/pypi/v/scandir.svg\r\n   :target: https://pypi.python.org/pypi/scandir\r\n   :alt: scandir on PyPI (Python Package Index)\r\n\r\n.. image:: https://travis-ci.org/benhoyt/scandir.svg?branch=master\r\n   :target: https://travis-ci.org/benhoyt/scandir\r\n   :alt: Travis CI tests (Linux)\r\n\r\n.. image:: https://ci.appveyor.com/api/projects/status/github/benhoyt/scandir?branch=master&svg=true\r\n   :target: https://ci.appveyor.com/project/benhoyt/scandir\r\n   :alt: Appveyor tests (Windows)\r\n\r\n\r\n``scandir()`` is a directory iteration function like ``os.listdir()``,\r\nexcept that instead of returning a list of bare filenames, it yields\r\n``DirEntry`` objects that include file type and stat information along\r\nwith the name. Using ``scandir()`` increases the speed of ``os.walk()``\r\nby 2-20 times (depending on the platform and file system) by avoiding\r\nunnecessary calls to ``os.stat()`` in most cases.\r\n\r\n\r\nNow included in a Python near you!\r\n----------------------------------\r\n\r\n``scandir`` has been included in the Python 3.5 standard library as\r\n``os.scandir()``, and the related performance improvements to\r\n``os.walk()`` have also been included. So if you're lucky enough to be\r\nusing Python 3.5 (release date September 13, 2015) you get the benefit\r\nimmediately, otherwise just\r\n`download this module from PyPI <https://pypi.python.org/pypi/scandir>`_,\r\ninstall it with ``pip install scandir``, and then do something like\r\nthis in your code:\r\n\r\n.. code-block:: python\r\n\r\n    # Use the built-in version of scandir/walk if possible, otherwise\r\n    # use the scandir module version\r\n    try:\r\n        from os import scandir, walk\r\n    except ImportError:\r\n        from scandir import scandir, walk\r\n\r\n`PEP 471 <https://www.python.org/dev/peps/pep-0471/>`_, which is the\r\nPEP that proposes including ``scandir`` in the Python standard library,\r\nwas `accepted <https://mail.python.org/pipermail/python-dev/2014-July/135561.html>`_\r\nin July 2014 by Victor Stinner, the BDFL-delegate for the PEP.\r\n\r\nThis ``scandir`` module is intended to work on Python 2.7+ and Python\r\n3.4+ (and it has been tested on those versions).\r\n\r\n\r\nBackground\r\n----------\r\n\r\nPython's built-in ``os.walk()`` is significantly slower than it needs to be,\r\nbecause -- in addition to calling ``listdir()`` on each directory -- it calls\r\n``stat()`` on each file to determine whether the filename is a directory or not.\r\nBut both ``FindFirstFile`` / ``FindNextFile`` on Windows and ``readdir`` on Linux/OS\r\nX already tell you whether the files returned are directories or not, so\r\nno further ``stat`` system calls are needed. In short, you can reduce the number\r\nof system calls from about 2N to N, where N is the total number of files and\r\ndirectories in the tree.\r\n\r\nIn practice, removing all those extra system calls makes ``os.walk()`` about\r\n**7-50 times as fast on Windows, and about 3-10 times as fast on Linux and Mac OS\r\nX.** So we're not talking about micro-optimizations. See more benchmarks\r\nin the \"Benchmarks\" section below.\r\n\r\nSomewhat relatedly, many people have also asked for a version of\r\n``os.listdir()`` that yields filenames as it iterates instead of returning them\r\nas one big list. This improves memory efficiency for iterating very large\r\ndirectories.\r\n\r\nSo as well as a faster ``walk()``, scandir adds a new ``scandir()`` function.\r\nThey're pretty easy to use, but see \"The API\" below for the full docs.\r\n\r\n\r\nBenchmarks\r\n----------\r\n\r\nBelow are results showing how many times as fast ``scandir.walk()`` is than\r\n``os.walk()`` on various systems, found by running ``benchmark.py`` with no\r\narguments:\r\n\r\n====================   ==============   =============\r\nSystem version         Python version   Times as fast\r\n====================   ==============   =============\r\nWindows 7 64-bit       2.7.7 64-bit     10.4\r\nWindows 7 64-bit SSD   2.7.7 64-bit     10.3\r\nWindows 7 64-bit NFS   2.7.6 64-bit     36.8\r\nWindows 7 64-bit SSD   3.4.1 64-bit     9.9\r\nWindows 7 64-bit SSD   3.5.0 64-bit     9.5\r\nUbuntu 14.04 64-bit    2.7.6 64-bit     5.8\r\nMac OS X 10.9.3        2.7.5 64-bit     3.8\r\n====================   ==============   =============\r\n\r\nAll of the above tests were done using the fast C version of scandir\r\n(source code in ``_scandir.c``).\r\n\r\nNote that the gains are less than the above on smaller directories and greater\r\non larger directories. This is why ``benchmark.py`` creates a test directory\r\ntree with a standardized size.\r\n\r\n\r\nThe API\r\n-------\r\n\r\nwalk()\r\n~~~~~~\r\n\r\nThe API for ``scandir.walk()`` is exactly the same as ``os.walk()``, so just\r\n`read the Python docs <https://docs.python.org/3.5/library/os.html#os.walk>`_.\r\n\r\nscandir()\r\n~~~~~~~~~\r\n\r\nThe full docs for ``scandir()`` and the ``DirEntry`` objects it yields are\r\navailable in the `Python documentation here <https://docs.python.org/3.5/library/os.html#os.scandir>`_. \r\nBut below is a brief summary as well.\r\n\r\n    scandir(path='.') -> iterator of DirEntry objects for given path\r\n\r\nLike ``listdir``, ``scandir`` calls the operating system's directory\r\niteration system calls to get the names of the files in the given\r\n``path``, but it's different from ``listdir`` in two ways:\r\n\r\n* Instead of returning bare filename strings, it returns lightweight\r\n  ``DirEntry`` objects that hold the filename string and provide\r\n  simple methods that allow access to the additional data the\r\n  operating system may have returned.\r\n\r\n* It returns a generator instead of a list, so that ``scandir`` acts\r\n  as a true iterator instead of returning the full list immediately.\r\n\r\n``scandir()`` yields a ``DirEntry`` object for each file and\r\nsub-directory in ``path``. Just like ``listdir``, the ``'.'``\r\nand ``'..'`` pseudo-directories are skipped, and the entries are\r\nyielded in system-dependent order. Each ``DirEntry`` object has the\r\nfollowing attributes and methods:\r\n\r\n* ``name``: the entry's filename, relative to the scandir ``path``\r\n  argument (corresponds to the return values of ``os.listdir``)\r\n\r\n* ``path``: the entry's full path name (not necessarily an absolute\r\n  path) -- the equivalent of ``os.path.join(scandir_path, entry.name)``\r\n\r\n* ``is_dir(*, follow_symlinks=True)``: similar to\r\n  ``pathlib.Path.is_dir()``, but the return value is cached on the\r\n  ``DirEntry`` object; doesn't require a system call in most cases;\r\n  don't follow symbolic links if ``follow_symlinks`` is False\r\n\r\n* ``is_file(*, follow_symlinks=True)``: similar to\r\n  ``pathlib.Path.is_file()``, but the return value is cached on the\r\n  ``DirEntry`` object; doesn't require a system call in most cases; \r\n  don't follow symbolic links if ``follow_symlinks`` is False\r\n\r\n* ``is_symlink()``: similar to ``pathlib.Path.is_symlink()``, but the\r\n  return value is cached on the ``DirEntry`` object; doesn't require a\r\n  system call in most cases\r\n\r\n* ``stat(*, follow_symlinks=True)``: like ``os.stat()``, but the\r\n  return value is cached on the ``DirEntry`` object; does not require a\r\n  system call on Windows (except for symlinks); don't follow symbolic links\r\n  (like ``os.lstat()``) if ``follow_symlinks`` is False\r\n\r\n* ``inode()``: return the inode number of the entry; the return value\r\n  is cached on the ``DirEntry`` object\r\n\r\nHere's a very simple example of ``scandir()`` showing use of the\r\n``DirEntry.name`` attribute and the ``DirEntry.is_dir()`` method:\r\n\r\n.. code-block:: python\r\n\r\n    def subdirs(path):\r\n        \"\"\"Yield directory names not starting with '.' under given path.\"\"\"\r\n        for entry in os.scandir(path):\r\n            if not entry.name.startswith('.') and entry.is_dir():\r\n                yield entry.name\r\n\r\nThis ``subdirs()`` function will be significantly faster with scandir\r\nthan ``os.listdir()`` and ``os.path.isdir()`` on both Windows and POSIX\r\nsystems, especially on medium-sized or large directories.\r\n\r\n\r\nFurther reading\r\n---------------\r\n\r\n* `The Python docs for scandir <https://docs.python.org/3.5/library/os.html#os.scandir>`_\r\n* `PEP 471 <https://www.python.org/dev/peps/pep-0471/>`_, the\r\n  (now-accepted) Python Enhancement Proposal that proposed adding\r\n  ``scandir`` to the standard library -- a lot of details here,\r\n  including rejected ideas and previous discussion\r\n\r\n\r\nFlames, comments, bug reports\r\n-----------------------------\r\n\r\nPlease send flames, comments, and questions about scandir to Ben Hoyt:\r\n\r\nhttp://benhoyt.com/\r\n\r\nFile bug reports for the version in the Python 3.5 standard library\r\n`here <https://docs.python.org/3.5/bugs.html>`_, or file bug reports\r\nor feature requests for this module at the GitHub project page:\r\n\r\nhttps://github.com/benhoyt/scandir\r\n\r\n\r\n",
  "requires_dist": null,
  "requires_python": "",
  "current_version": "1.10.0",
  "released_versions": [
    "0.4",
    "0.5",
    "0.6",
    "0.8",
    "0.9",
    "1.0",
    "1.1",
    "1.10.0",
    "1.2",
    "1.3",
    "1.4",
    "1.5",
    "1.6",
    "1.7",
    "1.8",
    "1.9.0"
  ]
}