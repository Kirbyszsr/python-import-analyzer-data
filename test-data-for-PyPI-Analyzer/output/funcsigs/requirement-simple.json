{
  "name": "funcsigs",
  "description": ".. funcsigs documentation master file, created by\n   sphinx-quickstart on Fri Apr 20 20:27:52 2012.\n   You can adapt this file completely to your liking, but it should at least\n   contain the root `toctree` directive.\n\nIntroducing funcsigs\n====================\n\nThe Funcsigs Package\n--------------------\n\n``funcsigs`` is a backport of the `PEP 362`_ function signature features from\nPython 3.3's `inspect`_ module. The backport is compatible with Python 2.6, 2.7\nas well as 3.3 and up. 3.2 was supported by version 0.4, but with setuptools and\npip no longer supporting 3.2, we cannot make any statement about 3.2\ncompatibility.\n\nCompatibility\n`````````````\n\nThe ``funcsigs`` backport has been tested against:\n\n* CPython 2.6\n* CPython 2.7\n* CPython 3.3\n* CPython 3.4\n* CPython 3.5\n* CPython nightlies\n* PyPy and PyPy3(currently failing CI)\n\nContinuous integration testing is provided by `Travis CI`_.\n\nUnder Python 2.x there is a compatibility issue when a function is assigned to\nthe ``__wrapped__`` property of a class after it has been constructed.\nSimiliarily there under PyPy directly passing the ``__call__`` method of a\nbuiltin is also a compatibility issues.  Otherwise the functionality is\nbelieved to be uniform between both Python2 and Python3.\n\nIssues\n``````\n\nSource code for ``funcsigs`` is hosted on `GitHub`_. Any bug reports or feature\nrequests can be made using GitHub's `issues system`_. |build_status| |coverage|\n\nExample\n-------\n\nTo obtain a `Signature` object, pass the target function to the\n``funcsigs.signature`` function.\n\n.. code-block:: python\n\n    >>> from funcsigs import signature\n    >>> def foo(a, b=None, *args, **kwargs):\n    ...     pass\n    ...\n    >>> sig = signature(foo)\n    >>> sig\n    <funcsigs.Signature object at 0x...>\n    >>> sig.parameters\n    OrderedDict([('a', <Parameter at 0x... 'a'>), ('b', <Parameter at 0x... 'b'>), ('args', <Parameter at 0x... 'args'>), ('kwargs', <Parameter at 0x... 'kwargs'>)])\n    >>> sig.return_annotation\n    <class 'funcsigs._empty'>\n\nIntrospecting callables with the Signature object\n-------------------------------------------------\n\n.. note::\n\n   This section of documentation is a direct reproduction of the Python\n   standard library documentation for the inspect module.\n\nThe Signature object represents the call signature of a callable object and its\nreturn annotation.  To retrieve a Signature object, use the :func:`signature`\nfunction.\n\n.. function:: signature(callable)\n\n   Return a :class:`Signature` object for the given ``callable``::\n\n      >>> from funcsigs import signature\n      >>> def foo(a, *, b:int, **kwargs):\n      ...     pass\n\n      >>> sig = signature(foo)\n\n      >>> str(sig)\n      '(a, *, b:int, **kwargs)'\n\n      >>> str(sig.parameters['b'])\n      'b:int'\n\n      >>> sig.parameters['b'].annotation\n      <class 'int'>\n\n   Accepts a wide range of python callables, from plain functions and classes to\n   :func:`functools.partial` objects.\n\n   .. note::\n\n      Some callables may not be introspectable in certain implementations of\n      Python.  For example, in CPython, built-in functions defined in C provide\n      no metadata about their arguments.\n\n\n.. class:: Signature\n\n   A Signature object represents the call signature of a function and its return\n   annotation.  For each parameter accepted by the function it stores a\n   :class:`Parameter` object in its :attr:`parameters` collection.\n\n   Signature objects are *immutable*.  Use :meth:`Signature.replace` to make a\n   modified copy.\n\n   .. attribute:: Signature.empty\n\n      A special class-level marker to specify absence of a return annotation.\n\n   .. attribute:: Signature.parameters\n\n      An ordered mapping of parameters' names to the corresponding\n      :class:`Parameter` objects.\n\n   .. attribute:: Signature.return_annotation\n\n      The \"return\" annotation for the callable.  If the callable has no \"return\"\n      annotation, this attribute is set to :attr:`Signature.empty`.\n\n   .. method:: Signature.bind(*args, **kwargs)\n\n      Create a mapping from positional and keyword arguments to parameters.\n      Returns :class:`BoundArguments` if ``*args`` and ``**kwargs`` match the\n      signature, or raises a :exc:`TypeError`.\n\n   .. method:: Signature.bind_partial(*args, **kwargs)\n\n      Works the same way as :meth:`Signature.bind`, but allows the omission of\n      some required arguments (mimics :func:`functools.partial` behavior.)\n      Returns :class:`BoundArguments`, or raises a :exc:`TypeError` if the\n      passed arguments do not match the signature.\n\n   .. method:: Signature.replace(*[, parameters][, return_annotation])\n\n      Create a new Signature instance based on the instance replace was invoked\n      on.  It is possible to pass different ``parameters`` and/or\n      ``return_annotation`` to override the corresponding properties of the base\n      signature.  To remove return_annotation from the copied Signature, pass in\n      :attr:`Signature.empty`.\n\n      ::\n\n         >>> def test(a, b):\n         ...     pass\n         >>> sig = signature(test)\n         >>> new_sig = sig.replace(return_annotation=\"new return anno\")\n         >>> str(new_sig)\n         \"(a, b) -> 'new return anno'\"\n\n\n.. class:: Parameter\n\n   Parameter objects are *immutable*.  Instead of modifying a Parameter object,\n   you can use :meth:`Parameter.replace` to create a modified copy.\n\n   .. attribute:: Parameter.empty\n\n      A special class-level marker to specify absence of default values and\n      annotations.\n\n   .. attribute:: Parameter.name\n\n      The name of the parameter as a string.  Must be a valid python identifier\n      name (with the exception of ``POSITIONAL_ONLY`` parameters, which can have\n      it set to ``None``).\n\n   .. attribute:: Parameter.default\n\n      The default value for the parameter.  If the parameter has no default\n      value, this attribute is set to :attr:`Parameter.empty`.\n\n   .. attribute:: Parameter.annotation\n\n      The annotation for the parameter.  If the parameter has no annotation,\n      this attribute is set to :attr:`Parameter.empty`.\n\n   .. attribute:: Parameter.kind\n\n      Describes how argument values are bound to the parameter.  Possible values\n      (accessible via :class:`Parameter`, like ``Parameter.KEYWORD_ONLY``):\n\n      +------------------------+----------------------------------------------+\n      |    Name                | Meaning                                      |\n      +========================+==============================================+\n      | *POSITIONAL_ONLY*      | Value must be supplied as a positional       |\n      |                        | argument.                                    |\n      |                        |                                              |\n      |                        | Python has no explicit syntax for defining   |\n      |                        | positional-only parameters, but many built-in|\n      |                        | and extension module functions (especially   |\n      |                        | those that accept only one or two parameters)|\n      |                        | accept them.                                 |\n      +------------------------+----------------------------------------------+\n      | *POSITIONAL_OR_KEYWORD*| Value may be supplied as either a keyword or |\n      |                        | positional argument (this is the standard    |\n      |                        | binding behaviour for functions implemented  |\n      |                        | in Python.)                                  |\n      +------------------------+----------------------------------------------+\n      | *VAR_POSITIONAL*       | A tuple of positional arguments that aren't  |\n      |                        | bound to any other parameter. This           |\n      |                        | corresponds to a ``*args`` parameter in a    |\n      |                        | Python function definition.                  |\n      +------------------------+----------------------------------------------+\n      | *KEYWORD_ONLY*         | Value must be supplied as a keyword argument.|\n      |                        | Keyword only parameters are those which      |\n      |                        | appear after a ``*`` or ``*args`` entry in a |\n      |                        | Python function definition.                  |\n      +------------------------+----------------------------------------------+\n      | *VAR_KEYWORD*          | A dict of keyword arguments that aren't bound|\n      |                        | to any other parameter. This corresponds to a|\n      |                        | ``**kwargs`` parameter in a Python function  |\n      |                        | definition.                                  |\n      +------------------------+----------------------------------------------+\n\n      Example: print all keyword-only arguments without default values::\n\n         >>> def foo(a, b, *, c, d=10):\n         ...     pass\n\n         >>> sig = signature(foo)\n         >>> for param in sig.parameters.values():\n         ...     if (param.kind == param.KEYWORD_ONLY and\n         ...                        param.default is param.empty):\n         ...         print('Parameter:', param)\n         Parameter: c\n\n   .. method:: Parameter.replace(*[, name][, kind][, default][, annotation])\n\n      Create a new Parameter instance based on the instance replaced was invoked\n      on.  To override a :class:`Parameter` attribute, pass the corresponding\n      argument.  To remove a default value or/and an annotation from a\n      Parameter, pass :attr:`Parameter.empty`.\n\n      ::\n\n         >>> from funcsigs import Parameter\n         >>> param = Parameter('foo', Parameter.KEYWORD_ONLY, default=42)\n         >>> str(param)\n         'foo=42'\n\n         >>> str(param.replace()) # Will create a shallow copy of 'param'\n         'foo=42'\n\n         >>> str(param.replace(default=Parameter.empty, annotation='spam'))\n         \"foo:'spam'\"\n\n\n.. class:: BoundArguments\n\n   Result of a :meth:`Signature.bind` or :meth:`Signature.bind_partial` call.\n   Holds the mapping of arguments to the function's parameters.\n\n   .. attribute:: BoundArguments.arguments\n\n      An ordered, mutable mapping (:class:`collections.OrderedDict`) of\n      parameters' names to arguments' values.  Contains only explicitly bound\n      arguments.  Changes in :attr:`arguments` will reflect in :attr:`args` and\n      :attr:`kwargs`.\n\n      Should be used in conjunction with :attr:`Signature.parameters` for any\n      argument processing purposes.\n\n      .. note::\n\n         Arguments for which :meth:`Signature.bind` or\n         :meth:`Signature.bind_partial` relied on a default value are skipped.\n         However, if needed, it is easy to include them.\n\n      ::\n\n        >>> def foo(a, b=10):\n        ...     pass\n\n        >>> sig = signature(foo)\n        >>> ba = sig.bind(5)\n\n        >>> ba.args, ba.kwargs\n        ((5,), {})\n\n        >>> for param in sig.parameters.values():\n        ...     if param.name not in ba.arguments:\n        ...         ba.arguments[param.name] = param.default\n\n        >>> ba.args, ba.kwargs\n        ((5, 10), {})\n\n\n   .. attribute:: BoundArguments.args\n\n      A tuple of positional arguments values.  Dynamically computed from the\n      :attr:`arguments` attribute.\n\n   .. attribute:: BoundArguments.kwargs\n\n      A dict of keyword arguments values.  Dynamically computed from the\n      :attr:`arguments` attribute.\n\n   The :attr:`args` and :attr:`kwargs` properties can be used to invoke\n   functions::\n\n      def test(a, *, b):\n         ...\n\n      sig = signature(test)\n      ba = sig.bind(10, b=20)\n      test(*ba.args, **ba.kwargs)\n\n\n.. seealso::\n\n   :pep:`362` - Function Signature Object.\n      The detailed specification, implementation details and examples.\n\nCopyright\n---------\n\n*funcsigs* is a derived work of CPython under the terms of the `PSF License\nAgreement`_. The original CPython inspect module, its unit tests and\ndocumentation are the copyright of the Python Software Foundation. The derived\nwork is distributed under the `Apache License Version 2.0`_.\n\n.. _PSF License Agreement: http://docs.python.org/3/license.html#terms-and-conditions-for-accessing-or-otherwise-using-python\n.. _Apache License Version 2.0: http://opensource.org/licenses/Apache-2.0\n.. _GitHub: https://github.com/testing-cabal/funcsigs\n.. _PSF License Agreement: http://docs.python.org/3/license.html#terms-and-conditions-for-accessing-or-otherwise-using-python\n.. _Travis CI: http://travis-ci.org/\n.. _Read The Docs: http://funcsigs.readthedocs.org/\n.. _PEP 362: http://www.python.org/dev/peps/pep-0362/\n.. _inspect: http://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object\n.. _issues system: https://github.com/testing-cabal/funcsigs/issues\n\n.. |build_status| image:: https://secure.travis-ci.org/aliles/funcsigs.png?branch=master\n   :target: http://travis-ci.org/#!/aliles/funcsigs\n   :alt: Current build status\n\n.. |coverage| image:: https://coveralls.io/repos/aliles/funcsigs/badge.png?branch=master\n   :target: https://coveralls.io/r/aliles/funcsigs?branch=master\n   :alt: Coverage status\n\n.. |pypi_version| image:: https://pypip.in/v/funcsigs/badge.png\n   :target: https://crate.io/packages/funcsigs/\n   :alt: Latest PyPI version",
  "requires_dist": null,
  "requires_python": null,
  "current_version": "1.0.2",
  "released_versions": [
    "0.1",
    "0.2",
    "0.3",
    "0.4",
    "1.0.0",
    "1.0.1",
    "1.0.2"
  ]
}