{
  "name": "parameterized",
  "description": "Parameterized testing with any Python test framework\n====================================================\n\n.. image:: https://img.shields.io/pypi/v/parameterized.svg\n    :alt: PyPI\n    :target: https://pypi.org/project/parameterized/\n\n.. image:: https://circleci.com/gh/wolever/parameterized.svg?style=svg\n    :alt: Circle CI\n    :target: https://circleci.com/gh/wolever/parameterized\n\n\nParameterized testing in Python sucks.\n\n``parameterized`` fixes that. For everything. Parameterized testing for nose,\nparameterized testing for py.test, parameterized testing for unittest.\n\n.. code:: python\n\n   # test_math.py\n   from nose.tools import assert_equal\n   from parameterized import parameterized, parameterized_class\n\n   import unittest\n   import math\n\n   @parameterized([\n       (2, 2, 4),\n       (2, 3, 8),\n       (1, 9, 1),\n       (0, 9, 0),\n   ])\n   def test_pow(base, exponent, expected):\n      assert_equal(math.pow(base, exponent), expected)\n\n   class TestMathUnitTest(unittest.TestCase):\n      @parameterized.expand([\n          (\"negative\", -1.5, -2.0),\n          (\"integer\", 1, 1.0),\n          (\"large fraction\", 1.6, 1),\n      ])\n      def test_floor(self, name, input, expected):\n          assert_equal(math.floor(input), expected)\n\n   @parameterized_class(('a', 'b', 'expected_sum', 'expected_product'), [\n      (1, 2, 3, 2),\n      (5, 5, 10, 25),\n   ])\n   class TestMathClass(unittest.TestCase):\n      def test_add(self):\n         assert_equal(self.a + self.b, self.expected_sum)\n\n      def test_multiply(self):\n         assert_equal(self.a * self.b, self.expected_product)\n\n   @parameterized_class([\n      { \"a\": 3, \"expected\": 2 },\n      { \"b\": 5, \"expected\": -4 },\n   ])\n   class TestMathClassDict(unittest.TestCase):\n      a = 1\n      b = 1\n\n      def test_subtract(self):\n         assert_equal(self.a - self.b, self.expected)\n\n\nWith nose (and nose2)::\n\n    $ nosetests -v test_math.py\n    test_floor_0_negative (test_math.TestMathUnitTest) ... ok\n    test_floor_1_integer (test_math.TestMathUnitTest) ... ok\n    test_floor_2_large_fraction (test_math.TestMathUnitTest) ... ok\n    test_math.test_pow(2, 2, 4, {}) ... ok\n    test_math.test_pow(2, 3, 8, {}) ... ok\n    test_math.test_pow(1, 9, 1, {}) ... ok\n    test_math.test_pow(0, 9, 0, {}) ... ok\n    test_add (test_math.TestMathClass_0) ... ok\n    test_multiply (test_math.TestMathClass_0) ... ok\n    test_add (test_math.TestMathClass_1) ... ok\n    test_multiply (test_math.TestMathClass_1) ... ok\n    test_subtract (test_math.TestMathClassDict_0) ... ok\n\n    ----------------------------------------------------------------------\n    Ran 12 tests in 0.015s\n\n    OK\n\nAs the package name suggests, nose is best supported and will be used for all\nfurther examples.\n\n\nWith py.test (version 2.0 and above)::\n\n    $ py.test -v test_math.py\n    ============================= test session starts ==============================\n    platform darwin -- Python 3.6.1, pytest-3.1.3, py-1.4.34, pluggy-0.4.0\n    collecting ... collected 13 items\n\n    test_math.py::test_pow::[0] PASSED\n    test_math.py::test_pow::[1] PASSED\n    test_math.py::test_pow::[2] PASSED\n    test_math.py::test_pow::[3] PASSED\n    test_math.py::TestMathUnitTest::test_floor_0_negative PASSED\n    test_math.py::TestMathUnitTest::test_floor_1_integer PASSED\n    test_math.py::TestMathUnitTest::test_floor_2_large_fraction PASSED\n    test_math.py::TestMathClass_0::test_add PASSED\n    test_math.py::TestMathClass_0::test_multiply PASSED\n    test_math.py::TestMathClass_1::test_add PASSED\n    test_math.py::TestMathClass_1::test_multiply PASSED\n    test_math.py::TestMathClassDict_0::test_subtract PASSED\n    ==================== 12 passed, 4 warnings in 0.16 seconds =====================\n\nWith unittest (and unittest2)::\n\n    $ python -m unittest -v test_math\n    test_floor_0_negative (test_math.TestMathUnitTest) ... ok\n    test_floor_1_integer (test_math.TestMathUnitTest) ... ok\n    test_floor_2_large_fraction (test_math.TestMathUnitTest) ... ok\n    test_add (test_math.TestMathClass_0) ... ok\n    test_multiply (test_math.TestMathClass_0) ... ok\n    test_add (test_math.TestMathClass_1) ... ok\n    test_multiply (test_math.TestMathClass_1) ... ok\n    test_subtract (test_math.TestMathClassDict_0) ... ok\n\n    ----------------------------------------------------------------------\n    Ran 8 tests in 0.001s\n\n    OK\n\n(note: because unittest does not support test decorators, only tests created\nwith ``@parameterized.expand`` will be executed)\n\nWith green::\n\n    $ green test_math.py -vvv\n    test_math\n      TestMathClass_1\n    .   test_method_a\n    .   test_method_b\n      TestMathClass_2\n    .   test_method_a\n    .   test_method_b\n      TestMathClass_3\n    .   test_method_a\n    .   test_method_b\n      TestMathUnitTest\n    .   test_floor_0_negative\n    .   test_floor_1_integer\n    .   test_floor_2_large_fraction\n      TestMathClass_0\n    .   test_add\n    .   test_multiply\n      TestMathClass_1\n    .   test_add\n    .   test_multiply\n      TestMathClassDict_0\n    .   test_subtract\n\n    Ran 12 tests in 0.121s\n\n    OK (passes=9)\n\n\nInstallation\n------------\n\n::\n\n    $ pip install parameterized\n\n\nCompatibility\n-------------\n\n`Yes`__ (mostly).\n\n__ https://travis-ci.org/wolever/parameterized\n\n.. list-table::\n   :header-rows: 1\n   :stub-columns: 1\n\n   * -\n     - Py2.6\n     - Py2.7\n     - Py3.4\n     - Py3.5\n     - Py3.6\n     - Py3.7\n     - Py3.8\n     - Py3.9\n     - PyPy\n     - ``@mock.patch``\n   * - nose\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n   * - nose2\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n   * - py.test 2\n     - yes\n     - yes\n     - no*\n     - no*\n     - no*\n     - no*\n     - yes\n     - yes\n     - yes\n     - yes\n   * - py.test 3\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n   * - py.test 4\n     - no**\n     - no**\n     - no**\n     - no**\n     - no**\n     - no**\n     - no**\n     - no**\n     - no**\n     - no**\n   * - py.test fixtures\n     - no\u2020\n     - no\u2020\n     - no\u2020\n     - no\u2020\n     - no\u2020\n     - no\u2020\n     - no\u2020\n     - no\u2020\n     - no\u2020\n     - no\u2020\n   * - | unittest\n       | (``@parameterized.expand``)\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n   * - | unittest2\n       | (``@parameterized.expand``)\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n\n\\*: py.test 2 does `does not appear to work (#71)`__ under Python 3. Please comment on the related issues if you are affected.\n\n\\*\\*: py.test 4 is not yet supported (but coming!) in `issue #34`__\n\n\u2020: py.test fixture support is documented in `issue #81`__\n\n__ https://github.com/wolever/parameterized/issues/71\n__ https://github.com/wolever/parameterized/issues/34\n__ https://github.com/wolever/parameterized/issues/81\n\nDependencies\n------------\n\n(this section left intentionally blank)\n\n\nExhaustive Usage Examples\n--------------------------\n\nThe ``@parameterized`` and ``@parameterized.expand`` decorators accept a list\nor iterable of tuples or ``param(...)``, or a callable which returns a list or\niterable:\n\n.. code:: python\n\n    from parameterized import parameterized, param\n\n    # A list of tuples\n    @parameterized([\n        (2, 3, 5),\n        (3, 5, 8),\n    ])\n    def test_add(a, b, expected):\n        assert_equal(a + b, expected)\n\n    # A list of params\n    @parameterized([\n        param(\"10\", 10),\n        param(\"10\", 16, base=16),\n    ])\n    def test_int(str_val, expected, base=10):\n        assert_equal(int(str_val, base=base), expected)\n\n    # An iterable of params\n    @parameterized(\n        param.explicit(*json.loads(line))\n        for line in open(\"testcases.jsons\")\n    )\n    def test_from_json_file(...):\n        ...\n\n    # A callable which returns a list of tuples\n    def load_test_cases():\n        return [\n            (\"test1\", ),\n            (\"test2\", ),\n        ]\n    @parameterized(load_test_cases)\n    def test_from_function(name):\n        ...\n\n.. **\n\nNote that, when using an iterator or a generator, all the items will be loaded\ninto memory before the start of the test run (we do this explicitly to ensure\nthat generators are exhausted exactly once in multi-process or multi-threaded\ntesting environments).\n\nThe ``@parameterized`` decorator can be used test class methods, and standalone\nfunctions:\n\n.. code:: python\n\n    from parameterized import parameterized\n\n    class AddTest(object):\n        @parameterized([\n            (2, 3, 5),\n        ])\n        def test_add(self, a, b, expected):\n            assert_equal(a + b, expected)\n\n    @parameterized([\n        (2, 3, 5),\n    ])\n    def test_add(a, b, expected):\n        assert_equal(a + b, expected)\n\n\nAnd ``@parameterized.expand`` can be used to generate test methods in\nsituations where test generators cannot be used (for example, when the test\nclass is a subclass of ``unittest.TestCase``):\n\n.. code:: python\n\n    import unittest\n    from parameterized import parameterized\n\n    class AddTestCase(unittest.TestCase):\n        @parameterized.expand([\n            (\"2 and 3\", 2, 3, 5),\n            (\"3 and 5\", 2, 3, 5),\n        ])\n        def test_add(self, _, a, b, expected):\n            assert_equal(a + b, expected)\n\nWill create the test cases::\n\n    $ nosetests example.py\n    test_add_0_2_and_3 (example.AddTestCase) ... ok\n    test_add_1_3_and_5 (example.AddTestCase) ... ok\n\n    ----------------------------------------------------------------------\n    Ran 2 tests in 0.001s\n\n    OK\n\nNote that ``@parameterized.expand`` works by creating new methods on the test\nclass. If the first parameter is a string, that string will be added to the end\nof the method name. For example, the test case above will generate the methods\n``test_add_0_2_and_3`` and ``test_add_1_3_and_5``.\n\nThe names of the test cases generated by ``@parameterized.expand`` can be\ncustomized using the ``name_func`` keyword argument. The value should\nbe a function which accepts three arguments: ``testcase_func``, ``param_num``,\nand ``params``, and it should return the name of the test case.\n``testcase_func`` will be the function to be tested, ``param_num`` will be the\nindex of the test case parameters in the list of parameters, and ``param``\n(an instance of ``param``) will be the parameters which will be used.\n\n.. code:: python\n\n    import unittest\n    from parameterized import parameterized\n\n    def custom_name_func(testcase_func, param_num, param):\n        return \"%s_%s\" %(\n            testcase_func.__name__,\n            parameterized.to_safe_name(\"_\".join(str(x) for x in param.args)),\n        )\n\n    class AddTestCase(unittest.TestCase):\n        @parameterized.expand([\n            (2, 3, 5),\n            (2, 3, 5),\n        ], name_func=custom_name_func)\n        def test_add(self, a, b, expected):\n            assert_equal(a + b, expected)\n\nWill create the test cases::\n\n    $ nosetests example.py\n    test_add_1_2_3 (example.AddTestCase) ... ok\n    test_add_2_3_5 (example.AddTestCase) ... ok\n\n    ----------------------------------------------------------------------\n    Ran 2 tests in 0.001s\n\n    OK\n\n\nThe ``param(...)`` helper class stores the parameters for one specific test\ncase.  It can be used to pass keyword arguments to test cases:\n\n.. code:: python\n\n    from parameterized import parameterized, param\n\n    @parameterized([\n        param(\"10\", 10),\n        param(\"10\", 16, base=16),\n    ])\n    def test_int(str_val, expected, base=10):\n        assert_equal(int(str_val, base=base), expected)\n\n\nIf test cases have a docstring, the parameters for that test case will be\nappended to the first line of the docstring. This behavior can be controlled\nwith the ``doc_func`` argument:\n\n.. code:: python\n\n    from parameterized import parameterized\n\n    @parameterized([\n        (1, 2, 3),\n        (4, 5, 9),\n    ])\n    def test_add(a, b, expected):\n        \"\"\" Test addition. \"\"\"\n        assert_equal(a + b, expected)\n\n    def my_doc_func(func, num, param):\n        return \"%s: %s with %s\" %(num, func.__name__, param)\n\n    @parameterized([\n        (5, 4, 1),\n        (9, 6, 3),\n    ], doc_func=my_doc_func)\n    def test_subtraction(a, b, expected):\n        assert_equal(a - b, expected)\n\n::\n\n    $ nosetests example.py\n    Test addition. [with a=1, b=2, expected=3] ... ok\n    Test addition. [with a=4, b=5, expected=9] ... ok\n    0: test_subtraction with param(*(5, 4, 1)) ... ok\n    1: test_subtraction with param(*(9, 6, 3)) ... ok\n\n    ----------------------------------------------------------------------\n    Ran 4 tests in 0.001s\n\n    OK\n\nFinally ``@parameterized_class`` parameterizes an entire class, using\neither a list of attributes, or a list of dicts that will be applied to the\nclass:\n\n.. code:: python\n\n    from yourapp.models import User\n    from parameterized import parameterized_class\n\n    @parameterized_class([\n       { \"username\": \"user_1\", \"access_level\": 1 },\n       { \"username\": \"user_2\", \"access_level\": 2, \"expected_status_code\": 404 },\n    ])\n    class TestUserAccessLevel(TestCase):\n       expected_status_code = 200\n\n       def setUp(self):\n          self.client.force_login(User.objects.get(username=self.username)[0])\n\n       def test_url_a(self):\n          response = self.client.get('/url')\n          self.assertEqual(response.status_code, self.expected_status_code)\n\n       def tearDown(self):\n          self.client.logout()\n\n\n    @parameterized_class((\"username\", \"access_level\", \"expected_status_code\"), [\n       (\"user_1\", 1, 200),\n       (\"user_2\", 2, 404)\n    ])\n    class TestUserAccessLevel(TestCase):\n       def setUp(self):\n          self.client.force_login(User.objects.get(username=self.username)[0])\n\n       def test_url_a(self):\n          response = self.client.get(\"/url\")\n          self.assertEqual(response.status_code, self.expected_status_code)\n\n       def tearDown(self):\n          self.client.logout()\n\n\nThe ``@parameterized_class`` decorator accepts a ``class_name_func`` argument,\nwhich controls the name of the parameterized classes generated by\n``@parameterized_class``:\n\n.. code:: python\n\n    from parameterized import parameterized, parameterized_class\n\n    def get_class_name(cls, num, params_dict):\n        # By default the generated class named includes either the \"name\"\n        # parameter (if present), or the first string value. This example shows\n        # multiple parameters being included in the generated class name:\n        return \"%s_%s_%s%s\" %(\n            cls.__name__,\n            num,\n            parameterized.to_safe_name(params_dict['a']),\n            parameterized.to_safe_name(params_dict['b']),\n        )\n\n    @parameterized_class([\n       { \"a\": \"hello\", \"b\": \" world!\", \"expected\": \"hello world!\" },\n       { \"a\": \"say \", \"b\": \" cheese :)\", \"expected\": \"say cheese :)\" },\n    ], class_name_func=get_class_name)\n    class TestConcatenation(TestCase):\n      def test_concat(self):\n          self.assertEqual(self.a + self.b, self.expected)\n\n::\n\n    $ nosetests -v test_math.py\n    test_concat (test_concat.TestConcatenation_0_hello_world_) ... ok\n    test_concat (test_concat.TestConcatenation_0_say_cheese__) ... ok\n\n\n\nUsing with Single Parameters\n............................\n\nIf a test function only accepts one parameter and the value is not iterable,\nthen it is possible to supply a list of values without wrapping each one in a\ntuple:\n\n.. code:: python\n\n   @parameterized([1, 2, 3])\n   def test_greater_than_zero(value):\n      assert value > 0\n\nNote, however, that if the single parameter *is* iterable (such as a list or\ntuple), then it *must* be wrapped in a tuple, list, or the ``param(...)``\nhelper:\n\n.. code:: python\n\n   @parameterized([\n      ([1, 2, 3], ),\n      ([3, 3], ),\n      ([6], ),\n   ])\n   def test_sums_to_6(numbers):\n      assert sum(numbers) == 6\n\n(note, also, that Python requires single element tuples to be defined with a\ntrailing comma: ``(foo, )``)\n\n\nUsing with ``@mock.patch``\n..........................\n\n``parameterized`` can be used with ``mock.patch``, but the argument ordering\ncan be confusing. The ``@mock.patch(...)`` decorator must come *below* the\n``@parameterized(...)``, and the mocked parameters must come *last*:\n\n.. code:: python\n\n   @mock.patch(\"os.getpid\")\n   class TestOS(object):\n      @parameterized(...)\n      @mock.patch(\"os.fdopen\")\n      @mock.patch(\"os.umask\")\n      def test_method(self, param1, param2, ..., mock_umask, mock_fdopen, mock_getpid):\n         ...\n\nNote: the same holds true when using ``@parameterized.expand``.\n\n\nMigrating from ``nose-parameterized`` to ``parameterized``\n----------------------------------------------------------\n\nTo migrate a codebase from ``nose-parameterized`` to ``parameterized``:\n\n1. Update your requirements file, replacing ``nose-parameterized`` with\n   ``parameterized``.\n\n2. Replace all references to ``nose_parameterized`` with ``parameterized``::\n\n    $ perl -pi -e 's/nose_parameterized/parameterized/g' your-codebase/\n\n3. You're done!\n\n\nFAQ\n---\n\nWhat happened to ``nose-parameterized``?\n    Originally only nose was supported. But now everything is supported, and it\n    only made sense to change the name!\n\nWhat do you mean when you say \"nose is best supported\"?\n    There are small caveates with ``py.test`` and ``unittest``: ``py.test``\n    does not show the parameter values (ex, it will show ``test_add[0]``\n    instead of ``test_add[1, 2, 3]``), and ``unittest``/``unittest2`` do not\n    support test generators so ``@parameterized.expand`` must be used.\n\nWhy not use ``@pytest.mark.parametrize``?\n    Because spelling is difficult. Also, ``parameterized`` doesn't require you\n    to repeat argument names, and (using ``param``) it supports optional\n    keyword arguments.\n\nWhy do I get an ``AttributeError: 'function' object has no attribute 'expand'`` with ``@parameterized.expand``?\n    You've likely installed the ``parametrized`` (note the missing *e*)\n    package. Use ``parameterized`` (with the *e*) instead and you'll be all\n    set.\n\n\n",
  "requires_dist": [
    "jinja2 ; extra == 'dev'"
  ],
  "requires_python": "",
  "current_version": "0.8.1",
  "released_versions": [
    "0.5.0",
    "0.6.1",
    "0.6.3",
    "0.7.0",
    "0.7.1",
    "0.7.2",
    "0.7.3",
    "0.7.4",
    "0.7.5",
    "0.8.1"
  ]
}