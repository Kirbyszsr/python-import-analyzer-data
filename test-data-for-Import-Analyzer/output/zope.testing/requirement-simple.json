{
  "name": "zope.testing",
  "description": "=================\n``zope.testing``\n=================\n\n.. image:: https://img.shields.io/pypi/v/zope.testing.svg\n    :target: https://pypi.python.org/pypi/zope.testing/\n    :alt: Latest Version\n\n.. image:: https://travis-ci.com/zopefoundation/zope.testing.svg?branch=master\n        :target: https://travis-ci.com/zopefoundation/zope.testing\n\n.. image:: https://readthedocs.org/projects/zopetesting/badge/?version=latest\n        :target: http://zopetesting.readthedocs.org/en/latest/\n        :alt: Documentation Status\n\nThis package provides a number of testing frameworks.\n\ncleanup\n  Provides a mixin class for cleaning up after tests that\n  make global changes.\n\nformparser\n  An HTML parser that extracts form information.\n\n  **Python 2 only**\n\n  This is intended to support functional tests that need to extract\n  information from HTML forms returned by the publisher.\n\n  See formparser.txt.\n\nloggingsupport\n  Support for testing logging code\n\n  If you want to test that your code generates proper log output, you\n  can create and install a handler that collects output.\n\nloghandler\n  Logging handler for tests that check logging output.\n\nmodule\n  Lets a doctest pretend to be a Python module.\n\n  See module.txt.\n\nrenormalizing\n  Regular expression pattern normalizing output checker.\n  Useful for doctests.\n\nserver\n  Provides a simple HTTP server compatible with the zope.app.testing\n  functional testing API.  Lets you interactively play with the system\n  under test.  Helpful in debugging functional doctest failures.\n\n  **Python 2 only**\n\nsetupstack\n  A simple framework for automating doctest set-up and tear-down.\n  See setupstack.txt.\n\nwait\n  A small utility for dealing with timing non-determinism\n  See wait.txt.\n\ndoctestcase\n  Support for defining doctests as methods of ``unittest.TestCase``\n  classes so that they can be more easily found by test runners, like\n  nose, that ignore test suites.\n\n.. contents::\n\nGetting started developing zope.testing\n=======================================\n\nzope.testing uses buildout.  To start, run ``python bootstrap.py``.  It will\ncreate a number of directories and the ``bin/buildout`` script.  Next, run\n``bin/buildout``.  It will create a test script for you.  Now, run ``bin/test``\nto run the zope.testing test suite.\n\n\nParsing HTML Forms\n==================\n\nSometimes in functional tests, information from a generated form must\nbe extracted in order to re-submit it as part of a subsequent request.\nThe `zope.testing.formparser` module can be used for this purpose.\n\nNOTE\n   formparser doesn't support Python 3.\n\nThe scanner is implemented using the `FormParser` class.  The\nconstructor arguments are the page data containing the form and\n(optionally) the URL from which the page was retrieved:\n\n  >>> import zope.testing.formparser\n\n  >>> page_text = '''\\\n  ... <html><body>\n  ...   <form name=\"form1\" action=\"/cgi-bin/foobar.py\" method=\"POST\">\n  ...     <input type=\"hidden\" name=\"f1\" value=\"today\" />\n  ...     <input type=\"submit\" name=\"do-it-now\" value=\"Go for it!\" />\n  ...     <input type=\"IMAGE\" name=\"not-really\" value=\"Don't.\"\n  ...            src=\"dont.png\" />\n  ...     <select name=\"pick-two\" size=\"3\" multiple>\n  ...       <option value=\"one\" selected>First</option>\n  ...       <option value=\"two\" label=\"Second\">Another</option>\n  ...       <optgroup>\n  ...         <option value=\"three\">Third</option>\n  ...         <option selected=\"selected\">Fourth</option>\n  ...       </optgroup>\n  ...     </select>\n  ...   </form>\n  ...\n  ...   Just for fun, a second form, after specifying a base:\n  ...   <base href=\"http://www.example.com/base/\" />\n  ...   <form action = 'sproing/sprung.html' enctype=\"multipart/form\">\n  ...     <textarea name=\"sometext\" rows=\"5\">Some text.</textarea>\n  ...     <input type=\"Image\" name=\"action\" value=\"Do something.\"\n  ...            src=\"else.png\" />\n  ...     <input type=\"text\" value=\"\" name=\"multi\" size=\"2\" />\n  ...     <input type=\"text\" value=\"\" name=\"multi\" size=\"3\" />\n  ...   </form>\n  ... </body></html>\n  ... '''\n\n  >>> parser = zope.testing.formparser.FormParser(page_text)\n  >>> forms = parser.parse()\n\n  >>> len(forms)\n  2\n  >>> forms.form1 is forms[0]\n  True\n  >>> forms.form1 is forms[1]\n  False\n\nMore often, the `parse()` convenience function is all that's needed:\n\n  >>> forms = zope.testing.formparser.parse(\n  ...     page_text, \"http://cgi.example.com/somewhere/form.html\")\n\n  >>> len(forms)\n  2\n  >>> forms.form1 is forms[0]\n  True\n  >>> forms.form1 is forms[1]\n  False\n\nOnce we have the form we're interested in, we can check form\nattributes and individual field values:\n\n  >>> form = forms.form1\n  >>> form.enctype\n  'application/x-www-form-urlencoded'\n  >>> form.method\n  'post'\n\n  >>> keys = form.keys()\n  >>> keys.sort()\n  >>> keys\n  ['do-it-now', 'f1', 'not-really', 'pick-two']\n\n  >>> not_really = form[\"not-really\"]\n  >>> not_really.type\n  'image'\n  >>> not_really.value\n  \"Don't.\"\n  >>> not_really.readonly\n  False\n  >>> not_really.disabled\n  False\n\nNote that relative URLs are converted to absolute URLs based on the\n``<base>`` element (if present) or using the base passed in to the\nconstructor.\n\n  >>> form.action\n  'http://cgi.example.com/cgi-bin/foobar.py'\n  >>> not_really.src\n  'http://cgi.example.com/somewhere/dont.png'\n\n  >>> forms[1].action\n  'http://www.example.com/base/sproing/sprung.html'\n  >>> forms[1][\"action\"].src\n  'http://www.example.com/base/else.png'\n\nFields which are repeated are reported as lists of objects that\nrepresent each instance of the field::\n\n  >>> field = forms[1][\"multi\"]\n  >>> isinstance(field, list)\n  True\n  >>> [o.value for o in field]\n  ['', '']\n  >>> [o.size for o in field]\n  [2, 3]\n\nThe ``<textarea>`` element provides some additional attributes:\n\n  >>> ta = forms[1][\"sometext\"]\n  >>> print ta.rows\n  5\n  >>> print ta.cols\n  None\n  >>> ta.value\n  'Some text.'\n\nThe ``<select>`` element provides access to the options as well:\n\n  >>> select = form[\"pick-two\"]\n  >>> select.multiple\n  True\n  >>> select.size\n  3\n  >>> select.type\n  'select'\n  >>> select.value\n  ['one', 'Fourth']\n\n  >>> options = select.options\n  >>> len(options)\n  4\n  >>> [opt.label for opt in options]\n  ['First', 'Second', 'Third', 'Fourth']\n  >>> [opt.value for opt in options]\n  ['one', 'two', 'three', 'Fourth']\n\n\nSupport for testing logging code\n================================\n\nIf you want to test that your code generates proper log output, you\ncan create and install a handler that collects output:\n\n  >>> from zope.testing.loggingsupport import InstalledHandler\n  >>> handler = InstalledHandler('foo.bar')\n\nThe handler is installed into loggers for all of the names passed. In\naddition, the logger level is set to 1, which means, log\neverything. If you want to log less than everything, you can provide a\nlevel keyword argument.  The level setting effects only the named\nloggers.\n\n  >>> import logging\n  >>> handler_with_levels = InstalledHandler('baz', level=logging.WARNING)\n\nThen, any log output is collected in the handler:\n\n  >>> logging.getLogger('foo.bar').exception('eek')\n  >>> logging.getLogger('foo.bar').info('blah blah')\n\n  >>> for record in handler.records:\n  ...     print_(record.name, record.levelname)\n  ...     print_(' ', record.getMessage())\n  foo.bar ERROR\n    eek\n  foo.bar INFO\n    blah blah\n\nA similar effect can be gotten by just printing the handler:\n\n  >>> print_(handler)\n  foo.bar ERROR\n    eek\n  foo.bar INFO\n    blah blah\n\nAfter checking the log output, you need to uninstall the handler:\n\n  >>> handler.uninstall()\n  >>> handler_with_levels.uninstall()\n\nAt which point, the handler won't get any more log output.\nLet's clear the handler:\n\n  >>> handler.clear()\n  >>> handler.records\n  []\n\nAnd then log something:\n\n  >>> logging.getLogger('foo.bar').info('blah')\n\nand, sure enough, we still have no output:\n\n  >>> handler.records\n  []\n\n\nRegular expression pattern normalizing output checker\n=====================================================\n\nThe pattern-normalizing output checker extends the default output checker with\nan option to normalize expected and actual output.\n\nYou specify a sequence of patterns and replacements.  The replacements are\napplied to the expected and actual outputs before calling the default outputs\nchecker.  Let's look at an example.  In this example, we have some times and\naddresses:\n\n    >>> want = '''\\\n    ... <object object at 0xb7f14438>\n    ... completed in 1.234 seconds.\n    ... <BLANKLINE>\n    ... <object object at 0xb7f14440>\n    ... completed in 123.234 seconds.\n    ... <BLANKLINE>\n    ... <object object at 0xb7f14448>\n    ... completed in .234 seconds.\n    ... <BLANKLINE>\n    ... <object object at 0xb7f14450>\n    ... completed in 1.234 seconds.\n    ... <BLANKLINE>\n    ... '''\n\n    >>> got = '''\\\n    ... <object object at 0xb7f14458>\n    ... completed in 1.235 seconds.\n    ...\n    ... <object object at 0xb7f14460>\n    ... completed in 123.233 seconds.\n    ...\n    ... <object object at 0xb7f14468>\n    ... completed in .231 seconds.\n    ...\n    ... <object object at 0xb7f14470>\n    ... completed in 1.23 seconds.\n    ...\n    ... '''\n\nWe may wish to consider these two strings to match, even though they differ in\nactual addresses and times.  The default output checker will consider them\ndifferent:\n\n    >>> import doctest\n    >>> doctest.OutputChecker().check_output(want, got, 0)\n    False\n\nWe'll use the zope.testing.renormalizing.OutputChecker to normalize both the\nwanted and gotten strings to ignore differences in times and\naddresses:\n\n    >>> import re\n    >>> from zope.testing.renormalizing import OutputChecker\n    >>> checker = OutputChecker([\n    ...    (re.compile('[0-9]*[.][0-9]* seconds'), '<SOME NUMBER OF> seconds'),\n    ...    (re.compile('at 0x[0-9a-f]+'), 'at <SOME ADDRESS>'),\n    ...    ])\n\n    >>> checker.check_output(want, got, 0)\n    True\n\nUsual OutputChecker options work as expected:\n\n    >>> want_ellided = '''\\\n    ... <object object at 0xb7f14438>\n    ... completed in 1.234 seconds.\n    ... ...\n    ... <object object at 0xb7f14450>\n    ... completed in 1.234 seconds.\n    ... <BLANKLINE>\n    ... '''\n\n    >>> checker.check_output(want_ellided, got, 0)\n    False\n\n    >>> checker.check_output(want_ellided, got, doctest.ELLIPSIS)\n    True\n\nWhen we get differencs, we output them with normalized text:\n\n    >>> source = '''\\\n    ... >>> do_something()\n    ... <object object at 0xb7f14438>\n    ... completed in 1.234 seconds.\n    ... ...\n    ... <object object at 0xb7f14450>\n    ... completed in 1.234 seconds.\n    ... <BLANKLINE>\n    ... '''\n\n    >>> example = doctest.Example(source, want_ellided)\n\n    >>> print_(checker.output_difference(example, got, 0))\n    Expected:\n        <object object at <SOME ADDRESS>>\n        completed in <SOME NUMBER OF> seconds.\n        ...\n        <object object at <SOME ADDRESS>>\n        completed in <SOME NUMBER OF> seconds.\n        <BLANKLINE>\n    Got:\n        <object object at <SOME ADDRESS>>\n        completed in <SOME NUMBER OF> seconds.\n        <BLANKLINE>\n        <object object at <SOME ADDRESS>>\n        completed in <SOME NUMBER OF> seconds.\n        <BLANKLINE>\n        <object object at <SOME ADDRESS>>\n        completed in <SOME NUMBER OF> seconds.\n        <BLANKLINE>\n        <object object at <SOME ADDRESS>>\n        completed in <SOME NUMBER OF> seconds.\n        <BLANKLINE>\n    <BLANKLINE>\n\n    >>> print_(checker.output_difference(example, got,\n    ...                                 doctest.REPORT_NDIFF))\n    Differences (ndiff with -expected +actual):\n        - <object object at <SOME ADDRESS>>\n        - completed in <SOME NUMBER OF> seconds.\n        - ...\n          <object object at <SOME ADDRESS>>\n          completed in <SOME NUMBER OF> seconds.\n          <BLANKLINE>\n        + <object object at <SOME ADDRESS>>\n        + completed in <SOME NUMBER OF> seconds.\n        + <BLANKLINE>\n        + <object object at <SOME ADDRESS>>\n        + completed in <SOME NUMBER OF> seconds.\n        + <BLANKLINE>\n        + <object object at <SOME ADDRESS>>\n        + completed in <SOME NUMBER OF> seconds.\n        + <BLANKLINE>\n    <BLANKLINE>\n\n    If the wanted text is empty, however, we don't transform the actual output.\n    This is usful when writing tests.  We leave the expected output empty, run\n    the test, and use the actual output as expected, after reviewing it.\n\n    >>> source = '''\\\n    ... >>> do_something()\n    ... '''\n\n    >>> example = doctest.Example(source, '\\n')\n    >>> print_(checker.output_difference(example, got, 0))\n    Expected:\n    <BLANKLINE>\n    Got:\n        <object object at 0xb7f14458>\n        completed in 1.235 seconds.\n        <BLANKLINE>\n        <object object at 0xb7f14460>\n        completed in 123.233 seconds.\n        <BLANKLINE>\n        <object object at 0xb7f14468>\n        completed in .231 seconds.\n        <BLANKLINE>\n        <object object at 0xb7f14470>\n        completed in 1.23 seconds.\n        <BLANKLINE>\n    <BLANKLINE>\n\nIf regular expressions aren't expressive enough, you can use arbitrary Python\ncallables to transform the text.  For example, suppose you want to ignore\ncase during comparison:\n\n    >>> checker = OutputChecker([\n    ...    lambda s: s.lower(),\n    ...    lambda s: s.replace('<blankline>', '<BLANKLINE>'),\n    ...    ])\n\n    >>> want = '''\\\n    ... Usage: thundermonkey [options] [url]\n    ... <BLANKLINE>\n    ... Options:\n    ...     -h    display this help message\n    ... '''\n\n    >>> got = '''\\\n    ... usage: thundermonkey [options] [URL]\n    ...\n    ... options:\n    ...     -h    Display this help message\n    ... '''\n\n    >>> checker.check_output(want, got, 0)\n    True\n\nSuppose we forgot that <BLANKLINE> must be in upper case:\n\n    >>> checker = OutputChecker([\n    ...    lambda s: s.lower(),\n    ...    ])\n\n    >>> checker.check_output(want, got, 0)\n    False\n\nThe difference would show us that:\n\n    >>> source = '''\\\n    ... >>> print_help_message()\n    ... ''' + want\n    >>> example = doctest.Example(source, want)\n    >>> print_(checker.output_difference(example, got,\n    ...                                 doctest.REPORT_NDIFF))\n    Differences (ndiff with -expected +actual):\n          usage: thundermonkey [options] [url]\n        - <blankline>\n        + <BLANKLINE>\n          options:\n              -h    display this help message\n    <BLANKLINE>\n\n\nIt is possible to combine OutputChecker checkers for easy reuse:\n\n    >>> address_and_time_checker = OutputChecker([\n    ...    (re.compile('[0-9]*[.][0-9]* seconds'), '<SOME NUMBER OF> seconds'),\n    ...    (re.compile('at 0x[0-9a-f]+'), 'at <SOME ADDRESS>'),\n    ...    ])\n    >>> lowercase_checker = OutputChecker([\n    ...    lambda s: s.lower(),\n    ...    ])\n    >>> combined_checker = address_and_time_checker + lowercase_checker\n    >>> len(combined_checker.transformers)\n    3\n\nCombining a checker with something else does not work:\n\n    >>> lowercase_checker + 5 #doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for +: ...\n\nUsing the 2to3 exception normalization:\n\n    >>> from zope.testing.renormalizing import (\n    ...     IGNORE_EXCEPTION_MODULE_IN_PYTHON2)\n    >>> checker = OutputChecker()\n    >>> want = \"\"\"\\\n    ... Traceback (most recent call last):\n    ... foo.bar.FooBarError: requires at least one argument.\"\"\"\n    >>> got = \"\"\"\\\n    ... Traceback (most recent call last):\n    ... FooBarError: requires at least one argument.\"\"\"\n    >>> result = checker.check_output(\n    ...     want, got, IGNORE_EXCEPTION_MODULE_IN_PYTHON2)\n    >>> import sys\n    >>> if sys.version_info[0] < 3:\n    ...     expected = True\n    ... else:\n    ...     expected = False\n    >>> result == expected\n    True\n\nWhen reporting a failing test and running in Python 2, the normalizer tries\nto be helpful by explaining how to test for exceptions in the traceback output.\n\n    >>> want = \"\"\"\\\n    ... Traceback (most recent call last):\n    ... foo.bar.FooBarErrorXX: requires at least one argument.\n    ... \"\"\"\n    >>> got = \"\"\"\\\n    ... Traceback (most recent call last):\n    ... FooBarError: requires at least one argument.\n    ... \"\"\"\n    >>> checker.check_output(want, got, IGNORE_EXCEPTION_MODULE_IN_PYTHON2)\n    False\n    >>> from doctest import Example\n    >>> example = Example('dummy', want)\n    >>> result = checker.output_difference(\n    ...     example, got, IGNORE_EXCEPTION_MODULE_IN_PYTHON2)\n    >>> output = \"\"\"\\\n    ... Expected:\n    ...     Traceback (most recent call last):\n    ...     foo.bar.FooBarErrorXX: requires at least one argument.\n    ... Got:\n    ...     Traceback (most recent call last):\n    ...     FooBarError: requires at least one argument.\n    ... \"\"\"\n    >>> hint = \"\"\"\\\n    ...     ===============================================================\n    ...     HINT:\n    ...       The optionflag IGNORE_EXCEPTION_MODULE_IN_PYTHON2 is set.\n    ...       You seem to test traceback output.\n    ...       If you are indeed, make sure to use the full dotted name of\n    ...       the exception class like Python 3 displays,\n    ...       even though you are running the tests in Python 2.\n    ...       The exception message needs to be last line (and thus not\n    ...       split over multiple lines).\n    ...     ===============================================================\"\"\"\n    >>> if sys.version_info[0] < 3:\n    ...     expected = output + hint\n    ... else:\n    ...     expected = output\n    >>> result == expected\n    True\n\n\nStack-based test setUp and tearDown\n===================================\n\nWriting doctest setUp and tearDown functions can be a bit tedious,\nespecially when setUp/tearDown functions are combined.\n\nthe zope.testing.setupstack module provides a small framework for\nautomating test tear down.  It provides a generic setUp function that\nsets up a stack. Normal test setUp functions call this function to set\nup the stack and then use the register function to register tear-down\nfunctions.\n\nTo see how this works we'll create a faux test:\n\n    >>> class Test:\n    ...     def __init__(self):\n    ...         self.globs = {}\n    >>> test = Test()\n\nWe'll register some tearDown functions that just print something:\n\n    >>> import sys\n    >>> import zope.testing.setupstack\n    >>> zope.testing.setupstack.register(\n    ...     test, lambda : sys.stdout.write('td 1\\n'))\n    >>> zope.testing.setupstack.register(\n    ...     test, lambda : sys.stdout.write('td 2\\n'))\n\nNow, when we call the tearDown function:\n\n    >>> zope.testing.setupstack.tearDown(test)\n    td 2\n    td 1\n\nThe registered tearDown functions are run. Note that they are run in\nthe reverse order that they were registered.\n\n\nExtra positional arguments can be passed to register:\n\n    >>> zope.testing.setupstack.register(\n    ...    test, lambda x, y, z: sys.stdout.write('%s %s %s\\n' % (x, y, z)),\n    ...    1, 2, z=9)\n    >>> zope.testing.setupstack.tearDown(test)\n    1 2 9\n\n\nTemporary Test Directory\n------------------------\n\nOften, tests create files as they demonstrate functionality.  They\nneed to arrange for the removeal of these files when the test is\ncleaned up.\n\nThe setUpDirectory function automates this.  We'll get the current\ndirectory first:\n\n    >>> import os\n    >>> here = os.getcwd()\n\nWe'll also create a new test:\n\n    >>> test = Test()\n\nNow we'll call the setUpDirectory function:\n\n    >>> zope.testing.setupstack.setUpDirectory(test)\n\nWe don't have to call zope.testing.setupstack.setUp, because\nsetUpDirectory calls it for us.\n\nNow the current working directory has changed:\n\n    >>> here == os.getcwd()\n    False\n    >>> setupstack_cwd = os.getcwd()\n\nWe can create files to out heart's content:\n\n    >>> with open('Data.fs', 'w') as f:\n    ...     foo = f.write('xxx')\n    >>> os.path.exists(os.path.join(setupstack_cwd, 'Data.fs'))\n    True\n\nWe'll make the file read-only. This can cause problems on Windows, but\nsetupstack takes care of that by making files writable before trying\nto remove them.\n\n    >>> import stat\n    >>> os.chmod('Data.fs', stat.S_IREAD)\n\nOn Unix systems, broken symlinks can cause problems because the chmod\nattempt by the teardown hook will fail; let's set up a broken symlink as\nwell, and verify the teardown doesn't break because of that:\n\n    >>> if sys.platform != 'win32':\n    ...     os.symlink('NotThere', 'BrokenLink')\n\nWhen tearDown is called:\n\n    >>> zope.testing.setupstack.tearDown(test)\n\nWe'll be back where we started:\n\n    >>> here == os.getcwd()\n    True\n\nand the files we created will be gone (along with the temporary\ndirectory that was created:\n\n    >>> os.path.exists(os.path.join(setupstack_cwd, 'Data.fs'))\n    False\n\nContext-manager support\n-----------------------\n\nYou can leverage context managers using the ``contextmanager`` method.\nThe result of calling the content manager's __enter__ method will be\nreturned. The context-manager's __exit__ method will be called as part\nof test tear down:\n\n    >>> class Manager(object):\n    ...     def __init__(self, *args, **kw):\n    ...         if kw:\n    ...             args += (kw, )\n    ...         self.args = args\n    ...     def __enter__(self):\n    ...         print_('enter', *self.args)\n    ...         return 42\n    ...     def __exit__(self, *args):\n    ...         print_('exit', args, *self.args)\n\n    >>> manager = Manager()\n    >>> test = Test()\n\n    >>> zope.testing.setupstack.context_manager(test, manager)\n    enter\n    42\n\n    >>> zope.testing.setupstack.tearDown(test)\n    exit (None, None, None)\n\n.. faux mock\n\n    >>> old_mock = sys.modules.get('mock')\n    >>> class FauxMock:\n    ...     @classmethod\n    ...     def patch(self, *args, **kw):\n    ...         return Manager(*args, **kw)\n\n    >>> sys.modules['mock'] = FauxMock\n\nBy far the most commonly called context manager is ``mock.patch``, so\nthere's a convenience function to make that simpler:\n\n    >>> zope.testing.setupstack.mock(test, 'time.time', return_value=42)\n    enter time.time {'return_value': 42}\n    42\n\n    >>> zope.testing.setupstack.tearDown(test)\n    exit (None, None, None) time.time {'return_value': 42}\n\nglobs\n-----\n\nDoctests have ``globs`` attributes used to hold test globals.\n``setupstack`` was originally designed to work with doctests, but can\nnow work with either doctests, or other test objects, as long as the\ntest objects have either a ``globs`` attribute or a ``__dict__``\nattribute.  The ``zope.testing.setupstack.globs`` function is used to\nget the globals for a test object:\n\n    >>> zope.testing.setupstack.globs(test) is test.globs\n    True\n\nHere, because the test object had a ``globs`` attribute, it was\nreturned. Because we used the test object above, it has a setupstack:\n\n    >>> '__zope.testing.setupstack' in test.globs\n    True\n\nIf we remove the ``globs`` attribute, the object's instance dictionary\nwill be used:\n\n    >>> del test.globs\n    >>> zope.testing.setupstack.globs(test) is test.__dict__\n    True\n    >>> zope.testing.setupstack.context_manager(test, manager)\n    enter\n    42\n\n    >>> '__zope.testing.setupstack' in test.__dict__\n    True\n\nThe ``globs`` function is used internally, but can also be used by\nsetup code to support either doctests or other test objects.\n\nTestCase\n--------\n\nA TestCase class is provided that:\n\n- Makes it easier to call setupstack apis, and\n\n- provides an inheritable tearDown method.\n\nIn addition to a tearDown method, the class provides methods:\n\n``setupDirectory()``\n    Creates a temporary directory, runs the test, and cleans it up.\n\n``register(func)``\n    Register a tear-down function.\n\n``context_manager(manager)``\n    Enters a context manager and exits it on tearDown.\n\n``mock(*args, **kw)``\n    Enters  ``mock.patch`` with the given arguments.\n\n    This is syntactic sugur for::\n\n        context_manager(mock.patch(*args, **kw))\n\nHere's an example:\n\n    >>> class MyTests(zope.testing.setupstack.TestCase):\n    ...\n    ...     def setUp(self):\n    ...         self.setUpDirectory()\n    ...         self.context_manager(manager)\n    ...         self.mock(\"time.time\", return_value=42)\n    ...\n    ...         @self.register\n    ...         def _():\n    ...             print('done w test')\n    ...\n    ...     def test(self):\n    ...         if here == os.getcwd():\n    ...             print('Failed to change directory')\n\n.. let's try it\n\n    >>> import unittest\n    >>> loader = unittest.TestLoader()\n    >>> suite = loader.loadTestsFromTestCase(MyTests)\n    >>> result = suite.run(unittest.TestResult())\n    enter\n    enter time.time {'return_value': 42}\n    done w test\n    exit (None, None, None) time.time {'return_value': 42}\n    exit (None, None, None)\n\n.. cleanup\n\n    >>> if old_mock:\n    ...     sys.modules['mock'] = old_mock\n    ... else:\n    ...     del sys.modules['mock']\n\n\n\nWait until a condition holds (or until a time out)\n==================================================\n\nOften, in tests, you need to wait until some condition holds.  This\nmay be because you're testing interaction with an external system or\ntesting threaded (threads, processes, greenlet's, etc.) interactions.\n\nYou can add sleeps to your tests, but it's often hard to know how\nlong to sleep.\n\n``zope.testing.wait`` provides a convenient way to wait until\nsome condition holds.  It will test a condition and, when true,\nreturn.  It will sleep a short time between tests.\n\nHere's a silly example, that illustrates it's use:\n\n    >>> from zope.testing.wait import wait\n    >>> wait(lambda : True)\n\nSince the condition we passed is always True, it returned\nimmediately.  If the condition doesn't hold, then we'll get a timeout:\n\n    >>> wait((lambda : False), timeout=.01)\n    Traceback (most recent call last):\n    ...\n    TimeOutWaitingFor: <lambda>\n\n``wait`` has some keyword options:\n\ntimeout\n   How long, in seconds, to wait for the condition to hold\n\n   Defaults to 9 seconds.\n\nwait\n   How long to wait between calls.\n\n   Defaults to .01 seconds.\n\nmessage\n   A message (or other data) to pass to the timeout exception.\n\n   This defaults to ``None``.  If this is false, then the callable's\n   doc string or ``__name__`` is used.\n\n``wait`` can be used as a decorator:\n\n    >>> @wait\n    ... def ok():\n    ...     return True\n\n    >>> @wait(timeout=.01)\n    ... def no_way():\n    ...     pass\n    Traceback (most recent call last):\n    ...\n    TimeOutWaitingFor: no_way\n\n    >>> @wait(timeout=.01)\n    ... def no_way():\n    ...     \"never true\"\n    Traceback (most recent call last):\n    ...\n    TimeOutWaitingFor: never true\n\n.. more tests\n\n    >>> import time\n    >>> now = time.time()\n    >>> @wait(timeout=.01, message='dang')\n    ... def no_way():\n    ...     \"never true\"\n    Traceback (most recent call last):\n    ...\n    TimeOutWaitingFor: dang\n\n    >>> .01 < (time.time() - now) < .03\n    True\n\n\nCustomization\n-------------\n\n``wait`` is an instance of ``Wait``.  With ``Wait``,\nyou can create you're own custom ``wait`` utilities.  For\nexample, if you're testing something that uses getevent, you'd want to\nuse gevent's sleep function:\n\n    >>> import zope.testing.wait\n    >>> wait = zope.testing.wait.Wait(getsleep=lambda : gevent.sleep)\n\nWait takes a number of customization parameters:\n\nexception\n  Timeout exception class\n\ngetnow\n  Function used to get a function for getting the current time.\n\n  Default: lambda : time.time\n\ngetsleep\n  Function used to get a sleep function.\n\n  Default: lambda : time.sleep\n\ntimeout\n  Default timeout\n\n  Default: 9\n\nwait\n  Default time to wait between attempts\n\n  Default: .01\n\n\n.. more tests\n\n    >>> def mysleep(t):\n    ...     print_('mysleep', t)\n    ...     time.sleep(t)\n\n    >>> def mynow():\n    ...     print_('mynow')\n    ...     return time.time()\n\n    >>> wait = zope.testing.wait.Wait(\n    ...    getnow=(lambda : mynow), getsleep=(lambda : mysleep),\n    ...    exception=ValueError, timeout=.1, wait=.02)\n\n    >>> @wait\n    ... def _(state=[]):\n    ...     if len(state) > 1:\n    ...        return True\n    ...     state.append(0)\n    mynow\n    mysleep 0.02\n    mynow\n    mysleep 0.02\n\n    >>> @wait(wait=.002)\n    ... def _(state=[]):\n    ...     if len(state) > 1:\n    ...        return True\n    ...     state.append(0)\n    mynow\n    mysleep 0.002\n    mynow\n    mysleep 0.002\n\n    >>> @wait(timeout=0)\n    ... def _(state=[]):\n    ...     if len(state) > 1:\n    ...        return True\n    ...     state.append(0)\n    Traceback (most recent call last):\n    ...\n    ValueError: _\n\n    >>> wait = zope.testing.wait.Wait(timeout=0)\n    >>> @wait(timeout=0)\n    ... def _(state=[]):\n    ...     if len(state) > 1:\n    ...        return True\n    ...     state.append(0)\n    Traceback (most recent call last):\n    ...\n    TimeOutWaitingFor: _\n\n\nDoctests in TestCase classes\n============================\n\nThe original ``doctest`` unittest integration was based on\n``unittest`` test suites, which have fallen out of favor. This module\nprovides a way to define doctests inside of unittest ``TestCase``\nclasses. It provides better integration with unittest test fixtures,\nbecause doctests use setup provided by the containing test case\nclass. It provides access to unittest assertion methods.\n\nYou can define doctests in multiple ways:\n\n- references to named files\n\n- strings\n\n- decorated functions with docstrings\n\n- reference to named files decorating test-specific setup functions\n\n- reference to named files decorating a test class\n\n.. some setup\n\n   >>> __name__ = 'tests'\n\nHere are some examples::\n\n    >>> from zope.testing import doctestcase\n    >>> import doctest\n    >>> import unittest\n\n    >>> g = 'global'\n\n    >>> class MyTest(unittest.TestCase):\n    ...\n    ...     def setUp(self):\n    ...         self.a = 1\n    ...         self.globs = dict(c=9)\n    ...\n    ...     test1 = doctestcase.file('test-1.txt', optionflags=doctest.ELLIPSIS)\n    ...\n    ...     test2 = doctestcase.docteststring('''\n    ...       >>> self.a, g, c\n    ...       (1, 'global', 9)\n    ...     ''')\n    ...\n    ...     @doctestcase.doctestmethod(optionflags=doctest.ELLIPSIS)\n    ...     def test3(self):\n    ...         '''\n    ...         >>> self.a, self.x, g, c\n    ...         (1, 3, 'global', 9)\n    ...         '''\n    ...         self.x = 3\n    ...\n    ...     @doctestcase.doctestfile('test4.txt')\n    ...     def test4(self):\n    ...         self.x = 5\n\n    >>> import sys\n\n    >>> @doctestcase.doctestfiles('loggingsupport.txt', 'renormalizing.txt')\n    ... class MoreTests(unittest.TestCase):\n    ...\n    ...    def setUp(self):\n    ...        def print_(*args):\n    ...            sys.stdout.write(' '.join(map(str, args))+'\\n')\n    ...        self.globs = dict(print_=print_)\n\n\n.. We can run these tests with the ``unittest`` test runner.\n\n    >>> loader = unittest.TestLoader()\n    >>> sys.stdout.writeln = lambda s: sys.stdout.write(s+'\\n')\n    >>> suite = loader.loadTestsFromTestCase(MyTest)\n    >>> result = suite.run(unittest.TextTestResult(sys.stdout, True, 3))\n    test1 (tests.MyTest) ... ok\n    test2 (tests.MyTest) ... ok\n    test3 (tests.MyTest) ... ok\n    test4 (tests.MyTest) ... ok\n\n    >>> suite = loader.loadTestsFromTestCase(MoreTests)\n    >>> result = suite.run(unittest.TextTestResult(sys.stdout, True, 3))\n    test_loggingsupport (tests.MoreTests) ... ok\n    test_renormalizing (tests.MoreTests) ... ok\n\n    >>> for _, e in result.errors:\n    ...     print(e); print\n\n    Check meta data:\n\n    >>> MyTest.test1.__name__\n    'test_1'\n    >>> import os, zope.testing\n    >>> (MyTest.test1.filepath ==\n    ...  os.path.join(os.path.dirname(zope.testing.__file__), 'test-1.txt'))\n    True\n    >>> MyTest.test1.filename\n    'test-1.txt'\n\n    >>> MyTest.test3.__name__\n    'test3'\n    >>> MyTest.test4.__name__\n    'test4'\n\n    >>> (MyTest.test4.filepath ==\n    ...  os.path.join(os.path.dirname(zope.testing.__file__), 'test4.txt'))\n    True\n    >>> MyTest.test4.filename\n    'test4.txt'\n\n    >>> MoreTests.test_loggingsupport.__name__\n    'test_loggingsupport'\n    >>> MoreTests.test_loggingsupport.filename\n    'loggingsupport.txt'\n    >>> (MoreTests.test_loggingsupport.filepath ==\n    ...  os.path.join(os.path.dirname(zope.testing.__file__),\n    ...               'loggingsupport.txt'))\n    True\n\nIn these examples, 4 constructors were used:\n\ndoctestfile (alias: file)\n  doctestfile makes a file-based test case.\n\n  This can be used as a decorator, in which case, the decorated\n  function is called before the test is run, to provide test-specific\n  setup.\n\ndoctestfiles (alias: files)\n  doctestfiles makes file-based test cases and assigns them to the\n  decorated class.\n\n  Multiple files can be specified and the resulting doctests are added\n  as members of the decorated class.\n\ndocteststring (alias string)\n  docteststring constructs a doctest from a string.\n\ndoctestmethod (alias method)\n  doctestmethod constructs a doctest from a method.\n\n  The method's docstring provides the test. The method's body provides\n  optional test-specific setup.\n\nNote that short aliases are provided, which maye be useful in certain\nimport styles.\n\nTests have access to the following data:\n\n- Tests created with the ``docteststring`` and ``doctestmethod``\n  constructors have access to the module globals of the defining\n  module.\n\n- In tests created with the ``docteststring`` and ``doctestmethod``\n  constructors, the test case instance is available as the ``self``\n  variable.\n\n- In tests created with the ``doctestfile`` and ``doctestfiles``\n  constructor, the test case instance is available as the ``test``\n  variable.\n\n- If a test case defines a globs attribute, it must be a dictionary\n  and it's contents are added to the test globals.\n\nThe constructors accept standard doctest ``optionflags`` and\n``checker`` arguments.\n\nNote that the doctest IGNORE_EXCEPTION_DETAIL option flag is\nadded to optionflags.\n\nWhen using ``doctestfile`` and ``doctestfile``, ``filename`` and\n``filepath`` attributes are available that contain the test file name\nand full path.\n\n``__name__`` attributes of class members\n----------------------------------------\n\nClass members have ``__name__`` attributes set as follows:\n\n- When using ``doctestmethod`` or ``doctestfile`` with a setup\n  function, ``__name__`` attribute is set to the name of the function.\n  A ``test_`` prefix is added, if the name doesn't start with ``test``.\n\n- When ``doctestfile`` is used without a setup function or when\n  ``doctestfiles`` is used, ``__name__`` is set to the last part of the\n  file path with the extension removed and non-word characters\n  converted to underscores. For example, with a test path of\n  ``'/foo/bar/test-it.rst'``, the ``__name__`` attribute is set to\n  ``'test_it'``.  A ``test_`` prefix is added, if the name doesn't\n  start with ``test``.\n\n- when using ``docteststring``, a ``name`` option can be passed in to\n  set ``__name__``.  A ``test_`` prefix is added, if the name doesn't\n  start with ``test``.\n\nThe ``__name__`` attribute is important when using nose, because nose\ndiscovers tests as class members using their ``__name__`` attributes,\nwhereas the unittest and py.test test runners use class dictionary keys.\n\n.. Let's look at some failure cases:\n\n    >>> class MyTest(unittest.TestCase):\n    ...\n    ...     test2 = doctestcase.string('''\n    ...     >>> 1\n    ...     1\n    ...     >>> 1 + 1\n    ...     1\n    ...     ''', name='test2')\n    ...\n    ...     @doctestcase.method\n    ...     def test3(self):\n    ...         '''\n    ...         >>> self.x\n    ...         3\n    ...         >>> 1 + 1\n    ...         1\n    ...         '''\n    ...         self.x = 3\n    ...\n    ...     @doctestcase.file('test4f.txt')\n    ...     def test4(self):\n    ...         self.x = 5\n\n    >>> suite = loader.loadTestsFromTestCase(MyTest)\n    >>> result = suite.run(unittest.TextTestResult(sys.stdout, True, 1))\n    FFF\n    >>> for c, e in result.failures:\n    ...     print(e) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n      ...\n    ...: Failed doctest test for <string>\n      File \"<string>\", line 0, in <string>\n    <BLANKLINE>\n    ----------------------------------------------------------------------\n    File \"<string>\", line 4, in <string>\n    Failed example:\n        1 + 1\n    Expected:\n        1\n    Got:\n        2\n    <BLANKLINE>\n    <BLANKLINE>\n    Traceback (most recent call last):\n      ...\n    ...: Failed doctest test for test3\n      File \"None\", line 10, in test3\n    <BLANKLINE>\n    ----------------------------------------------------------------------\n    Line 4, in test3\n    Failed example:\n        1 + 1\n    Expected:\n        1\n    Got:\n        2\n    <BLANKLINE>\n    <BLANKLINE>\n    Traceback (most recent call last):\n    ...\n    ...: Failed doctest test for test4f.txt\n      File \"...test4f.txt\", line 0, in txt\n    <BLANKLINE>\n    ----------------------------------------------------------------------\n    File \"...test4f.txt\", line 3, in test4f.txt\n    Failed example:\n        1 + 1\n    Expected:\n        1\n    Got:\n        2\n    <BLANKLINE>\n    <BLANKLINE>\n\n    Check string meta data:\n\n    >>> MyTest.test2.__name__\n    'test2'\n\n.. Verify setting optionflags and checker\n\n    >>> class EasyChecker:\n    ...     def check_output(self, want, got, optionflags):\n    ...         return True\n    ...     def output_difference(self, example, got, optionflags):\n    ...         return ''\n\n    >>> class MyTest(unittest.TestCase):\n    ...\n    ...     test2 = doctestcase.string('''\n    ...     >>> 1\n    ...     2\n    ...     ''', checker=EasyChecker())\n    ...\n    ...     @doctestcase.method(optionflags=doctest.ELLIPSIS)\n    ...     def test3(self):\n    ...         '''\n    ...         >>> 'Hello'\n    ...         '...'\n    ...         '''\n    ...\n    ...     @doctestcase.file('test4e.txt', optionflags=doctest.ELLIPSIS)\n    ...     def test4(self):\n    ...         self.x = 5\n\n    >>> suite = loader.loadTestsFromTestCase(MyTest)\n    >>> result = suite.run(unittest.TextTestResult(sys.stdout, True, 2))\n    test2 (tests.MyTest) ... ok\n    test3 (tests.MyTest) ... ok\n    test4 (tests.MyTest) ... ok\n\n.. test __name__ variations\n\n    >>> class MyTest(unittest.TestCase):\n    ...\n    ...     foo = doctestcase.string('''>>> 1''', name='foo')\n    ...\n    ...     @doctestcase.method\n    ...     def bar(self):\n    ...         '''\n    ...         >>> self.x\n    ...         3\n    ...         '''\n    ...     @doctestcase.file('test4f.txt')\n    ...     def baz(self):\n    ...         pass\n    ...     wait = doctestcase.file('wait.txt')\n\n    >>> MyTest.foo.__name__\n    'test_foo'\n    >>> MyTest.bar.__name__\n    'test_bar'\n    >>> MyTest.baz.__name__\n    'test_baz'\n    >>> MyTest.wait.__name__\n    'test_wait'\n\n\nChanges\n=======\n\n4.9 (2021-01-08)\n----------------\n\n- Make ``setupstack.txt`` test work again if the current directory is empty.\n\n\n4.8 (2021-01-04)\n----------------\n\n- Add support for Python 3.8 and 3.9.\n\n- Drop support for Python 3.3 and 3.4.\n\n- Extend IGNORE_EXCEPTION_MODULE_IN_PYTHON2 to cover also exceptions without\n  arguments (thus without a colon on the last line of the traceback output).\n\n\n4.7 (2018-10-04)\n----------------\n\n- Added support for Python 3.7.\n\n\n4.6.2 (2017-06-12)\n------------------\n\n- Remove dependencies on ``zope.interface`` and ``zope.exceptions``;\n  they're not used here.\n\n- Remove use of 2to3 for outdated versions of PyPy3, letting us build\n  universal wheels.\n\n\n4.6.1 (2017-01-04)\n------------------\n\n- Add support for Python 3.6.\n\n\n4.6.0 (2016-10-20)\n------------------\n\n- Introduce option flag ``IGNORE_EXCEPTION_MODULE_IN_PYTHON2`` to normalize\n  exception class names in traceback output. In Python 3 they are displayed as\n  the full dotted name. In Python 2 they are displayed as \"just\" the class\n  name.  When running doctests in Python 3, the option flag will not have any\n  effect, however when running the same test in Python 2, the segments in the\n  full dotted name leading up to the class name are stripped away from the\n  \"expected\" string.\n\n- Drop support for Python 2.6 and 3.2.\n\n- Add support for Python 3.5.\n\n- Cleaned up useless 2to3 conversion.\n\n4.5.0 (2015-09-02)\n------------------\n\n- Added meta data for test case methods created with\n  ``zope.testing.doctestcase``.\n\n  - Reasonable values for ``__name__``, making sure that ``__name__``\n    starts with ``test``.\n\n  - For ``doctestfile`` methods, provide ``filename`` and ``filepath``\n    attributes.\n\n  The meta data us useful, for example, for selecting tests with the\n  nose attribute mechanism.\n\n- Added ``doctestcase.doctestfiles``\n\n  - Define multiple doctest files at once.\n\n  - Automatically assign test class members.  So rather than::\n\n      class MYTests(unittest.TestCase):\n          ...\n          test_foo = doctestcase.doctestfile('foo.txt')\n\n    You can use::\n\n      @doctestcase.doctestfiles('foo.txt', 'bar.txt', ...)\n      class MYTests(unittest.TestCase):\n          ...\n\n4.4.0 (2015-07-16)\n------------------\n\n- Added ``zope.testing.setupstack.mock`` as a convenience function for\n  setting up mocks in tests.  (The Python ``mock`` package must be in\n  the path for this to work. The excellent ``mock`` package isn't a\n  dependency of ``zope.testing``.)\n\n- Added the base class ``zope.testing.setupstack.TestCase`` to make it\n  much easier to use ``zope.testing.setupstack`` in ``unittest`` test\n  cases.\n\n\n4.3.0 (2015-07-15)\n------------------\n\n- Added support for creating doctests as methods of\n  ``unittest.TestCase`` classes so that they can found automatically\n  by test runners, like *nose* that ignore test suites.\n\n4.2.0 (2015-06-01)\n------------------\n\n- **Actually** remove long-deprecated ``zope.testing.doctest`` (announced as\n  removed in 4.0.0) and ``zope.testing.doctestunit``.\n\n- Add support for PyPy and PyPy3.\n\n4.1.3 (2014-03-19)\n------------------\n\n- Add support for Python 3.4.\n\n- Update ``boostrap.py`` to version 2.2.\n\n4.1.2 (2013-02-19)\n------------------\n\n- Adjust Trove classifiers to reflect the currently supported Python\n  versions. Officially drop Python 2.4 and 2.5. Add Python 3.3.\n\n- LP: #1055720: Fix failing test on Python 3.3 due to changed exception\n  messaging.\n\n4.1.1 (2012-02-01)\n------------------\n\n- Fix: Windows test failure.\n\n4.1.0 (2012-01-29)\n------------------\n\n- Add context-manager support to ``zope.testing.setupstack``\n\n- Make ``zope.testing.setupstack`` usable with all tests, not just\n  doctests and added ``zope.testing.setupstack.globs``, which makes it\n  easier to write test setup code that workes with doctests and other\n  kinds of tests.\n\n- Add the ``wait`` module, which makes it easier to deal with\n  non-deterministic timing issues.\n\n- Rename ``zope.testing.renormalizing.RENormalizing`` to\n  ``zope.testing.renormalizing.OutputChecker``. The old name is an\n  alias.\n\n- Update tests to run with Python 3.\n\n- Label more clearly which features are supported by Python 3.\n\n- Reorganize documentation.\n\n4.0.0 (2011-11-09)\n------------------\n\n- Remove the deprecated ``zope.testing.doctest``.\n\n- Add Python 3 support.\n\n- Fix test which fails if there is a file named `Data.fs` in the current\n  working directory.\n\n\n3.10.2 (2010-11-30)\n-------------------\n\n- Fix test of broken symlink handling to not break on Windows.\n\n\n3.10.1 (2010-11-29)\n-------------------\n\n- Fix removal of broken symlinks on Unix.\n\n\n3.10.0 (2010-07-21)\n-------------------\n\n- Remove ``zope.testing.testrunner``, which now is moved to zope.testrunner.\n\n- Update fix for LP #221151 to a spelling compatible with Python 2.4.\n\n3.9.5 (2010-05-19)\n------------------\n\n- LP #579019: When layers are run in parallel, ensure that each ``tearDown``\n  is called, including the first layer which is run in the main\n  thread.\n\n- Deprecate ``zope.testing.testrunner`` and ``zope.testing.exceptions``.\n  They have been moved to a separate zope.testrunner module, and will be\n  removed from zope.testing in 4.0.0, together with ``zope.testing.doctest``.\n\n3.9.4 (2010-04-13)\n------------------\n\n- LP #560259: Fix subunit output formatter to handle layer setup\n  errors.\n\n- LP #399394:  Add a ``--stop-on-error`` / ``--stop`` / ``-x`` option to\n  the testrunner.\n\n- LP #498162:  Add a ``--pdb`` alias for the existing ``--post-mortem``\n  / ``-D`` option to the testrunner.\n\n- LP #547023:  Add a ``--version`` option to the testrunner.\n\n- Add tests for LP #144569 and #69988.\n\n  https://bugs.launchpad.net/bugs/69988\n\n  https://bugs.launchpad.net/zope3/+bug/144569\n\n\n3.9.3 (2010-03-26)\n------------------\n\n- Remove import of ``zope.testing.doctest`` from ``zope.testing.renormalizer``.\n\n- Suppress output to ``sys.stderr`` in ``testrunner-layers-ntd.txt``.\n\n- Suppress ``zope.testing.doctest`` deprecation warning when running\n  our own test suite.\n\n\n3.9.2 (2010-03-15)\n------------------\n\n- Fix broken ``from zope.testing.doctest import *``\n\n3.9.1 (2010-03-15)\n------------------\n\n- No changes; reupload to fix broken 3.9.0 release on PyPI.\n\n3.9.0 (2010-03-12)\n------------------\n\n- Modify the testrunner to use the standard Python ``doctest`` module instead\n  of the deprecated ``zope.testing.doctest``.\n\n- Fix ``testrunner-leaks.txt`` to use the ``run_internal`` helper, so that\n  ``sys.exit`` isn't triggered during the test run.\n\n- Add support for conditionally using a subunit-based output\n  formatter upon request if subunit and testtools are available. Patch\n  contributed by Jonathan Lange.\n\n3.8.7 (2010-01-26)\n------------------\n\n- Downgrade the ``zope.testing.doctest`` deprecation warning into a\n  PendingDeprecationWarning.\n\n3.8.6 (2009-12-23)\n------------------\n\n- Add ``MANIFEST.in`` and reupload to fix broken 3.8.5 release on PyPI.\n\n\n3.8.5 (2009-12-23)\n------------------\n\n- Add back ``DocFileSuite``, ``DocTestSuite``, ``debug_src`` and ``debug``\n  BBB imports back into ``zope.testing.doctestunit``; apparently many packages\n  still import them from there!\n\n- Deprecate ``zope.testing.doctest`` and ``zope.testing.doctestunit``\n  in favor of the stdlib ``doctest`` module.\n\n\n3.8.4 (2009-12-18)\n------------------\n\n- Fix missing imports and undefined variables reported by pyflakes,\n  adding tests to exercise the blind spots.\n\n- Cleaned up unused imports reported by pyflakes.\n\n- Add two new options to generate randomly ordered list of tests and to\n  select a specific order of tests.\n\n- Allow combining RENormalizing checkers via ``+`` now:\n  ``checker1 + checker2`` creates a checker with the transformations of both\n  checkers.\n\n- Fix tests under Python 2.7.\n\n3.8.3 (2009-09-21)\n------------------\n\n- Fix test failures due to using ``split()`` on filenames when running from a\n  directory with spaces in it.\n\n- Fix testrunner behavior on Windows for ``-j2`` (or greater) combined with\n  ``-v`` (or greater).\n\n3.8.2 (2009-09-15)\n------------------\n\n- Remove hotshot profiler when using Python 2.6. That makes zope.testing\n  compatible with Python 2.6\n\n\n3.8.1 (2009-08-12)\n------------------\n\n- Avoid hardcoding ``sys.argv[0]`` as script;\n  allow, for instance, Zope 2's `bin/instance test` (LP#407916).\n\n- Produce a clear error message when a subprocess doesn't follow the\n  ``zope.testing.testrunner`` protocol (LP#407916).\n\n- Avoid unnecessarily squelching verbose output in a subprocess when there are\n  not multiple subprocesses.\n\n- Avoid unnecessarily batching subprocess output, which can stymie automated\n  and human processes for identifying hung tests.\n\n- Include incremental output when there are multiple subprocesses and a\n  verbosity of ``-vv`` or greater is requested.  This again is not batched,\n  supporting automated processes and humans looking for hung tests.\n\n\n3.8.0 (2009-07-24)\n------------------\n\n- Allow testrunner to include descendants of ``unittest.TestCase`` in test\n  modules, which no longer need to provide ``test_suite()``.\n\n\n3.7.7 (2009-07-15)\n------------------\n\n- Clean up support for displaying tracebacks with supplements by turning it\n  into an always-enabled feature and making the dependency on\n  ``zope.exceptions`` explicit.\n\n- Fix #251759: prevent the testrunner descending into directories that\n  aren't Python packages.\n\n- Code cleanups.\n\n\n3.7.6 (2009-07-02)\n------------------\n\n- Add zope-testrunner ``console_scripts`` entry point. This exposes a\n  ``zope-testrunner`` script with default installs allowing the testrunner\n  to be run from the command line.\n\n3.7.5 (2009-06-08)\n------------------\n\n- Fix bug when running subprocesses on Windows.\n\n- The option ``REPORT_ONLY_FIRST_FAILURE`` (command line option \"-1\") is now\n  respected even when a doctest declares its own ``REPORTING_FLAGS``, such as\n  ``REPORT_NDIFF``.\n\n- Fix bug that broke readline with pdb when using doctest\n  (see http://bugs.python.org/issue5727).\n\n- Make tests pass on Windows and Linux at the same time.\n\n\n3.7.4 (2009-05-01)\n------------------\n\n- Filenames of doctest examples now contain the line number and not\n  only the example number. So a stack trace in pdb tells the exact\n  line number of the current example. This fixes\n  https://bugs.launchpad.net/bugs/339813\n\n- Colorization of doctest output correctly handles blank lines.\n\n\n3.7.3 (2009-04-22)\n------------------\n\n- Improve handling of rogue threads:  always exit with status so even\n  spinning daemon threads won't block the runner from exiting. This deprecated\n  the ``--with-exit-status`` option.\n\n\n3.7.2 (2009-04-13)\n------------------\n\n- Fix test failure on Python 2.4 due to slight difference in the way\n  coverage is reported (__init__ files with only a single comment line are now\n  not reported)\n\n- Fix bug that caused the test runner to hang when running subprocesses (as a\n  result Python 2.3 is no longer supported).\n\n- Work around a bug in Python 2.6 (related to\n  http://bugs.python.org/issue1303673) that causes the profile tests to fail.\n\n- Add explanitory notes to ``buildout.cfg`` about how to run the tests with\n  multiple versions of Python\n\n\n3.7.1 (2008-10-17)\n------------------\n\n- The ``setupstack`` temporary directory support now properly handles\n  read-only files by making them writable before removing them.\n\n\n3.7.0 (2008-09-22)\n------------------\n\n- Add alterate setuptools / distutils commands for running all tests\n  using our testrunner.  See 'zope.testing.testrunner.eggsupport:ftest'.\n\n- Add a setuptools-compatible test loader which skips tests with layers:\n  the testrunner used by ``setup.py test`` doesn't know about them, and those\n  tests then fail.  See ``zope.testing.testrunner.eggsupport:SkipLayers``.\n\n- Add support for Jython, when a garbage collector call is sent.\n\n- Add support to bootstrap on Jython.\n\n- Fix NameError in StartUpFailure.\n\n- Open doctest files in universal mode, so that packages released on Windows\n  can be tested on Linux, for example.\n\n\n3.6.0 (2008-07-10)\n------------------\n\n- Add ``-j`` option to parallel tests run in subprocesses.\n\n- RENormalizer accepts plain Python callables.\n\n- Add ``--slow-test`` option.\n\n- Add ``--no-progress`` and ``--auto-progress`` options.\n\n- Complete refactoring of the test runner into multiple code files and a more\n  modular (pipeline-like) architecture.\n\n- Unify unit tests with the layer support by introducing a real unit test\n  layer.\n\n- Add a doctest for ``zope.testing.module``. There were several bugs\n  that were fixed:\n\n  * ``README.txt`` was a really bad default argument for the module\n    name, as it is not a proper dotted name. The code would\n    immediately fail as it would look for the ``txt`` module in the\n    ``README`` package. The default is now ``__main__``.\n\n  * The ``tearDown`` function did not clean up the ``__name__`` entry in the\n    global dictionary.\n\n- Fix a bug that caused a SubprocessError to be generated if a subprocess\n  sent any output to stderr.\n\n- Fix a bug that caused the unit tests to be skipped if run in a subprocess.\n\n\n3.5.1 (2007-08-14)\n------------------\n\n- Invoke post-mortem debugging for layer-setup failures.\n\n3.5.0 (2007-07-19)\n------------------\n\n- Ensure that the test runner works on Python 2.5.\n\n- Add support for ``cProfile``.\n\n- Add output colorizing (``-c`` option).\n\n- Add ``--hide-secondary-failures`` and ``--show-secondary-failures`` options\n  (https://bugs.launchpad.net/zope3/+bug/115454).\n\n- Fix some problems with Unicode in doctests.\n\n- Fix \"Error reading from subprocess\" errors on Unix-like systems.\n\n3.4 (2007-03-29)\n----------------\n\n- Add ``exit-with-status`` support (supports use with buildbot and\n  ``zc.recipe.testing``)\n\n- Add a small framework for automating set up and tear down of\n  doctest tests. See ``setupstack.txt``.\n\n- Allow ``testrunner-wo-source.txt`` and ``testrunner-errors.txt`` to run\n  within a read-only source tree.\n\n3.0 (2006-09-20)\n----------------\n\n- Update the doctest copy with text-file encoding support.\n\n- Add logging-level support to the ``loggingsuppport`` module.\n\n- At verbosity-level 1, dots are not output continuously, without any\n  line breaks.\n\n- Improve output when the inability to tear down a layer causes tests\n  to be run in a subprocess.\n\n- Make ``zope.exception`` required only if the ``zope_tracebacks`` extra is\n  requested.\n\n- Fix the test coverage. If a module, for example `interfaces`, was in an\n  ignored directory/package, then if a module of the same name existed in a\n  covered directory/package, then it was also ignored there, because the\n  ignore cache stored the result by module name and not the filename of the\n  module.\n\n2.0 (2006-01-05)\n----------------\n\n- Release a separate project corresponding to the version of ``zope.testing``\n  shipped as part of the Zope 3.2.0 release.\n\n\n",
  "requires_dist": [
    "setuptools",
    "zope.testrunner ; extra == 'test'"
  ],
  "requires_python": "",
  "current_version": "4.9",
  "released_versions": [
    "3.0",
    "3.10.0",
    "3.10.1",
    "3.10.2",
    "3.10.3",
    "3.4",
    "3.5.0",
    "3.5.1",
    "3.5.3",
    "3.5.4",
    "3.5.5",
    "3.5.6",
    "3.6.0",
    "3.7.0",
    "3.7.1",
    "3.7.2",
    "3.7.3",
    "3.7.4",
    "3.7.5",
    "3.7.6",
    "3.7.7",
    "3.8.0",
    "3.8.1",
    "3.8.2",
    "3.8.3",
    "3.8.4",
    "3.8.5",
    "3.8.6",
    "3.8.7",
    "3.9.0",
    "3.9.1",
    "3.9.2",
    "3.9.3",
    "3.9.4",
    "3.9.5",
    "3.9.6",
    "3.9.7",
    "4.0.0",
    "4.1.0",
    "4.1.0dev-r124241",
    "4.1.1",
    "4.1.2",
    "4.1.3",
    "4.2.0",
    "4.3.0",
    "4.4.0",
    "4.4.1",
    "4.5.0",
    "4.6.0",
    "4.6.1",
    "4.6.2",
    "4.7",
    "4.8",
    "4.9"
  ]
}