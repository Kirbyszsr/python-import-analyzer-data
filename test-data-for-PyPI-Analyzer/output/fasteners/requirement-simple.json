{
  "name": "fasteners",
  "description": "Fasteners\n=========\n\n[![Documentation status](https://readthedocs.org/projects/fasteners/badge/?version=latest)](https://readthedocs.org/projects/fasteners/?badge=latest)\n[![Downloads](https://img.shields.io/pypi/dm/fasteners.svg)](https://pypi.python.org/pypi/fasteners/)\n[![Latest version](https://img.shields.io/pypi/v/fasteners.svg)](https://pypi.python.org/pypi/fasteners/)\n\nCross platform locks for threads and processes.\n\n\ud83d\udd29 Install\n----------\n\n```\npip install fasteners\n```\n\n\ud83d\udd29 Usage\n--------\nLock for processes has the same API as the \n[threading.Lock](https://docs.python.org/3/library/threading.html#threading.Lock)\nfor threads:\n```python\nimport fasteners\nimport threading\n\nlock = threading.Lock()                                 # for threads\nlock = fasteners.InterProcessLock('path/to/lock.file')  # for processes\n\nwith lock:\n    ... # exclusive access\n\n# or alternatively    \n\nlock.acquire()\n... # exclusive access\nlock.release()\n```\n\nReader Writer lock has a similar API, which is the same for threads or processes:\n\n```python\nimport fasteners\n\nrw_lock = fasteners.ReaderWriterLock()                                 # for threads\nrw_lock = fasteners.InterProcessReaderWriterLock('path/to/lock.file')  # for processes\n\nwith rw_lock.write_locked():\n    ... # write access\n\nwith rw_lock.read_locked():\n    ... # read access\n\n# or alternatively\n\nrw_lock.acquire_read_lock()\n... # read access\nrw_lock.release_read_lock()\n\nrw_lock.acquire_write_lock()\n... # write access\nrw_lock.release_write_lock()\n```\n\n\ud83d\udd29 Overview\n-----------\n\nPython standard library provides a lock for threads (both a reentrant one, and a\nnon-reentrant one, see below). Fasteners extends this, and provides a lock for\nprocesses, as well as Reader Writer locks for both threads and processes.\n\nThe specifics of the locks are as follows:\n\n### Process locks\n\nThe `fasteners.InterProcessLock` uses [fcntl](https://man7.org/linux/man-pages/man2/fcntl.2.html) on Unix-like systems and \nmsvc [_locking](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/locking?view=msvc-160) on Windows. \nAs a result, if used cross-platform it guarantees an intersection of their features:\n\n| lock | reentrant | mandatory |\n|------|-----------|-----------|\n| fcntl                        | \u2718 | \u2718 |\n| _locking                     | \u2714 | \u2714 |\n| fasteners.InterProcessLock   | \u2718 | \u2718 |\n\n\nThe `fasteners.InterProcessReaderWriterLock` also uses fcntl on Unix-like systems and \n[LockFileEx](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-lockfileex) on Windows. Their \nfeatures are as follows:\n\n| lock | reentrant | mandatory | upgradable | preference | \n|------|-----------|-----------|------------|------------|\n| fcntl                                    | \u2718 | \u2718 | \u2714 | reader |\n| LockFileEx                               | \u2714 | \u2714 | \u2718 | reader |\n| fasteners.InterProcessReaderWriterLock   | \u2718 | \u2718 | \u2718 | reader |\n\n\n### Thread locks\n\nFasteners do not provide a simple thread lock, but for the sake of comparison note that the `threading` module\nprovides both a reentrant and non-reentrant locks:\n\n| lock | reentrant | mandatory |\n|------|-----------|-----------|\n| threading.Lock  | \u2718 | \u2718 |\n| threading.RLock | \u2714 | \u2718 |\n\n\nThe `fasteners.ReaderWriterLock` at the moment is as follows:\n\n| lock | reentrant | mandatory | upgradable | preference | \n|------|-----------|-----------|-------------|------------|\n| fasteners.ReaderWriterLock | \u2714 | \u2718 | \u2718 | reader |\n\n\ud83d\udd29 Glossary\n-----------\nTo learn more about the various aspects of locks, check the wikipedia pages for \n[locks](https://en.wikipedia.org/wiki/Lock_(computer_science)) and \n[readers writer locks](https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock) as well as the\n[resources](https://github.com/harlowja/fasteners/blob/master/doc/source/api/process_lock.rst) listed in the \ndocumentation. Here we briefly mention the main notions used above.\n\n* **Lock** - a mechanism that prevents two or more threads or processes from running the same code at the same time.\n* **Readers writer lock** - a mechanism that prevents two or more threads from having write (or write and read) access, \nwhile allowing multiple readers.\n* **Reentrant lock** - a lock that can be acquired (and then released) multiple times, as in:\n\n```python\nwith lock:\n    with lock:\n        ... # some code\n```\n* **Mandatory lock** (as opposed to advisory lock) - a lock that is enforced by the operating system, rather than\nby the cooperation between threads or processes\n* **Upgradable readers writer lock** - a readers writer lock that can be upgraded from reader to writer (or downgraded\nfrom writer to reader) without losing the lock that is already held, as in:\n```python\nwith rw_lock.read_locked():\n    ... # read access\n    with rw_lock.write_locked():\n        ... # write access\n    ... # read access\n```\n* **Readers writer lock preference** - describes the behaviour when multiple threads or processes are waiting for \naccess. Some of the patterns are:\n    * **Reader preference** - If lock is held by readers, then new readers will get immediate access. This can result\n    in writers waiting forever (writer starvation)\n    * **Writer preference** - If writer is waiting for a lock, then all the new readers (and writers) will be queued\n    after the writer.\n    * **Phase fair** - Lock that alternates between readers and writers.\n\n\n\n",
  "requires_dist": [
    "six",
    "monotonic (>=0.1) ; python_version < \"3.4\""
  ],
  "requires_python": "",
  "current_version": "0.16",
  "released_versions": [
    "0.10.0",
    "0.11.0",
    "0.12.0",
    "0.13.0",
    "0.14.0",
    "0.14.1",
    "0.15",
    "0.16",
    "0.3.0",
    "0.4.0",
    "0.5.0",
    "0.6.0",
    "0.7.0",
    "0.8.0",
    "0.9.0"
  ]
}