{
  "name": "pyemd",
  "description": ".. image:: https://img.shields.io/travis/wmayner/pyemd/develop.svg?style=flat-square&maxAge=3600\n    :target: https://travis-ci.org/wmayner/pyemd\n.. image:: https://img.shields.io/pypi/pyversions/pyemd.svg?style=flat-square&maxAge=86400\n    :target: https://wiki.python.org/moin/Python2orPython3\n    :alt: Python versions badge\n\nPyEMD: Fast EMD for Python\n==========================\n\nPyEMD is a Python wrapper for `Ofir Pele and Michael Werman's implementation\n<http://ofirpele.droppages.com/>`_ of the `Earth Mover's\nDistance <http://en.wikipedia.org/wiki/Earth_mover%27s_distance>`_ that allows\nit to be used with NumPy. **If you use this code, please cite the papers listed\nat the end of this document.**\n\n\nInstallation\n------------\n\n.. code:: bash\n\n    pip install pyemd\n\n\nUsage\n-----\n\n.. code:: python\n\n    >>> from pyemd import emd\n    >>> import numpy as np\n    >>> first_histogram = np.array([0.0, 1.0])\n    >>> second_histogram = np.array([5.0, 3.0])\n    >>> distance_matrix = np.array([[0.0, 0.5],\n    ...                             [0.5, 0.0]])\n    >>> emd(first_histogram, second_histogram, distance_matrix)\n    3.5\n\nYou can also get the associated minimum-cost flow:\n\n.. code:: python\n\n    >>> from pyemd import emd_with_flow\n    >>> emd_with_flow(first_histogram, second_histogram, distance_matrix)\n    (3.5, [[0.0, 0.0], [0.0, 1.0]])\n\nYou can also calculate the EMD directly from two arrays of observations:\n\n.. code:: python\n\n    >>> from pyemd import emd_samples\n    >>> first_array = [1, 2, 3, 4]\n    >>> second_array = [2, 3, 4, 5]\n    >>> emd_samples(first_array, second_array, bins=2)\n    0.5\n\nDocumentation\n-------------\n\nemd()\n~~~~~\n\n.. code:: python\n\n    emd(first_histogram,\n        second_histogram,\n        distance_matrix,\n        extra_mass_penalty=-1.0)\n\n*Arguments:*\n\n- ``first_histogram`` *(np.ndarray)*: A 1D array of type ``np.float64`` of\n  length *N*.\n- ``second_histogram`` *(np.ndarray)*: A 1D array of ``np.float64`` of length\n  *N*.\n- ``distance_matrix`` *(np.ndarray)*: A 2D array of ``np.float64,`` of size at\n  least *N* \u00d7 *N*. This defines the underlying metric, or ground distance, by\n  giving the pairwise distances between the histogram bins. It must represent a\n  metric; there is no warning if it doesn't.\n\n*Keyword Arguments:*\n\n- ``extra_mass_penalty`` *(float)*: The penalty for extra mass. If you want the\n  resulting distance to be a metric, it should be at least half the diameter of\n  the space (maximum possible distance between any two points). If you want\n  partial matching you can set it to zero (but then the resulting distance is\n  not guaranteed to be a metric). The default value is ``-1.0``, which means the\n  maximum value in the distance matrix is used.\n\n*Returns:* *(float)* The EMD value.\n\n----\n\nemd_with_flow()\n~~~~~~~~~~~~~~~\n\n.. code:: python\n\n    emd_with_flow(first_histogram,\n                  second_histogram,\n                  distance_matrix,\n                  extra_mass_penalty=-1.0)\n\nArguments are the same as for ``emd()``.\n\n*Returns:* *(tuple(float, list(list(float))))* The EMD value and the associated\nminimum-cost flow.\n\n----\n\nemd_samples()\n~~~~~~~~~~~~~\n\n.. code:: python\n\n    emd_samples(first_array,\n                second_array,\n                extra_mass_penalty=-1.0,\n                distance='euclidean',\n                normalized=True,\n                bins='auto',\n                range=None)\n\n*Arguments:*\n\n- ``first_array`` *(Iterable)*: A 1D array of samples used to generate a\n  histogram.\n- ``second_array`` *(Iterable)*: A 1D array of samples used to generate a\n  histogram.\n\n*Keyword Arguments:*\n\n- ``extra_mass_penalty`` *(float)*: Same as for ``emd()``.\n- ``distance`` *(string or function)*: A string or function implementing\n  a metric on a 1D ``np.ndarray``. Defaults to the Euclidean distance. Currently\n  limited to 'euclidean' or your own function, which must take a 1D array and\n  return a square 2D array of pairwise distances.\n- ``normalized`` (*boolean*): If true (default), treat histograms as fractions\n  of the dataset. If false, treat histograms as counts. In the latter case the\n  EMD will vary greatly by array length.\n- ``bins`` *(int or string)*: The number of bins to include in the generated\n  histogram. If a string, must be one of the bin selection algorithms accepted\n  by ``np.histogram()``. Defaults to ``'auto'``, which gives the maximum of the\n  'sturges' and 'fd' estimators.\n- ``range`` *(tuple(int, int))*: The lower and upper range of the bins, passed\n  to ``numpy.histogram()``. Defaults to the range of the union of\n  ``first_array`` and ``second_array``. Note: if the given range is not a\n  superset of the default range, no warning will be given.\n\n*Returns:* *(float)* The EMD value between the histograms of ``first_array`` and\n``second_array``.\n\n----\n\nLimitations and Caveats\n-----------------------\n\n- ``emd()`` and ``emd_with_flow()``:\n\n  - The ``distance_matrix`` is assumed to represent a metric; there is no check\n    to ensure that this is true. See the documentation in\n    ``pyemd/lib/emd_hat.hpp`` for more information.\n  - The histograms and distance matrix must be numpy arrays of type\n    ``np.float64``. The original C++ template function can accept any numerical\n    C++ type, but this wrapper only instantiates the template with ``double``\n    (Cython converts ``np.float64`` to ``double``). If there's demand, I can add\n    support for other types.\n\n- ``emd_with_flow()``:\n\n  - The flow matrix does not contain the flows to/from the extra mass bin.\n\n- ``emd_samples()``:\n\n  - Using the default ``bins='auto'`` results in an extra call to\n    ``np.histogram()`` to determine the bin lengths, since `the NumPy\n    bin-selectors are not exposed in the public API\n    <https://github.com/numpy/numpy/issues/10183>`_. For performance, you may\n    want to set the bins yourself.\n\n\nContributing\n------------\n\nTo help develop PyEMD, fork the project on GitHub and install the requirements\nwith ``pip install -r requirements.txt``.\n\nThe ``Makefile`` defines some tasks to help with development:\n\n- ``test``: Run the test suite\n- ``build`` Generate and compile the Cython extension\n- ``clean``: Remove the compiled Cython extension\n- ``default``: Run ``build``\n\nTests for different Python environments can be run with ``tox``.\n\n\nCredit\n------\n\n- All credit for the actual algorithm and implementation goes to `Ofir Pele\n  <http://www.ariel.ac.il/sites/ofirpele/>`_ and `Michael Werman\n  <http://www.cs.huji.ac.il/~werman/>`_. See the `relevant paper\n  <http://www.seas.upenn.edu/~ofirpele/publications/ICCV2009.pdf>`_.\n- Thanks to the Cython developers for making this kind of wrapper relatively\n  easy to write.\n\nPlease cite these papers if you use this code:\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOfir Pele and Michael Werman. A linear time histogram metric for improved SIFT\nmatching. *Computer Vision - ECCV 2008*, Marseille, France, 2008, pp. 495-508.\n\n.. code-block:: latex\n\n    @INPROCEEDINGS{pele2008,\n      title={A linear time histogram metric for improved sift matching},\n      author={Pele, Ofir and Werman, Michael},\n      booktitle={Computer Vision--ECCV 2008},\n      pages={495--508},\n      year={2008},\n      month={October},\n      publisher={Springer}\n    }\n\nOfir Pele and Michael Werman. Fast and robust earth mover's distances. *Proc.\n2009 IEEE 12th Int. Conf. on Computer Vision*, Kyoto, Japan, 2009, pp. 460-467.\n\n.. code-block:: latex\n\n    @INPROCEEDINGS{pele2009,\n      title={Fast and robust earth mover's distances},\n      author={Pele, Ofir and Werman, Michael},\n      booktitle={2009 IEEE 12th International Conference on Computer Vision},\n      pages={460--467},\n      year={2009},\n      month={September},\n      organization={IEEE}\n    }\n\n\n",
  "requires_dist": [
    "numpy (<2.0.0,>=1.9.0)"
  ],
  "requires_python": "",
  "current_version": "0.5.1",
  "released_versions": [
    "0.0.10",
    "0.0.6",
    "0.0.7",
    "0.0.8",
    "0.0.9",
    "0.1.1",
    "0.2.0",
    "0.3.0",
    "0.4.0",
    "0.4.1",
    "0.4.2",
    "0.4.3",
    "0.4.4",
    "0.5.0",
    "0.5.1"
  ]
}