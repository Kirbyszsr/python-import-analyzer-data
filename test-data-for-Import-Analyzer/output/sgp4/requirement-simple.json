{
  "name": "sgp4",
  "description": "\nThis Python package computes the position and velocity of an\nearth-orbiting satellite, given the satellite's TLE orbital elements\nfrom a source like `CelesTrak <https://celestrak.com/>`_.  It implements\nthe most recent version of SGP4, and is regularly run against the SGP4\ntest suite to make sure that its satellite position predictions **agree\nto within 0.1\u00a0mm** with the predictions of the standard distribution of\nthe algorithm.  This error is far less than the 1\u20133\u00a0km/day by which\nsatellites themselves deviate from the ideal orbits described in TLE\nfiles.\n\n* If your platform supports it, this package compiles and uses the\n  verbatim source code from the official C++ version of SGP4.\n\n* Otherwise, a slower but reliable Python implementation of SGP4 is used\n  instead.\n\n* If, instead of asking for the position of a single satellite at a\n  single time, you supply this library with an array of satellites and\n  an array of times, then the arrays can be processed using machine code\n  instead of requiring you to run a slow Python loop over them.\n\nNote that the SGP4 propagator returns raw *x,y,z* Cartesian coordinates\nin a \u201cTrue Equator Mean Equinox\u201d (TEME) reference frame that\u2019s centered\non the Earth but does not rotate with it \u2014 an \u201cEarth centered inertial\u201d\n(ECI) reference frame.  The SGP4 propagator itself does not implement\nthe math to convert these positions into more official ECI frames like\nJ2000 or the ICRF; nor to convert positions into any Earth-centered\nEarth-fixed (ECEF) frames like the ITRS; nor to convert them to\nlatitudes and longitudes through an Earth ellipsoid like WGS84.\n\nFor conversions into other coordinate frames, look for a comprehensive\nastronomy library that is built atop this one, like the `Skyfield\n<https://rhodesmill.org/skyfield/>`_ library:\n\nhttps://rhodesmill.org/skyfield/earth-satellites.html\n\nUsage\n-----\n\nThis library uses the same function names as the official C++ code, to\nhelp users who may already be familiar with SGP4 in other languages.\nHere is how to compute the x,y,z position and velocity for the\nInternational Space Station at 12:50:19 on 29 June\u00a02000:\n\n>>> from sgp4.api import Satrec\n>>>\n>>> s = '1 25544U 98067A   19343.69339541  .00001764  00000-0  38792-4 0  9991'\n>>> t = '2 25544  51.6439 211.2001 0007417  17.6667  85.6398 15.50103472202482'\n>>> satellite = Satrec.twoline2rv(s, t)\n>>>\n>>> jd, fr = 2458827, 0.362605\n>>> e, r, v = satellite.sgp4(jd, fr)\n>>> e\n0\n>>> print(r)  # True Equator Mean Equinox position (km)\n(-6102.44..., -986.33..., -2820.31...)\n>>> print(v)  # True Equator Mean Equinox velocity (km/s)\n(-1.45..., -5.52..., 5.10...)\n\nAs input, you can provide either:\n\n* A simple floating-point Julian Date for ``jd`` and the value 0.0 for\n  ``fr``, if you are happy with the precision of a 64-bit floating point\n  number.  Note that modern Julian Dates are greater than 2,450,000\n  which means that nearly half of the precision of a 64-bit float will\n  be consumed by the whole part that specifies the day.  The remaining\n  digits will provide a precision for the fraction of around 20.1\u00a0\u00b5s.\n  This should be no problem for the accuracy of your result \u2014 satellite\n  positions usually off by a few kilometers anyway, far less than a\n  satellite moves in 20.1\u00a0\u00b5s \u2014 but if you run a solver that dives down\n  into the microseconds while searching for a rising or setting time,\n  the solver might be bothered by the 20.1\u00a0\u00b5s plateau between each jump\n  in the satellite\u2019s position.\n\n* Or, you can provide a coarse date ``jd`` plus a very precise fraction\n  ``fr`` that supplies the rest of the value.  The Julian Date for which\n  the satellite position is computed is the sum of the two values.  One\n  common practice is to provide the whole number as ``jd`` and the\n  fraction as ``fr``; another is to have ``jd`` carry the fraction 0.5\n  since UTC midnight occurs halfway through each Julian Date.  Either\n  way, splitting the value allows a solver to run all the way down into\n  the nanoseconds and still see SGP4 respond smoothly to tiny date\n  adjustments with tiny changes in the resulting satellite position.\n\nHere is how to intrepret the results:\n\n* ``e`` will be a non-zero error code if the satellite position could\n  not be computed for the given date.  You can ``from sgp4.api import\n  SGP4_ERRORS`` to access a dictionary mapping error codes to error\n  messages explaining what each code means.\n\n* ``r`` measures the satellite position in **kilometers** from the\n  center of the earth in the idiosyncratic True Equator Mean Equinox\n  coordinate frame used by SGP4.\n\n* ``v`` velocity is the rate at which the position is changing,\n  expressed in **kilometers per second**.\n\nIf your application does not natively handle Julian dates, you can\ncompute ``jd`` and ``fr`` from calendar dates using ``jday()``.\n\n>>> from sgp4.api import jday\n>>> jd, fr = jday(2019, 12, 9, 12, 0, 0)\n>>> jd\n2458826.5\n>>> fr\n0.5\n\nOMM\n---\n\nThe industry is making adjustments because the fixed-width TLE format\nwill soon run out of satellite numbers.\n\n* Some TLE files now use a new \u201cAlpha-5\u201d convention that expands the\n  range of satellite numbers by using an initial letter; for example,\n  \u201cE8493\u201d means satellite 148493.  This library now supports the Alpha-5\n  convention and should return the correct integer in Python.\n\n* Some authorities are now distributing satellite elements in an \u201cOMM\u201d\n  Orbit Mean Elements Message format that replaces the TLE format.  You\n  can learn about OMM in Dr.\u00a0T.S. Kelso\u2019s `\u201cA New Way to Obtain GP Data\u201d\n  <https://celestrak.com/NORAD/documentation/gp-data-formats.php>`_ at\n  the CelesTrak site.\n\nYou can already try out experimental support for OMM:\n\n>>> from sgp4 import omm\n\nReading OMM data takes two steps, because OMM supports several different\ntext formats.  First, parse the input text to recover the field names\nand values that it stores; second, build a Python satellite object from\nthose field values.  For example, to load OMM from XML:\n\n>>> with open('sample_omm.xml') as f:\n...     fields = next(omm.parse_xml(f))\n>>> sat = Satrec()\n>>> omm.initialize(sat, fields)\n\nOr, to load OMM from CSV:\n\n>>> with open('sample_omm.csv') as f:\n...     fields = next(omm.parse_csv(f))\n>>> sat = Satrec()\n>>> omm.initialize(sat, fields)\n\nEither way, the satellite object should wind up properly initialized and\nready to start producing positions.\n\nIf you are interested in saving satellite parameters using the new OMM\nformat, then read the section on \u201cExport\u201d below.\n\nEpoch\n-----\n\nOver a given satellite\u2019s lifetime, dozens or hundreds of different TLE\nrecords will be produced as its orbit evolves.  Each TLE record\nspecifies the \u201cepoch date\u201d for which it is most accurate.  Typically a\nTLE is only useful for a couple of weeks to either side of its epoch\ndate, beyond which its predictions become unreliable.\n\nSatellite objects natively provide their epoch as a two-digit year and\nthen a fractional number of days into the year:\n\n>>> satellite.epochyr\n19\n>>> satellite.epochdays\n343.69339541\n\nBecause Sputnik was launched in 1957, satellite element sets will never\nrefer to an earlier year, so years 57 through 99 mean 1957\u20131999 while 0\nthrough 56 mean 2000\u20132056.  The TLE format will presumably be obsolete\nin 2057 and have to be upgraded to 4-digit years.\n\nTo turn the number of days and its fraction into a calendar date and\ntime, use the ``days2mdhms()`` function.\n\n>>> from sgp4.api import days2mdhms\n>>> month, day, hour, minute, second = days2mdhms(19, 343.69339541)\n>>> month\n12\n>>> day\n9\n>>> hour\n16\n>>> minute\n38\n>>> second\n29.363424\n\nThe SGP4 library also translates those two numbers into a Julian date\nand fractional Julian date, since Julian dates are more commonly used in\nastronomy.\n\n>>> satellite.jdsatepoch\n2458826.5\n>>> satellite.jdsatepochF\n0.69339541\n\nFinally, a convenience function is available in the library if you need\nthe epoch date and time as Python ``datetime``.\n\n>>> from sgp4.conveniences import sat_epoch_datetime\n>>> sat_epoch_datetime(satellite)\ndatetime.datetime(2019, 12, 9, 16, 38, 29, 363423, tzinfo=UTC)\n\nArray Acceleration\n------------------\n\nTo avoid the expense of Python loops when you have many dates, you can\npass them as arrays to another method that understands NumPy:\n\n>>> import numpy as np\n>>> np.set_printoptions(precision=2)\n\n>>> jd = np.array((2458826, 2458826, 2458826, 2458826))\n>>> fr = np.array((0.0001, 0.0002, 0.0003, 0.0004))\n\n>>> e, r, v = satellite.sgp4_array(jd, fr)\n\n>>> print(e)\n[0 0 0 0]\n>>> print(r)\n[[-3431.31  2620.15 -5252.97]\n [-3478.86  2575.14 -5243.87]\n [-3526.09  2529.89 -5234.28]\n [-3572.98  2484.41 -5224.19]]\n>>> print(v)\n[[-5.52 -5.19  1.02]\n [-5.49 -5.22  1.08]\n [-5.45 -5.25  1.14]\n [-5.41 -5.28  1.2 ]]\n\nTo avoid the expense of Python loops when you have many satellites and\ndates, build a ``SatrecArray`` from several individual satellites.  Its\n``sgp4()`` method will expect both ``jd`` and ``fr`` to be NumPy arrays,\nso if you only have one date, be sure to provide NumPy arrays of length\none.  Here is a sample computation for 2 satellites and 4 dates:\n\n>>> s = '1 20580U 90037B   19342.88042116  .00000361  00000-0  11007-4 0  9996'\n>>> t = '2 20580  28.4682 146.6676 0002639 185.9222 322.7238 15.09309432427086'\n>>> satellite2 = Satrec.twoline2rv(s, t)\n\n>>> from sgp4.api import SatrecArray\n>>> a = SatrecArray([satellite, satellite2])\n>>> e, r, v = a.sgp4(jd, fr)\n\n>>> np.set_printoptions(precision=2)\n>>> print(e)\n[[0 0 0 0]\n [0 0 0 0]]\n>>> print(r)\n[[[-3431.31  2620.15 -5252.97]\n  [-3478.86  2575.14 -5243.87]\n  [-3526.09  2529.89 -5234.28]\n  [-3572.98  2484.41 -5224.19]]\n<BLANKLINE>\n [[ 5781.85  2564.   -2798.22]\n  [ 5749.36  2618.59 -2814.63]\n  [ 5716.35  2672.94 -2830.78]\n  [ 5682.83  2727.05 -2846.68]]]\n>>> print(v)\n[[[-5.52 -5.19  1.02]\n  [-5.49 -5.22  1.08]\n  [-5.45 -5.25  1.14]\n  [-5.41 -5.28  1.2 ]]\n<BLANKLINE>\n [[-3.73  6.33 -1.91]\n  [-3.79  6.3  -1.88]\n  [-3.85  6.28 -1.85]\n  [-3.91  6.25 -1.83]]]\n\nExport\n------\n\nIf you have a ``Satrec`` you want to share with friends or persist to a\nfile, there\u2019s an export routine that will turn it back into a TLE:\n\n>>> from sgp4 import exporter\n>>> line1, line2 = exporter.export_tle(satellite)\n>>> line1\n'1 25544U 98067A   19343.69339541  .00001764  00000-0  38792-4 0  9991'\n>>> line2\n'2 25544  51.6439 211.2001 0007417  17.6667  85.6398 15.50103472202482'\n\nAnd another that produces the fields defined by the new OMM format (see\nthe \u201cOMM\u201d section above):\n\n>>> from pprint import pprint\n>>> fields = exporter.export_omm(satellite, 'ISS (ZARYA)')\n>>> pprint(fields)\n{'ARG_OF_PERICENTER': 17.6667,\n 'BSTAR': 3.8792e-05,\n 'CENTER_NAME': 'EARTH',\n 'CLASSIFICATION_TYPE': 'U',\n 'ECCENTRICITY': 0.0007417,\n 'ELEMENT_SET_NO': 999,\n 'EPHEMERIS_TYPE': 0,\n 'EPOCH': '2019-12-09T16:38:29.363423',\n 'INCLINATION': 51.6439,\n 'MEAN_ANOMALY': 85.6398,\n 'MEAN_ELEMENT_THEORY': 'SGP4',\n 'MEAN_MOTION': 15.501034720000002,\n 'MEAN_MOTION_DDOT': 0.0,\n 'MEAN_MOTION_DOT': 1.764e-05,\n 'NORAD_CAT_ID': 25544,\n 'OBJECT_ID': '1998-067A',\n 'OBJECT_NAME': 'ISS (ZARYA)',\n 'RA_OF_ASC_NODE': 211.2001,\n 'REF_FRAME': 'TEME',\n 'REV_AT_EPOCH': 20248,\n 'TIME_SYSTEM': 'UTC'}\n\nGravity\n-------\n\nThe SGP4 algorithm operates atop a set of constants specifying how\nstrong the Earth\u2019s gravity is.  The most recent official paper on SGP4\n(see below) specifies that \u201cWe use WGS-72 as the default value\u201d, so this\nPython module uses the same default.  But in case you want to use either\nthe old legacy version of the WGS-72 constants, or else the non-standard\nbut more modern WGS-84 constants, the ``twoline2rv()`` constructor takes\nan optional argument:\n\n>>> from sgp4.api import WGS72OLD, WGS72, WGS84\n>>> satellite3 = Satrec.twoline2rv(s, t, WGS84)\n\nYou will in general get less accurate results if you choose WGS-84.\nEven though it reflects more recent and accurate measures of the Earth,\nsatellite TLEs across the industry are most likely generated with WGS-72\nas their basis.  The positions you generate will better agree with the\nreal positions of each satellite if you use the same underlying gravity\nconstants as were used to generate the TLE.\n\nProviding your own elements\n---------------------------\n\nIf instead of parsing a TLE you want to specify orbital elements\ndirectly, you can call a satellite object\u2019s ``sgp4init()`` method with\nthe new elements:\n\n>>> sat = Satrec()\n>>> sat.sgp4init(\n...     WGS72,           # gravity model\n...     'i',             # 'a' = old AFSPC mode, 'i' = improved mode\n...     5,               # satnum: Satellite number\n...     18441.785,       # epoch: days since 1949 December 31 00:00 UT\n...     2.8098e-05,      # bstar: drag coefficient (1/earth radii)\n...     6.969196665e-13, # ndot (NOT USED): ballistic coefficient (revs/day)\n...     0.0,             # nddot (NOT USED): mean motion 2nd derivative (revs/day^3)\n...     0.1859667,       # ecco: eccentricity\n...     5.7904160274885, # argpo: argument of perigee (radians)\n...     0.5980929187319, # inclo: inclination (radians)\n...     0.3373093125574, # mo: mean anomaly (radians)\n...     0.0472294454407, # no_kozai: mean motion (radians/minute)\n...     6.0863854713832, # nodeo: right ascension of ascending node (radians)\n... )\n\n* The two parameters marked \u201cNOT USED\u201d above, ``ndot`` and ``nddot``, do\n  get saved to the satellite object, and do get written out if you write\n  the parameters to a TLE or OMM file.  But they are ignored by SGP4\n  when doing propagation, so you can leave them ``0.0`` without any\n  effect on the resulting satellite positions.\n\n* To compute the \u201cepoch\u201d argument, you can take a normal Julian date and\n  subtract ``2433281.5`` days.\n\n* Once the underlying C++ routine is finished, this Python library \u2014 as\n  a convenience for callers \u2014 goes ahead and sets four time attributes\n  that ``sgp4init()`` leaves unset: the date fields ``epochyr``,\n  ``epochdays``, ``jdsatepoch``, and ``jdsatepochF``.\n\nSee the next section for the complete list of attributes that are\navailable from the satellite record once it has been initialized.\n\nAttributes\n----------\n\nThere are several dozen ``Satrec`` attributes\nthat expose data from the underlying C++ SGP4 record.\nThey fall into several categories.\n\n*Identification*\n\nThese are copied directly from the TLE record but aren\u2019t used by the\npropagation math.\n\n| ``satnum`` \u2014 Unique number assigned to the satellite.\n| ``classification`` \u2014 ``'U'``, ``'C'``, or ``'S'``\n  indicating the element set is Unclassified, Classified, or Secret.\n| ``ephtype`` \u2014 Integer \u201cephemeris type\u201d, used internally by space\n  agencies to mark element sets that are not ready for publication;\n  this field should always be ``0`` in published TLEs.\n| ``elnum`` \u2014 Element set number.\n| ``revnum`` \u2014 Satellite\u2019s revolution number at the moment of the epoch,\n  presumably counting from 1 following launch.\n\n*The Orbital Elements*\n\nThese are the orbital parameters, copied verbatim from the text of the\nTLE record.  They describe the orbit at the moment of the TLE\u2019s epoch\nand so remain constant even as the satellite record is used over and\nover again to propagate positions for different times.\n\n| ``epochyr`` \u2014 Epoch date: the last two digits of the year.\n| ``epochdays`` \u2014 Epoch date: the number of days into the year,\n  including a decimal fraction for the UTC time of day.\n| ``ndot`` \u2014 First time derivative of the mean motion\n  (loaded from the TLE, but otherwise ignored).\n| ``nddot`` \u2014 Second time derivative of the mean motion\n  (loaded from the TLE, but otherwise ignored).\n| ``bstar`` \u2014 Ballistic drag coefficient B* (1/earth\u00a0radii).\n| ``inclo`` \u2014 Inclination (radians).\n| ``nodeo`` \u2014 Right ascension of ascending node (radians).\n| ``ecco`` \u2014 Eccentricity.\n| ``argpo`` \u2014 Argument of perigee (radians).\n| ``mo`` \u2014 Mean anomaly (radians).\n| ``no_kozai`` \u2014 Mean motion (radians/minute).\n| ``no`` \u2014 Alias for ``no_kozai``, for compatibility with old code.\n\nYou can also access the epoch as a Julian date:\n\n| ``jdsatepoch`` \u2014 Whole part of the epoch\u2019s Julian date.\n| ``jdsatepochF`` \u2014 Fractional part of the epoch\u2019s Julian date.\n\n*Derived Orbit Properties*\n\nThese are computed when the satellite is first loaded,\nas a convenience for callers who might be interested in them.\nThey aren\u2019t used by the SGP4 propagator itself.\n\n| ``a`` \u2014 Semi-major axis (earth\u00a0radii).\n| ``altp`` \u2014 Altitude of the satellite at perigee\n  (earth\u00a0radii, assuming a spherical Earth).\n| ``alta`` \u2014 Altitude of the satellite at apogee\n  (earth\u00a0radii, assuming a spherical Earth).\n| ``argpdot`` \u2014 Rate at which the argument of perigee is changing\n  (radians/minute).\n| ``gsto`` \u2014 Greenwich Sidereal Time at the satellite\u2019s epoch (radians).\n| ``mdot`` \u2014 Rate at which the mean anomaly is changing (radians/minute)\n| ``nodedot`` \u2014 Rate at which the right ascension of the ascending node\n  is changing (radians/minute).\n\n*Propagator Mode*\n\n| ``operationmode`` \u2014 A single character that directs SGP4\n  to either operate in its modern ``'i'`` improved mode\n  or in its legacy ``'a'`` AFSPC mode.\n| ``method`` \u2014 A single character, chosen automatically\n  when the orbital elements were loaded, that indicates whether SGP4\n  has chosen to use its built-in ``'n'`` Near Earth\n  or ``'d'`` Deep Space mode for this satellite.\n\n*Results From the Most Recent Call*\n\n| ``t`` \u2014\n  The time you gave when you most recently asked SGP4\n  to compute this satellite\u2019s position,\n  measured in minutes before (negative) or after (position)\n  the satellite\u2019s epoch.\n| ``error`` \u2014\n  Error code produced by the most recent SGP4 propagation\n  you performed with this element set.\n\nThe possible ``error`` codes are:\n\n0. No error.\n1. Mean eccentricity is outside the range 0\u00a0\u2264\u00a0e\u00a0<\u00a01.\n2. Mean motion has fallen below zero.\n3. Perturbed eccentricity is outside the range 0\u00a0\u2264\u00a0e\u00a0\u2264\u00a01.\n4. Length of the orbit\u2019s semi-latus rectum has fallen below zero.\n5. (No longer used.)\n6. Orbit has decayed: the computed position is underground.\n   (The position is still returned, in case the vector is helpful\n   to software that might be searching for the moment of re-entry.)\n\nPartway through each propagation, the SGP4 routine saves a set of\n\u201csingly averaged mean elements\u201d that describe the orbit\u2019s shape at the\nmoment for which a position is being computed.  They are averaged with\nrespect to the mean anomaly and include the effects of secular gravity,\natmospheric drag, and \u2014 in Deep Space mode \u2014 of those pertubations from\nthe Sun and Moon that SGP4 averages over an entire revolution of each of\nthose bodies.  They omit both the shorter-term and longer-term periodic\npertubations from the Sun and Moon that SGP4 applies right before\ncomputing each position.\n\n| ``am`` \u2014 Average semi-major axis (earth\u00a0radii).\n| ``em`` \u2014 Average eccentricity.\n| ``im`` \u2014 Average inclination (radians).\n| ``Om`` \u2014 Average right ascension of ascending node (radians).\n| ``om`` \u2014 Average argument of perigee (radians).\n| ``mm`` \u2014 Average mean anomaly (radians).\n| ``nm`` \u2014 Average mean motion (radians/minute).\n\n*Gravity Model Parameters*\n\nWhen the satellite record is initialized, your choice of gravity model\nresults in a slate of eight constants being copied in:\n\n| ``tumin`` \u2014 Minutes in one \u201ctime unit\u201d.\n| ``xke`` \u2014 The reciprocal of ``tumin``.\n| ``mu`` \u2014 Earth\u2019s gravitational parameter (km\u00b3/s\u00b2).\n| ``radiusearthkm`` \u2014 Radius of the earth (km).\n| ``j2``, ``j3``, ``j4`` \u2014 Un-normalized zonal harmonic values J\u2082, J\u2083, and J\u2084.\n| ``j3oj2`` \u2014 The ratio J\u2083/J\u2082.\n\nValidation against the official algorithm\n-----------------------------------------\n\nThis implementation passes all of the automated tests in the August 2010\nrelease of the reference implementation of SGP4 by Vallado et\u00a0al., who\noriginally published their revision of SGP4 in\u00a02006:\n\n    Vallado, David A., Paul Crawford, Richard Hujsak, and T.S. Kelso,\n    \u201cRevisiting Spacetrack Report #3,\u201d presented at the AIAA/AAS\n    Astrodynamics Specialist Conference, Keystone, CO, 2006 August\n    21\u201324.\n\nIf you would like to review the paper, it is `available online\n<https://www.celestrak.com/publications/AIAA/2006-6753/>`_.  You can\nalways download the latest version of their code for comparison against\nthis Python module (or other implementations) at `AIAA-2006-6753.zip\n<https://www.celestrak.com/publications/AIAA/2006-6753/AIAA-2006-6753.zip>`_.\n\nFor developers\n--------------\n\nDevelopers can check out this full project from GitHub:\n\nhttps://github.com/brandon-rhodes/python-sgp4\n\nTo run its unit tests, install Python\u00a02, Python\u00a03, and the ``tox``\ntesting tool.  The tests runing in Python\u00a02 will exercise the fallback\npure-Python version of the routines, while Python\u00a03 exercises the fast\nnew C++ accelerated code::\n\n    cd python-sgp4\n    tox\n\nLegacy API\n----------\n\nBefore this library pivoted to wrapping Vallado's official C++ code and\nwas operating in pure Python only, it had a slightly quirkier API, which\nis still supported for compatibility with older clients.  You can learn\nabout it by reading the documentation from version 1.4 or earlier:\n\nhttps://pypi.org/project/sgp4/1.4/\n\nChangelog\n---------\n\n| 2021-04-22 \u2014 2.19\n\n* Extended the documentation on the Python Package Index and in the\n  module docstring so it lists every ``Satrec`` attribute that this\n  library exposes; even the more obscure ones might be useful to folks\n  working to analyze satellite orbits.\n\n| 2021-03-08 \u2014 2.18\n\n* If a TLE satellite number lacks the required 5 digits,\n  ``twoline2rv()`` now gives the underlying C++ library a little help so\n  it can still parse the classification and international designator\n  correctly.\n\n* The ``Satrec`` attributes ``jdsatepoch``, ``jdsatepochF``,\n  ``epochyr``, and ``epochdays`` are now writeable, so users can adjust\n  their values manually \u2014 which should make up for the fact that the\n  ``sgp4init()`` method can\u2019t set them with full floating point\n  precision.\n\n| 2021-02-17 \u2014 2.17 \u2014 Fixed where in the output array the ``sgp4_array()`` method writes NaN values when an SGP4 propagation fails.\n| 2021-02-12 \u2014 2.16 \u2014 Fixed ``days2mdhms()`` rounding to always match TLE epoch.\n| 2021-01-08 \u2014 2.15 \u2014 Fixed parsing of the ``satnum`` TLE field in the Python fallback code, when the field has a leading space; added OMM export routine.\n| 2020-12-16 \u2014 2.14 \u2014 New data formats: added OMM message support for both XML and CSV, and added support for the new Alpha-5 extension to TLE files.\n| 2020-10-14 \u2014 2.13 \u2014 Enhanced ``sgp4init()`` with custom code that also sets the ``epochdays`` and ``epochyr`` satellite attributes.\n| 2020-05-28 \u2014 2.12 \u2014 Moved the decision of whether to set the locale during ``twoline2rv()`` from import time to runtime, for users who change locales after their application is up and running.\n| 2020-05-24 \u2014 2.11 \u2014 Fixed a regression in how dates are split into hours, minutes, and seconds that would sometimes produce a time whose second=60, crashing the pure-Python version of the library.\n| 2020-05-22 \u2014 2.10 \u2014 Switch the locale temporarily to ``C`` during the C++ accelerated ``twoline2rv()``, since it does not protect its ``sscanf()`` calls from locales that, like German, expect comma decimal points instead of the period decimal points always used in a TLE.\n| 2020-05-21 \u2014 2.9 \u2014 Added ``sat_epoch_datetime()``, expanded documentation around converting a satellite epoch to a date and time, and started rounding the epoch to exactly the digits provided in the TLE; and removed the ``Satrec.epoch`` attribute from Python fallback code to better match the C++ version.\n| 2020-05-07 \u2014 2.8 \u2014 New function ``jday_datetime()`` is now available in the ``sgp4.conveniences`` module, thanks to Egemen Imre.\n| 2020-04-24 \u2014 2.7 \u2014 New method ``sgp4init()`` (thank you, Chris Lewicki!) is available.\n| 2020-04-20 \u2014 2.6 \u2014 New routine ``export_tle()`` (thank you, Egemen Imre!) is available. Improved how the accelerated C++ backend parses the ``intldesg`` string and the ``revnum`` integer.\n| 2020-03-22 \u2014 2.5 \u2014 Gave the new accelerated ``twoline2rv()`` an optional argument that lets the user choose a non-standard set of gravity constants.\n| 2020-02-25 \u2014 2.4 \u2014 Improved the ``jday()`` docstring; made the old legacy Python resilient if the day of the month is out-of-range (past the end of the month) in a TLE; and Mark Rutten fixed the C++ so it compiles on Windows!\n| 2020-02-04 \u2014 2.3 \u2014 Removed experimental code that caused performance problems for users with Numba installed.\n| 2020-02-02 \u2014 2.2 \u2014 A second release on Palindrome Day: fix the Satrec ``.epochyr`` attribute so it behaves the same way in Python as it does in the official C library, where it is only the last 2 digits of the year; and make ``.no`` available in the Python fallback case as well.\n| 2020-02-02 \u2014 2.1 \u2014 Add vectorized array method to Satrec object; add ``.no`` attribute to new Satrec object to support old code that has not migrated to the new name ``.no_kozai``; gave Python wrapper classes ``__slots__`` to avoid the expense of a per-object attribute dictionary.\n| 2020-01-30 \u2014 2.0 \u2014 Rewrite API to use genuine Vallado C++ code on those systems where it can be compiled; add accelerated vectorized array interface; make ``gstime()`` a public function; clarify format error message.\n| 2015-01-15 \u2014 1.4 \u2014 Display detailed help when TLE input does not match format.\n| 2014-06-26 \u2014 1.3 \u2014 Return ``(NaN,NaN,NaN)`` vectors on error and set ``.error_message``\n| 2013-11-29 \u2014 1.2 \u2014 Made ``epochyr`` 4 digits; add ``datetime`` for ``.epoch``\n| 2012-11-22 \u2014 1.1 \u2014 Python\u00a03 compatibility; more documentation\n| 2012-08-27 \u2014 1.0 \u2014 Initial release\n\n\n\n",
  "requires_dist": null,
  "requires_python": "",
  "current_version": "2.19",
  "released_versions": [
    "1.0",
    "1.1",
    "1.3",
    "1.4",
    "2.0",
    "2.1",
    "2.10",
    "2.11",
    "2.12",
    "2.13",
    "2.14",
    "2.15",
    "2.16",
    "2.17",
    "2.18",
    "2.19",
    "2.2",
    "2.3",
    "2.4",
    "2.5",
    "2.6",
    "2.7",
    "2.8",
    "2.9"
  ]
}