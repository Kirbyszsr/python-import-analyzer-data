{
  "name": "filelock",
  "description": "# py-filelock\n\n![travis-ci](https://travis-ci.org/benediktschmitt/py-filelock.svg?branch=master)\n\nThis package contains a single module, which implements a platform independent\nfile lock in Python, which provides a simple way of inter-process communication:\n\n```Python\nfrom filelock import Timeout, FileLock\n\nlock = FileLock(\"high_ground.txt.lock\")\nwith lock:\n    open(\"high_ground.txt\", \"a\").write(\"You were the chosen one.\")        \n```\n\n**Don't use** a *FileLock* to lock the file you want to write to, instead create\na separate *.lock* file as shown above.\n\n![animated example](https://raw.githubusercontent.com/benediktschmitt/py-filelock/master/example/example.gif)\n\n\n## Similar libraries\n\nPerhaps you are looking for something like\n\n*   https://pypi.python.org/pypi/pid/2.1.1\n*   https://docs.python.org/3.6/library/msvcrt.html#msvcrt.locking\n*   or https://docs.python.org/3/library/fcntl.html#fcntl.flock\n\n\n## Installation\n\n*py-filelock* is available via PyPi:\n\n```\n$ pip3 install filelock\n```\n\n\n## Documentation\n\nThe documentation for the API is available on\n[readthedocs.org](https://filelock.readthedocs.io/).\n\n\n### Examples\n\nA *FileLock* is used to indicate another process of your application that a\nresource or working\ndirectory is currently used. To do so, create a *FileLock* first:\n\n```Python\nfrom filelock import Timeout, FileLock\n\nfile_path = \"high_ground.txt\"\nlock_path = \"high_ground.txt.lock\"\n\nlock = FileLock(lock_path, timeout=1)\n```\n\nThe lock object supports multiple ways for acquiring the lock, including the\nones used to acquire standard Python thread locks:\n\n```Python\nwith lock:\n    open(file_path, \"a\").write(\"Hello there!\")\n\nlock.acquire()\ntry:\n    open(file_path, \"a\").write(\"General Kenobi!\")\nfinally:\n    lock.release()\n```\n\nThe *acquire()* method accepts also a *timeout* parameter. If the lock cannot be\nacquired within *timeout* seconds, a *Timeout* exception is raised:\n\n```Python\ntry:\n    with lock.acquire(timeout=10):\n        open(file_path, \"a\").write(\"I have a bad feeling about this.\")\nexcept Timeout:\n    print(\"Another instance of this application currently holds the lock.\")\n```\n\nThe lock objects are recursive locks, which means that once acquired, they will\nnot block on successive lock requests:\n\n```Python\ndef cite1():\n    with lock:\n        open(file_path, \"a\").write(\"I hate it when he does that.\")\n\ndef cite2():\n    with lock:\n        open(file_path, \"a\").write(\"You don't want to sell me death sticks.\")\n\n# The lock is acquired here.\nwith lock:\n    cite1()\n    cite2()\n\n# And released here.\n```\n\n\n## FileLock vs SoftFileLock\n\nThe *FileLock* is platform dependent while the *SoftFileLock* is not. Use the\n*FileLock* if all instances of your application are running on the same host and\na *SoftFileLock* otherwise.\n\nThe *SoftFileLock* only watches the existence of the lock file. This makes it\nultra portable, but also more prone to dead locks if the application crashes.\nYou can simply delete the lock file in such cases.\n\n\n## Contributions\n\nContributions are always welcome, please make sure they pass all tests before\ncreating a pull request. Never hesitate to open a new issue, although it may\ntake some time for me to respond.\n\n\n## License\n\nThis package is [public domain](./LICENSE.rst).\n\n\n",
  "requires_dist": null,
  "requires_python": "",
  "current_version": "3.0.12",
  "released_versions": [
    "0.2.0",
    "0.2.1",
    "0.2.2",
    "1.0.0",
    "1.0.1",
    "1.0.2",
    "1.0.3",
    "2.0.0",
    "2.0.1",
    "2.0.10",
    "2.0.11",
    "2.0.12",
    "2.0.13",
    "2.0.4",
    "2.0.5",
    "2.0.6",
    "2.0.7",
    "2.0.8",
    "2.0.9",
    "3.0.0",
    "3.0.10",
    "3.0.12",
    "3.0.2",
    "3.0.3",
    "3.0.4",
    "3.0.6",
    "3.0.8",
    "3.0.9"
  ]
}