{
  "name": "cookies",
  "description": "What is this and what is it for?\n--------------------------------\n\ncookies.py is a Python module for working with HTTP cookies: parsing and\nrendering 'Cookie:' request headers and 'Set-Cookie:' response headers,\nand exposing a convenient API for creating and modifying cookies. It can be\nused as a replacement of Python's Cookie.py (aka http.cookies). \n\nFeatures\n--------\n\n* Rendering according to the excellent new RFC 6265 \n  (rather than using a unique ad hoc format inconsistently relating to\n  unrealistic, very old RFCs which everyone ignored). Uses URL encoding to\n  represent non-ASCII by default, like many other languages' libraries\n* Liberal parsing, incorporating many complaints about Cookie.py barfing\n  on common cookie formats which can be reliably parsed (e.g. search 'cookie'\n  on the Python issue tracker)\n* Well-documented code, with chapter and verse from RFCs\n  (rather than arbitrary, undocumented decisions and huge tables of magic \n  values, as you see in Cookie.py). \n* Test coverage at 100%, with a much more comprehensive test suite\n  than Cookie.py\n* Single-source compatible with the following Python versions: \n  2.6, 2.7, 3.2, 3.3 and PyPy (2.7).\n* Cleaner, less surprising API::\n\n    # old Cookie.py - this code is all directly from its docstring\n    >>> from Cookie import SmartCookie\n    >>> C = SmartCookie()\n    >>> # n.b. it's \"smart\" because it automatically pickles Python objects,\n    >>> # which is actually quite stupid for security reasons!\n    >>> C[\"rocky\"] = \"road\"\n    >>> C[\"rocky\"][\"path\"] = \"/cookie\"\n    >>> # So C[\"rocky\"] is a string, except when it's a dict...\n    >>> # and why do I have to write [\"\"] to access a fixed set of attrs?\n    >>> # Look at the atrocious way I render out a request header:\n    >>> C.output(attrs=[], header=\"Cookie:\")\n    'Cookie: rocky=road'\n\n    # new cookies.py\n    >>> from cookies import Cookies, Cookie\n    >>> cookies = Cookies(rocky='road')\n    >>> # Can also write explicitly: cookies['rocky'] = Cookie['road']\n    >>> cookies['rocky'].path = \"/cookie\" \n    >>> cookies.render_request()\n    'rocky=road'\n* Friendly to customization, extension, and reuse of its parts. \n  Unlike Cookie.py, it doesn't lock all implementation inside its own classes\n  (forcing you to write ugly wrappers as Django, Trac, Werkzeug/Flask, web.py\n  and Tornado had to do). You can suppress minor parse exceptions with\n  parameters rather than subclass wrappers. You can plug in your own parsers,\n  renderers and validators for new or existing cookie attributes. You can\n  render the data out in a dict. You can easily use the underlying imperative\n  API or even lift the parser's regexps for your own parser or project. They\n  are very well documented and relate directly to RFCs, so you know exactly\n  what you are getting and why. It's MIT-licensed so do\n  what you want (but I'd love to know what use you are getting from it!)\n* One file, so you can just drop cookies.py into your project if you like\n* MIT license, so you can use it in whatever you want with no strings\n\nThings this is not meant to do\n------------------------------\nWhile this is intended to be a good module for handling cookies, it does not\neven try to do any of the following:\n\n* Maintain backward compatibility with Cookie.py, which would mean\n  inheriting its confusions and bugs\n* Implement RFCs 2109 or 2965, which have always been ignored by almost\n  everyone and are now obsolete as well\n* Handle every conceivable output from terrible legacy apps, which is not\n  possible to do without lots of silent data loss and corruption (the\n  parser does try to be liberal as possible otherwise, though)\n* Provide a means to store pickled Python objects in cookie values\n  (that's a big security hole)\n\nThis doesn't compete with the cookielib (http.cookiejar) module in the Python\nstandard library, which is specifically for implementing cookie storage and\nsimilar behavior in an HTTP client such as a browser. Things cookielib does\nthat this doesn't:\n\n* Write to or read from browsers' cookie stores or other proprietary\n  formats for storing cookie data in files \n* Handle the browser/client logic like deciding which cookies to send or\n  discard, etc. \n\nIf you are looking for a cookie library but neither this one nor cookielib\nwill help, you might also consider the implementations in WebOb or Bottle.",
  "requires_dist": null,
  "requires_python": null,
  "current_version": "2.2.1",
  "released_versions": [
    "0.9.0",
    "0.9.1",
    "1.2.1",
    "2.0.0",
    "2.1.0",
    "2.2.1"
  ]
}