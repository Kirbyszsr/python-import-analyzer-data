{
  "name": "pytest-localserver",
  "description": "==================\npytest-localserver\n==================\n\npytest-localserver is a plugin for the `pytest`_ testing framework which enables\nyou to test server connections locally.\n\nSometimes `monkeypatching`_ ``urllib2.urlopen()`` just does not cut it, for\ninstance if you work with ``urllib2.Request``, define your own openers/handlers\nor work with ``httplib``. In these cases it may come in handy to have an HTTP\nserver running locally which behaves just like the real thing [1]_. Well, look\nno further!\n\nQuickstart\n==========\n\nLet's say you have a function to scrape HTML which only required to be pointed\nat a URL ::\n\n    import requests\n    def scrape(url):\n        html = requests.get(url).text\n        # some parsing happens here\n        # ...\n        return result\n\nYou want to test this function in its entirety without having to rely on a\nremote server whose content you cannot control, neither do you want to waste\ntime setting up a complex mechanism to mock or patch the underlying Python\nmodules dealing with the actual HTTP request (of which there are more than one\nBTW). So what do you do?\n\nYou simply use pytest's `funcargs feature`_ and simulate an entire server\nlocally! ::\n\n    def test_retrieve_some_content(httpserver):\n        httpserver.serve_content(open('cached-content.html').read())\n        assert scrape(httpserver.url) == 'Found it!'\n\nWhat happened here is that for the duration of your tests an HTTP server is\nstarted on a random port on localhost which will serve the content you tell it\nto and behaves just like the real thing.\n\nThe added bonus is that you can test whether your code behaves gracefully if\nthere is a network problem::\n\n    def test_content_retrieval_fails_graciously(httpserver):\n        httpserver.serve_content('File not found!', 404)\n        pytest.raises(ContentNotFoundException, scrape, httpserver.url)\n\nThe same thing works for SMTP servers, too::\n\n    def test_sending_some_message(smtpserver):\n        mailer = MyMailer(host=smtpserver.addr[0], port=smtpserver.addr[1])\n        mailer.send(to='bob@example.com', from_='alice@example.com',\n            subject='MyMailer v1.0', body='Check out my mailer!')\n        assert len(smtpserver.outbox)==1\n\nHere an SMTP server is started which accepts e-mails being sent to it. The\nnice feature here is that you can actually check if the message was received\nand what was sent by looking into the smtpserver's ``outbox``.\n\nIt is really that easy!\n\nAvailable funcargs\n==================\n\nHere is a short overview of the available funcargs. For more details I suggest\npoking around in the code itself.\n\n``httpserver``\n    provides a threaded HTTP server instance running on localhost. It has the\n    following attributes:\n\n    * ``code`` - HTTP response code (int)\n    * ``content`` - content of next response (str)\n    * ``headers`` - response headers (dict)\n\n    Once these attribute are set, all subsequent requests will be answered with\n    these values until they are changed or the server is stopped. A more \n    convenient way to change these is ::\n\n        httpserver.serve_content(content=None, code=200, headers=None) \n\n    The server address can be found in property\n\n    * ``url``\n\n    which is the string representation of tuple ``server_address`` (host as str,\n    port as int).\n\n    If you want to check which form fields have been POSTed, Try ::\n\n        httpserver.serve_content(..., show_post_vars=True)\n\n    which will display them as parsable text.\n\n    If you need to inspect the requests sent to the server, a list of all\n    received requests can be found in property\n\n    * ``requests``\n\n    which is a list of ``werkzeug.wrappers.Request`` objects.\n\n``httpsserver``\n    is the same as ``httpserver`` only with SSL encryption.\n\n``smtpserver``\n    provides a threaded instance of ``smtpd.SMTPServer`` runnning on localhost.\n    It has the following attributes:\n\n    * ``addr`` - server address as tuple (host as str, port as int)\n    * ``outbox`` - list of ``email.message.Message`` instances received.\n\nUsing your a WSGI application as test server\n============================================\n\nAs of version 0.3 you can now use a `WSGI application`_ to run on the test\nserver ::\n\n    from pytest_localserver.http import WSGIServer\n\n    def simple_app(environ, start_response):\n        \"\"\"Simplest possible WSGI application\"\"\"\n        status = '200 OK'\n        response_headers = [('Content-type', 'text/plain')]\n        start_response(status, response_headers)\n        return ['Hello world!\\n']\n\n    @pytest.fixture\n    def testserver(request):\n        \"\"\"Defines the testserver funcarg\"\"\"\n        server = WSGIServer(application=simple_app)\n        server.start()\n        request.addfinalizer(server.stop)\n        return server\n\n    def test_retrieve_some_content(testserver):\n        assert scrape(testserver.url) == 'Hello world!\\n'\n\nHave a look at the following page for more information on WSGI:\nhttp://wsgi.readthedocs.org/en/latest/learn.html\n\nDownload and Installation\n=========================\n\nYou can install the plugin by running ::\n\n    pip install pytest-localserver\n\nAlternatively, get the latest stable version from `PyPI`_ or the latest\n`bleeding-edge archive`_ from bitbucket.org.\n\nLicense and Credits\n===================\n\nThis plugin is released under the MIT license. You can find the full text of\nthe license in the LICENSE file.\n\nCopyright (C) 2010-2013 Sebastian Rahlf and others (see AUTHORS).\n\nSome parts of this package is based on ideas or code from other people:\n\n- I borrowed some implementation ideas for the httpserver from `linkchecker`_.\n- The implementation for the SMTP server is based on the `Mailsink recipe`_ by \n  Adam Feuer, Matt Branthwaite and Troy Frever.\n- The HTTPS implementation is based on work by `Sebastien Martini`_.\n\nThanks guys!\n\nDevelopment and future plans\n============================\n\nFeel free to clone the repository and add your own changes. Pull requests are\nalways welcome!::\n\n    hg clone https://bitbucket.org/pytest-dev/pytest-localserver\n\nIf you find any bugs, please file a `report`_.\n\nTest can be run with tox. Note that you need virtualenv<1.8 to run tests for\nPython 2.4.\n\nI already have a couple of ideas for future versions:\n\n* support for FTP, SSH (maybe base all on twisted?)\n* making the SMTP outbox as convenient to use as ``django.core.mail.outbox``\n* add your own here!\n\n----\n\n.. [1] The idea for this project was born when I needed to check that `a piece\n       of software`_ behaved itself when receiving HTTP error codes 404 and 500.\n       Having unsuccessfully tried to mock a server, I stumbled across \n       `linkchecker`_ which uses a the same idea to test its internals.\n\n.. _monkeypatching: http://pytest.org/latest/monkeypatch.html\n.. _pytest: http://pytest.org/\n.. _funcargs feature: http://pytest.org/latest/funcargs.html\n.. _linkchecker: http://linkchecker.sourceforge.net/\n.. _WSGI application: http://www.python.org/dev/peps/pep-0333/\n.. _PyPI: http://pypi.python.org/pypi/pytest-localserver/\n.. _bleeding-edge archive: https://bitbucket.org/pytest-dev/pytest-localserver/get/tip.tar.gz\n.. _report: https://bitbucket.org/pytest-dev/pytest-localserver/issues/\n.. _tox: http://testrun.org/tox/\n.. _a piece of software: http://pypi.python.org/pypi/python-amazon-product-api/\n.. _Mailsink recipe: http://code.activestate.com/recipes/440690/\n.. _Sebastien Martini: http://code.activestate.com/recipes/442473/\n",
  "requires_dist": null,
  "requires_python": "",
  "current_version": "0.5.0",
  "released_versions": [
    "0.1",
    "0.1.1",
    "0.1.2",
    "0.1.3",
    "0.1.4",
    "0.1.5",
    "0.3",
    "0.3.2",
    "0.3.3",
    "0.3.4",
    "0.3.5",
    "0.3.6",
    "0.3.7",
    "0.4.0",
    "0.4.1",
    "0.4.2",
    "0.5.0"
  ]
}