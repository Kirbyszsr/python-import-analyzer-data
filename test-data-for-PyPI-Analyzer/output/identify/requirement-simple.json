{
  "name": "identify",
  "description": "identify\n========\n\n[![Build Status](https://dev.azure.com/asottile/asottile/_apis/build/status/pre-commit.identify?branchName=master)](https://dev.azure.com/asottile/asottile/_build/latest?definitionId=67&branchName=master)\n[![Azure DevOps coverage](https://img.shields.io/azure-devops/coverage/asottile/asottile/67/master.svg)](https://dev.azure.com/asottile/asottile/_build/latest?definitionId=67&branchName=master)\n[![pre-commit.ci status](https://results.pre-commit.ci/badge/github/pre-commit/identify/master.svg)](https://results.pre-commit.ci/latest/github/pre-commit/identify/master)\n[![PyPI version](https://badge.fury.io/py/identify.svg)](https://pypi.python.org/pypi/identify)\n\nFile identification library for Python.\n\nGiven a file (or some information about a file), return a set of standardized\ntags identifying what the file is.\n\n## Installation\n\n`pip install identify`\n\n## Usage\n### With a file on disk\n\nIf you have an actual file on disk, you can get the most information possible\n(a superset of all other methods):\n\n```python\n>>> from identify import identify\n>>> identify.tags_from_path('/path/to/file.py')\n{'file', 'text', 'python', 'non-executable'}\n>>> identify.tags_from_path('/path/to/file-with-shebang')\n{'file', 'text', 'shell', 'bash', 'executable'}\n>>> identify.tags_from_path('/bin/bash')\n{'file', 'binary', 'executable'}\n>>> identify.tags_from_path('/path/to/directory')\n{'directory'}\n>>> identify.tags_from_path('/path/to/symlink')\n{'symlink'}\n```\n\nWhen using a file on disk, the checks performed are:\n\n* File type (file, symlink, directory, socket)\n* Mode (is it executable?)\n* File name (mostly based on extension)\n* If executable, the shebang is read and the interpreter interpreted\n\n\n### If you only have the filename\n\n```python\n>>> identify.tags_from_filename('file.py')\n{'text', 'python'}\n```\n\n\n### If you only have the interpreter\n\n```python\n>>> identify.tags_from_interpreter('python3.5')\n{'python', 'python3'}\n>>> identify.tags_from_interpreter('bash')\n{'shell', 'bash'}\n>>> identify.tags_from_interpreter('some-unrecognized-thing')\nset()\n```\n\n### As a cli\n\n```\n$ identify-cli --help\nusage: identify-cli [-h] [--filename-only] path\n\npositional arguments:\n  path\n\noptional arguments:\n  -h, --help       show this help message and exit\n  --filename-only\n```\n\n```console\n$ identify-cli setup.py; echo $?\n[\"file\", \"non-executable\", \"python\", \"text\"]\n0\n$ identify setup.py --filename-only; echo $?\n[\"python\", \"text\"]\n0\n$ identify-cli wat.wat; echo $?\nwat.wat does not exist.\n1\n$ identify-cli wat.wat --filename-only; echo $?\n1\n```\n\n### Identifying LICENSE files\n\n`identify` also has an api for determining what type of license is contained\nin a file.  This routine is roughly based on the approaches used by\n[licensee] (the ruby gem that github uses to figure out the license for a\nrepo).\n\nThe approach that `identify` uses is as follows:\n\n1. Strip the copyright line\n2. Normalize all whitespace\n3. Return any exact matches\n4. Return the closest by edit distance (where edit distance < 5%)\n\nTo use the api, install via `pip install identify[license]`\n\n```pycon\n>>> from identify import identify\n>>> identify.license_id('LICENSE')\n'MIT'\n```\n\nThe return value of the `license_id` function is an [SPDX] id.  Currently\nlicenses are sourced from [choosealicense.com].\n\n[licensee]: https://github.com/benbalter/licensee\n[SPDX]: https://spdx.org/licenses/\n[choosealicense.com]: https://github.com/github/choosealicense.com\n\n## How it works\n\nA call to `tags_from_path` does this:\n\n1. What is the type: file, symlink, directory? If it's not file, stop here.\n2. Is it executable? Add the appropriate tag.\n3. Do we recognize the file extension? If so, add the appropriate tags, stop\n   here. These tags would include binary/text.\n4. Peek at the first X bytes of the file. Use these to determine whether it is\n   binary or text, add the appropriate tag.\n5. If identified as text above, try to read and interpret the shebang, and add\n   appropriate tags.\n\nBy design, this means we don't need to partially read files where we recognize\nthe file extension.\n\n\n",
  "requires_dist": [
    "editdistance-s ; extra == 'license'"
  ],
  "requires_python": ">=3.6.1",
  "current_version": "2.2.4",
  "released_versions": [
    "0.0.0.dev1",
    "0.0.1",
    "0.0.2",
    "0.0.3",
    "0.0.4",
    "1.0.0",
    "1.0.1",
    "1.0.10",
    "1.0.11",
    "1.0.12",
    "1.0.13",
    "1.0.14",
    "1.0.15",
    "1.0.16",
    "1.0.17",
    "1.0.18",
    "1.0.2",
    "1.0.3",
    "1.0.4",
    "1.0.5",
    "1.0.6",
    "1.0.7",
    "1.0.8",
    "1.0.9",
    "1.1.0",
    "1.1.1",
    "1.1.2",
    "1.1.3",
    "1.1.4",
    "1.1.5",
    "1.1.6",
    "1.1.7",
    "1.1.8",
    "1.2.0",
    "1.2.1",
    "1.2.2",
    "1.3.0",
    "1.4.0",
    "1.4.1",
    "1.4.10",
    "1.4.11",
    "1.4.12",
    "1.4.13",
    "1.4.14",
    "1.4.15",
    "1.4.16",
    "1.4.17",
    "1.4.18",
    "1.4.19",
    "1.4.2",
    "1.4.20",
    "1.4.21",
    "1.4.22",
    "1.4.23",
    "1.4.24",
    "1.4.25",
    "1.4.26",
    "1.4.27",
    "1.4.28",
    "1.4.29",
    "1.4.3",
    "1.4.30",
    "1.4.4",
    "1.4.5",
    "1.4.6",
    "1.4.7",
    "1.4.8",
    "1.4.9",
    "1.5.0",
    "1.5.1",
    "1.5.10",
    "1.5.11",
    "1.5.12",
    "1.5.13",
    "1.5.14",
    "1.5.2",
    "1.5.3",
    "1.5.4",
    "1.5.5",
    "1.5.6",
    "1.5.7",
    "1.5.8",
    "1.5.9",
    "1.6.0",
    "1.6.1",
    "1.6.2",
    "2.0.0",
    "2.1.0",
    "2.1.1",
    "2.1.2",
    "2.1.3",
    "2.1.4",
    "2.2.0",
    "2.2.1",
    "2.2.2",
    "2.2.3",
    "2.2.4"
  ]
}