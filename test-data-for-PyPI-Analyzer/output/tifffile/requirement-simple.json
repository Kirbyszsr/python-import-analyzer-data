{
  "name": "tifffile",
  "description": "Read and write TIFF files\n=========================\n\nTifffile is a Python library to\n\n(1) store numpy arrays in TIFF (Tagged Image File Format) files, and\n(2) read image and metadata from TIFF-like files used in bioimaging.\n\nImage and metadata can be read from TIFF, BigTIFF, OME-TIFF, STK, LSM, SGI,\nNIHImage, ImageJ, MicroManager, FluoView, ScanImage, SEQ, GEL, SVS, SCN, SIS,\nZIF (Zoomable Image File Format), QPTIFF (QPI), NDPI, and GeoTIFF files.\n\nImage data can be read as numpy arrays or zarr arrays/groups from strips,\ntiles, pages (IFDs), SubIFDs, higher order series, and pyramidal levels.\n\nNumpy arrays can be written to TIFF, BigTIFF, OME-TIFF, and ImageJ hyperstack\ncompatible files in multi-page, volumetric, pyramidal, memory-mappable, tiled,\npredicted, or compressed form.\n\nA subset of the TIFF specification is supported, mainly 8, 16, 32 and 64-bit\ninteger, 16, 32 and 64-bit float, grayscale and multi-sample images.\nSpecifically, CCITT and OJPEG compression, chroma subsampling without JPEG\ncompression, color space transformations, samples with differing types, or\nIPTC and XMP metadata are not implemented.\n\nTIFF, the Tagged Image File Format, was created by the Aldus Corporation and\nAdobe Systems Incorporated. BigTIFF allows for files larger than 4 GB.\nSTK, LSM, FluoView, SGI, SEQ, GEL, QPTIFF, NDPI, SCN, ZIF, and OME-TIFF,\nare custom extensions defined by Molecular Devices (Universal Imaging\nCorporation), Carl Zeiss MicroImaging, Olympus, Silicon Graphics International,\nMedia Cybernetics, Molecular Dynamics, PerkinElmer, Hamamatsu, Leica,\nObjectivePathology, and the Open Microscopy Environment consortium,\nrespectively.\n\nFor command line usage run ``python -m tifffile --help``\n\n:Author:\n  `Christoph Gohlke <https://www.lfd.uci.edu/~gohlke/>`_\n\n:Organization:\n  Laboratory for Fluorescence Dynamics, University of California, Irvine\n\n:License: BSD 3-Clause\n\n:Version: 2021.4.8\n\nRequirements\n------------\nThis release has been tested with the following requirements and dependencies\n(other versions may work):\n\n* `CPython 3.7.9, 3.8.8, 3.9.2 64-bit <https://www.python.org>`_\n* `Numpy 1.19.5 <https://pypi.org/project/numpy/>`_\n* `Imagecodecs 2021.3.31 <https://pypi.org/project/imagecodecs/>`_\n  (required only for encoding or decoding LZW, JPEG, etc.)\n* `Matplotlib 3.3.3 <https://pypi.org/project/matplotlib/>`_\n  (required only for plotting)\n* `Lxml 4.6.3 <https://pypi.org/project/lxml/>`_\n  (required only for validating and printing XML)\n* `Zarr 2.7.0 <https://pypi.org/project/zarr/>`_\n  (required only for opening zarr storage)\n\nRevisions\n---------\n2021.4.8\n    Pass 4393 tests.\n    Fix reading OJPEG with wrong photometric or samplesperpixel tags (#75).\n    Fix fsspec ReferenceFileSystem v1 and JPEG compression.\n    Use TiffTagRegistry for NDPI_TAGS, EXIF_TAGS, GPS_TAGS, IOP_TAGS constants.\n    Make TIFF.GEO_KEYS an Enum (breaking).\n2021.3.31\n    Use JPEG restart markers as tile offsets in NDPI.\n    Support version 1 and more codecs in fsspec ReferenceFileSystem (untested).\n2021.3.17\n    Fix regression reading multi-file OME-TIFF with missing files (#72).\n    Fix fsspec ReferenceFileSystem with non-native byte order (#56).\n2021.3.16\n    TIFF is no longer a defended trademark.\n    Add method to export fsspec ReferenceFileSystem from ZarrTiffStore (#56).\n2021.3.5\n    Preliminary support for EER format (#68).\n    Do not warn about unknown compression (#68).\n2021.3.4\n    Fix reading multi-file, multi-series OME-TIFF (#67).\n    Detect ScanImage 2021 files (#46).\n    Shape new version ScanImage series according to metadata (breaking).\n    Remove Description key from TiffFile.scanimage_metadata dict (breaking).\n    Also return ScanImage version from read_scanimage_metadata (breaking).\n    Fix docstrings.\n2021.2.26\n    Squeeze axes of LSM series by default (breaking).\n    Add option to preserve single dimensions when reading from series (WIP).\n    Do not allow appending to OME-TIFF files.\n    Fix reading STK files without name attribute in metadata.\n    Make TIFF constants multi-thread safe and pickleable (#64).\n    Add detection of NDTiffStorage MajorVersion to read_micromanager_metadata.\n    Support ScanImage v4 files in read_scanimage_metadata.\n2021.2.1\n    Fix multi-threaded access of ZarrTiffStores using same TiffFile instance.\n    Use fallback zlib and lzma codecs with imagecodecs lite builds.\n    Open Olympus and Panasonic RAW files for parsing, albeit not supported.\n    Support X2 and X4 differencing found in DNG.\n    Support reading JPEG_LOSSY compression found in DNG.\n2021.1.14\n    Try ImageJ series if OME series fails (#54)\n    Add option to use pages as chunks in ZarrFileStore (experimental).\n    Fix reading from file objects with no readinto function.\n2021.1.11\n    Fix test errors on PyPy.\n    Fix decoding bitorder with imagecodecs >= 2021.1.11.\n2021.1.8\n    Decode float24 using imagecodecs >= 2021.1.8.\n    Consolidate reading of segments if possible.\n2020.12.8\n    Fix corrupted ImageDescription in multi shaped series if buffer too small.\n    Fix libtiff warning that ImageDescription contains null byte in value.\n    Fix reading invalid files using JPEG compression with palette colorspace.\n2020.12.4\n    Fix reading some JPEG compressed CFA images.\n    Make index of SubIFDs a tuple.\n    Pass through FileSequence.imread arguments in imread.\n    Do not apply regex flags to FileSequence axes patterns (breaking).\n2020.11.26\n    Add option to pass axes metadata to ImageJ writer.\n    Pad incomplete tiles passed to TiffWriter.write (#38).\n    Split TiffTag constructor (breaking).\n    Change TiffTag.dtype to TIFF.DATATYPES (breaking).\n    Add TiffTag.overwrite method.\n    Add script to change ImageDescription in files.\n    Add TiffWriter.overwrite_description method (WIP).\n2020.11.18\n    Support writing SEPARATED color space (#37).\n    Use imagecodecs.deflate codec if available.\n    Fix SCN and NDPI series with Z dimensions.\n    Add TiffReader alias for TiffFile.\n    TiffPage.is_volumetric returns True if ImageDepth > 1.\n    Zarr store getitem returns numpy arrays instead of bytes.\n2020.10.1\n    Formally deprecate unused TiffFile parameters (scikit-image #4996).\n2020.9.30\n    Allow to pass additional arguments to compression codecs.\n    Deprecate TiffWriter.save method (use TiffWriter.write).\n    Deprecate TiffWriter.save compress parameter (use compression).\n    Remove multifile parameter from TiffFile (breaking).\n    Pass all is_flag arguments from imread to TiffFile.\n    Do not byte-swap JPEG2000, WEBP, PNG, JPEGXR segments in TiffPage.decode.\n2020.9.29\n    Fix reading files produced by ScanImage > 2015 (#29).\n2020.9.28\n    Derive ZarrStore from MutableMapping.\n    Support zero shape ZarrTiffStore.\n    Fix ZarrFileStore with non-TIFF files.\n    Fix ZarrFileStore with missing files.\n    Cache one chunk in ZarrFileStore.\n    Keep track of already opened files in FileCache.\n    Change parse_filenames function to return zero-based indices.\n    Remove reopen parameter from asarray (breaking).\n    Rename FileSequence.fromfile to imread (breaking).\n2020.9.22\n    Add experimental zarr storage interface (WIP).\n    Remove unused first dimension from TiffPage.shaped (breaking).\n    Move reading of STK planes to series interface (breaking).\n    Always use virtual frames for ScanImage files.\n    Use DimensionOrder to determine axes order in OmeXml.\n    Enable writing striped volumetric images.\n    Keep complete dataoffsets and databytecounts for TiffFrames.\n    Return full size tiles from Tiffpage.segments.\n    Rename TiffPage.is_sgi property to is_volumetric (breaking).\n    Rename TiffPageSeries.is_pyramid to is_pyramidal (breaking).\n    Fix TypeError when passing jpegtables to non-JPEG decode method (#25).\n2020.9.3\n    Do not write contiguous series by default (breaking).\n    Allow to write to SubIFDs (WIP).\n    Fix writing F-contiguous numpy arrays (#24).\n2020.8.25\n    Do not convert EPICS timeStamp to datetime object.\n    Read incompletely written Micro-Manager image file stack header (#23).\n    Remove tag 51123 values from TiffFile.micromanager_metadata (breaking).\n2020.8.13\n    Use tifffile metadata over OME and ImageJ for TiffFile.series (breaking).\n    Fix writing iterable of pages with compression (#20).\n    Expand error checking of TiffWriter data, dtype, shape, and tile arguments.\n2020.7.24\n    Parse nested OmeXml metadata argument (WIP).\n    Do not lazy load TiffFrame JPEGTables.\n    Fix conditionally skipping some tests.\n2020.7.22\n    Do not auto-enable OME-TIFF if description is passed to TiffWriter.save.\n    Raise error writing empty bilevel or tiled images.\n    Allow to write tiled bilevel images.\n    Allow to write multi-page TIFF from iterable of single page images (WIP).\n    Add function to validate OME-XML.\n    Correct Philips slide width and length.\n2020.7.17\n    Initial support for writing OME-TIFF (WIP).\n    Return samples as separate dimension in OME series (breaking).\n    Fix modulo dimensions for multiple OME series.\n    Fix some test errors on big endian systems (#18).\n    Fix BytesWarning.\n    Allow to pass TIFF.PREDICTOR values to TiffWriter.save.\n2020.7.4\n    Deprecate support for Python 3.6 (NEP 29).\n    Move pyramidal subresolution series to TiffPageSeries.levels (breaking).\n    Add parser for SVS, SCN, NDPI, and QPI pyramidal series.\n    Read single-file OME-TIFF pyramids.\n    Read NDPI files > 4 GB (#15).\n    Include SubIFDs in generic series.\n    Preliminary support for writing packed integer arrays (#11, WIP).\n    Read more LSM info subrecords.\n    Fix missing ReferenceBlackWhite tag for YCbCr photometrics.\n    Fix reading lossless JPEG compressed DNG files.\n2020.6.3\n    ...\n\nRefer to the CHANGES file for older revisions.\n\nNotes\n-----\nThe API is not stable yet and might change between revisions.\n\nTested on little-endian platforms only.\n\nPython 32-bit versions are deprecated. Python <= 3.7 are no longer supported.\n\nTifffile relies on the `imagecodecs <https://pypi.org/project/imagecodecs/>`_\npackage for encoding and decoding LZW, JPEG, and other compressed image\nsegments.\n\nSeveral TIFF-like formats do not strictly adhere to the TIFF6 specification,\nsome of which allow file or data sizes to exceed the 4 GB limit:\n\n* *BigTIFF* is identified by version number 43 and uses different file\n  header, IFD, and tag structures with 64-bit offsets. It adds more data types.\n  Tifffile can read and write BigTIFF files.\n* *ImageJ* hyperstacks store all image data, which may exceed 4 GB,\n  contiguously after the first IFD. Files > 4 GB contain one IFD only.\n  The size (shape and dtype) of the up to 6-dimensional image data can be\n  determined from the ImageDescription tag of the first IFD, which is Latin-1\n  encoded. Tifffile can read and write ImageJ hyperstacks.\n* *OME-TIFF* stores up to 8-dimensional data in one or multiple TIFF of BigTIFF\n  files. The 8-bit UTF-8 encoded OME-XML metadata found in the ImageDescription\n  tag of the first IFD defines the position of TIFF IFDs in the high\n  dimensional data. Tifffile can read OME-TIFF files, except when the OME-XML\n  metadata are stored in a separate file. Tifffile can write numpy arrays\n  to single-file OME-TIFF.\n* *LSM* stores all IFDs below 4 GB but wraps around 32-bit StripOffsets.\n  The StripOffsets of each series and position require separate unwrapping.\n  The StripByteCounts tag contains the number of bytes for the uncompressed\n  data. Tifffile can read large LSM files.\n* *STK* (MetaMorph Stack) contains additional image planes stored contiguously\n  after the image data of the first page. The total number of planes\n  is equal to the counts of the UIC2tag. Tifffile can read STK files.\n* *NDPI* uses some 64-bit offsets in the file header, IFD, and tag structures.\n  Tag values/offsets can be corrected using high bits stored after IFD\n  structures. Tifffile can read NDPI files > 4 GB. JPEG compressed segments\n  with dimensions >65530 or missing restart markers are not readable with\n  libjpeg. Tifffile works around this limitation by separately decoding the\n  MCUs between restart markers.\n* *Philips* TIFF slides store wrong ImageWidth and ImageLength tag values for\n  tiled pages. The values can be corrected using the DICOM_PIXEL_SPACING\n  attributes of the XML formatted description of the first page. Tifffile can\n  read Philips slides.\n* *ScanImage* optionally allows corrupt non-BigTIFF files > 2 GB. The values\n  of StripOffsets and StripByteCounts can be recovered using the constant\n  differences of the offsets of IFD and tag values throughout the file.\n  Tifffile can read such files if the image data are stored contiguously in\n  each page.\n* *GeoTIFF* sparse files allow strip or tile offsets and byte counts to be 0.\n  Such segments are implicitly set to 0 or the NODATA value on reading.\n  Tifffile can read GeoTIFF sparse files.\n\nOther libraries for reading scientific TIFF files from Python:\n\n* `Python-bioformats <https://github.com/CellProfiler/python-bioformats>`_\n* `Imread <https://github.com/luispedro/imread>`_\n* `GDAL <https://github.com/OSGeo/gdal/tree/master/gdal/swig/python>`_\n* `OpenSlide-python <https://github.com/openslide/openslide-python>`_\n* `PyLibTiff <https://github.com/pearu/pylibtiff>`_\n* `SimpleITK <https://github.com/SimpleITK/SimpleITK>`_\n* `PyLSM <https://launchpad.net/pylsm>`_\n* `PyMca.TiffIO.py <https://github.com/vasole/pymca>`_ (same as fabio.TiffIO)\n* `BioImageXD.Readers <http://www.bioimagexd.net/>`_\n* `CellCognition <https://cellcognition-project.org/>`_\n* `pymimage <https://github.com/ardoi/pymimage>`_\n* `pytiff <https://github.com/FZJ-INM1-BDA/pytiff>`_\n* `ScanImageTiffReaderPython\n  <https://gitlab.com/vidriotech/scanimagetiffreader-python>`_\n* `bigtiff <https://pypi.org/project/bigtiff>`_\n* `Large Image <https://github.com/girder/large_image>`_\n\nSome libraries are using tifffile to write OME-TIFF files:\n\n* `Zeiss Apeer OME-TIFF library\n  <https://github.com/apeer-micro/apeer-ometiff-library>`_\n* `Allen Institute for Cell Science imageio\n  <https://pypi.org/project/aicsimageio>`_\n* `xtiff <https://github.com/BodenmillerGroup/xtiff>`_\n\nOther tools for inspecting and manipulating TIFF files:\n\n* `tifftools <https://github.com/DigitalSlideArchive/tifftools>`_\n* `Tyf <https://github.com/Moustikitos/tyf>`_\n\nReferences\n----------\n* TIFF 6.0 Specification and Supplements. Adobe Systems Incorporated.\n  https://www.adobe.io/open/standards/TIFF.html\n* TIFF File Format FAQ. https://www.awaresystems.be/imaging/tiff/faq.html\n* The BigTIFF File Format.\n  https://www.awaresystems.be/imaging/tiff/bigtiff.html\n* MetaMorph Stack (STK) Image File Format.\n  http://mdc.custhelp.com/app/answers/detail/a_id/18862\n* Image File Format Description LSM 5/7 Release 6.0 (ZEN 2010).\n  Carl Zeiss MicroImaging GmbH. BioSciences. May 10, 2011\n* The OME-TIFF format.\n  https://docs.openmicroscopy.org/ome-model/latest/\n* UltraQuant(r) Version 6.0 for Windows Start-Up Guide.\n  http://www.ultralum.com/images%20ultralum/pdf/UQStart%20Up%20Guide.pdf\n* Micro-Manager File Formats.\n  https://micro-manager.org/wiki/Micro-Manager_File_Formats\n* ScanImage BigTiff Specification - ScanImage 2019.\n  http://scanimage.vidriotechnologies.com/display/SI2019/\n  ScanImage+BigTiff+Specification\n* ZIF, the Zoomable Image File format. http://zif.photo/\n* GeoTIFF File Format https://gdal.org/drivers/raster/gtiff.html\n* Cloud optimized GeoTIFF.\n  https://github.com/cogeotiff/cog-spec/blob/master/spec.md\n* Tags for TIFF and Related Specifications. Digital Preservation.\n  https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n* CIPA DC-008-2016: Exchangeable image file format for digital still cameras:\n  Exif Version 2.31.\n  http://www.cipa.jp/std/documents/e/DC-008-Translation-2016-E.pdf\n* The EER (Electron Event Representation) file format.\n  https://github.com/fei-company/EerReaderLib\n\nExamples\n--------\nWrite a numpy array to a single-page RGB TIFF file:\n\n>>> data = numpy.random.randint(0, 255, (256, 256, 3), 'uint8')\n>>> imwrite('temp.tif', data, photometric='rgb')\n\nRead the image from the TIFF file as numpy array:\n\n>>> image = imread('temp.tif')\n>>> image.shape\n(256, 256, 3)\n\nWrite a 3D numpy array to a multi-page, 16-bit grayscale TIFF file:\n\n>>> data = numpy.random.randint(0, 2**12, (64, 301, 219), 'uint16')\n>>> imwrite('temp.tif', data, photometric='minisblack')\n\nRead the whole image stack from the TIFF file as numpy array:\n\n>>> image_stack = imread('temp.tif')\n>>> image_stack.shape\n(64, 301, 219)\n>>> image_stack.dtype\ndtype('uint16')\n\nRead the image from the first page in the TIFF file as numpy array:\n\n>>> image = imread('temp.tif', key=0)\n>>> image.shape\n(301, 219)\n\nRead images from a selected range of pages:\n\n>>> image = imread('temp.tif', key=range(4, 40, 2))\n>>> image.shape\n(18, 301, 219)\n\nIterate over all pages in the TIFF file and successively read images:\n\n>>> with TiffFile('temp.tif') as tif:\n...     for page in tif.pages:\n...         image = page.asarray()\n\nGet information about the image stack in the TIFF file without reading\nthe image data:\n\n>>> tif = TiffFile('temp.tif')\n>>> len(tif.pages)  # number of pages in the file\n64\n>>> page = tif.pages[0]  # get shape and dtype of the image in the first page\n>>> page.shape\n(301, 219)\n>>> page.dtype\ndtype('uint16')\n>>> page.axes\n'YX'\n>>> series = tif.series[0]  # get shape and dtype of the first image series\n>>> series.shape\n(64, 301, 219)\n>>> series.dtype\ndtype('uint16')\n>>> series.axes\n'QYX'\n>>> tif.close()\n\nInspect the \"XResolution\" tag from the first page in the TIFF file:\n\n>>> with TiffFile('temp.tif') as tif:\n...     tag = tif.pages[0].tags['XResolution']\n>>> tag.value\n(1, 1)\n>>> tag.name\n'XResolution'\n>>> tag.code\n282\n>>> tag.count\n1\n>>> tag.dtype\n<DATATYPES.RATIONAL: 5>\n\nIterate over all tags in the TIFF file:\n\n>>> with TiffFile('temp.tif') as tif:\n...     for page in tif.pages:\n...         for tag in page.tags:\n...             tag_name, tag_value = tag.name, tag.value\n\nOverwrite the value of an existing tag, e.g. XResolution:\n\n>>> with TiffFile('temp.tif', mode='r+b') as tif:\n...     _ = tif.pages[0].tags['XResolution'].overwrite(tif, (96000, 1000))\n\nWrite a floating-point ndarray and metadata using BigTIFF format, tiling,\ncompression, and planar storage:\n\n>>> data = numpy.random.rand(2, 5, 3, 301, 219).astype('float32')\n>>> imwrite('temp.tif', data, bigtiff=True, photometric='minisblack',\n...         compression='deflate', planarconfig='separate', tile=(32, 32),\n...         metadata={'axes': 'TZCYX'})\n\nWrite a volume with xyz voxel size 2.6755x2.6755x3.9474 micron^3 to an\nImageJ hyperstack formatted TIFF file:\n\n>>> volume = numpy.random.randn(57, 256, 256).astype('float32')\n>>> imwrite('temp.tif', volume, imagej=True, resolution=(1./2.6755, 1./2.6755),\n...         metadata={'spacing': 3.947368, 'unit': 'um', 'axes': 'ZYX'})\n\nRead the volume and metadata from the ImageJ file:\n\n>>> with TiffFile('temp.tif') as tif:\n...     volume = tif.asarray()\n...     axes = tif.series[0].axes\n...     imagej_metadata = tif.imagej_metadata\n>>> volume.shape\n(57, 256, 256)\n>>> axes\n'ZYX'\n>>> imagej_metadata['slices']\n57\n\nCreate an empty TIFF file and write to the memory-mapped numpy array:\n\n>>> memmap_image = memmap('temp.tif', shape=(3, 256, 256), dtype='float32')\n>>> memmap_image[1, 255, 255] = 1.0\n>>> memmap_image.flush()\n>>> del memmap_image\n\nMemory-map image data of the first page in the TIFF file:\n\n>>> memmap_image = memmap('temp.tif', page=0)\n>>> memmap_image[1, 255, 255]\n1.0\n>>> del memmap_image\n\nWrite two numpy arrays to a multi-series TIFF file:\n\n>>> series0 = numpy.random.randint(0, 255, (32, 32, 3), 'uint8')\n>>> series1 = numpy.random.randint(0, 1023, (4, 256, 256), 'uint16')\n>>> with TiffWriter('temp.tif') as tif:\n...     tif.write(series0, photometric='rgb')\n...     tif.write(series1, photometric='minisblack')\n\nRead the second image series from the TIFF file:\n\n>>> series1 = imread('temp.tif', series=1)\n>>> series1.shape\n(4, 256, 256)\n\nSuccessively write the frames of one contiguous series to a TIFF file:\n\n>>> data = numpy.random.randint(0, 255, (30, 301, 219), 'uint8')\n>>> with TiffWriter('temp.tif') as tif:\n...     for frame in data:\n...         tif.write(frame, contiguous=True)\n\nAppend an image series to the existing TIFF file:\n\n>>> data = numpy.random.randint(0, 255, (301, 219, 3), 'uint8')\n>>> imwrite('temp.tif', data, append=True)\n\nCreate a TIFF file from a generator of tiles:\n\n>>> data = numpy.random.randint(0, 2**12, (31, 33, 3), 'uint16')\n>>> def tiles(data, tileshape):\n...     for y in range(0, data.shape[0], tileshape[0]):\n...         for x in range(0, data.shape[1], tileshape[1]):\n...             yield data[y : y + tileshape[0], x : x + tileshape[1]]\n>>> imwrite('temp.tif', tiles(data, (16, 16)), tile=(16, 16),\n...         shape=data.shape, dtype=data.dtype)\n\nWrite two numpy arrays to a multi-series OME-TIFF file:\n\n>>> series0 = numpy.random.randint(0, 255, (32, 32, 3), 'uint8')\n>>> series1 = numpy.random.randint(0, 1023, (4, 256, 256), 'uint16')\n>>> with TiffWriter('temp.ome.tif') as tif:\n...     tif.write(series0, photometric='rgb')\n...     tif.write(series1, photometric='minisblack',\n...              metadata={'axes': 'ZYX', 'SignificantBits': 10,\n...                        'Plane': {'PositionZ': [0.0, 1.0, 2.0, 3.0]}})\n\nWrite a tiled, multi-resolution, pyramidal, OME-TIFF file using\nJPEG compression. Sub-resolution images are written to SubIFDs:\n\n>>> data = numpy.arange(1024*1024*3, dtype='uint8').reshape((1024, 1024, 3))\n>>> with TiffWriter('temp.ome.tif', bigtiff=True) as tif:\n...     options = dict(tile=(256, 256), compression='jpeg')\n...     tif.write(data, subifds=2, **options)\n...     # save pyramid levels to the two subifds\n...     # in production use resampling to generate sub-resolutions\n...     tif.write(data[::2, ::2], subfiletype=1, **options)\n...     tif.write(data[::4, ::4], subfiletype=1, **options)\n\nAccess the image levels in the pyramidal OME-TIFF file:\n\n>>> baseimage = imread('temp.ome.tif')\n>>> second_level = imread('temp.ome.tif', series=0, level=1)\n>>> with TiffFile('temp.ome.tif') as tif:\n...     baseimage = tif.series[0].asarray()\n...     second_level = tif.series[0].levels[1].asarray()\n\nIterate over and decode single JPEG compressed tiles in the TIFF file:\n\n>>> with TiffFile('temp.ome.tif') as tif:\n...     fh = tif.filehandle\n...     for page in tif.pages:\n...         for index, (offset, bytecount) in enumerate(\n...             zip(page.dataoffsets, page.databytecounts)\n...         ):\n...             fh.seek(offset)\n...             data = fh.read(bytecount)\n...             tile, indices, shape = page.decode(\n...                 data, index, jpegtables=page.jpegtables\n...             )\n\nUse zarr to access the tiled, pyramidal images in the TIFF file:\n\n>>> import zarr\n>>> store = imread('temp.ome.tif', aszarr=True)\n>>> z = zarr.open(store, mode='r')\n>>> z\n<zarr.hierarchy.Group '/' read-only>\n>>> z[0]  # base layer\n<zarr.core.Array '/0' (1024, 1024, 3) uint8 read-only>\n>>> store.close()\n\nRead images from a sequence of TIFF files as numpy array:\n\n>>> imwrite('temp_C001T001.tif', numpy.random.rand(64, 64))\n>>> imwrite('temp_C001T002.tif', numpy.random.rand(64, 64))\n>>> image_sequence = imread(['temp_C001T001.tif', 'temp_C001T002.tif'])\n>>> image_sequence.shape\n(2, 64, 64)\n\nRead an image stack from a series of TIFF files with a file name pattern\nas numpy or zarr arrays:\n\n>>> image_sequence = TiffSequence('temp_C001*.tif', pattern='axes')\n>>> image_sequence.shape\n(1, 2)\n>>> image_sequence.axes\n'CT'\n>>> data = image_sequence.asarray()\n>>> data.shape\n(1, 2, 64, 64)\n>>> with image_sequence.aszarr() as store:\n...     zarr.open(store, mode='r')\n<zarr.core.Array (1, 2, 64, 64) float64 read-only>\n>>> image_sequence.close()\n\n\n",
  "requires_dist": [
    "numpy (>=1.15.1)",
    "imagecodecs (>=2021.3.31) ; extra == 'all'",
    "matplotlib (>=3.2) ; extra == 'all'",
    "lxml ; extra == 'all'"
  ],
  "requires_python": ">=3.7",
  "current_version": "2021.4.8",
  "released_versions": [
    "0.1.0",
    "0.10.0",
    "0.11.0",
    "0.11.1",
    "0.12.0",
    "0.12.1",
    "0.13.0",
    "0.13.1",
    "0.13.2",
    "0.13.4",
    "0.13.5",
    "0.14.0",
    "0.15.0",
    "0.15.1",
    "0.2.0",
    "0.3.0",
    "0.3.1",
    "0.3.2",
    "0.3.3",
    "0.4",
    "0.5",
    "0.6.0",
    "0.6.1",
    "0.6.2",
    "0.7.0",
    "0.8.0",
    "0.9.0",
    "0.9.1",
    "0.9.2",
    "2018.10.18",
    "2018.11.28",
    "2018.11.6",
    "2019.1.1",
    "2019.1.30",
    "2019.1.4",
    "2019.2.10",
    "2019.2.22",
    "2019.3.18",
    "2019.3.8",
    "2019.5.22",
    "2019.5.30",
    "2019.6.18",
    "2019.7.2",
    "2019.7.20",
    "2019.7.26",
    "2019.7.26.2",
    "2020.10.1",
    "2020.11.18",
    "2020.11.26",
    "2020.12.4",
    "2020.12.8",
    "2020.2.16",
    "2020.5.11",
    "2020.5.25",
    "2020.5.30",
    "2020.5.5",
    "2020.5.7",
    "2020.6.3",
    "2020.7.17",
    "2020.7.22",
    "2020.7.24",
    "2020.7.4",
    "2020.8.13",
    "2020.8.25",
    "2020.9.22",
    "2020.9.28",
    "2020.9.29",
    "2020.9.3",
    "2020.9.30",
    "2021.1.11",
    "2021.1.14",
    "2021.1.8",
    "2021.2.1",
    "2021.2.26",
    "2021.3.16",
    "2021.3.17",
    "2021.3.31",
    "2021.3.4",
    "2021.3.5",
    "2021.4.8"
  ]
}