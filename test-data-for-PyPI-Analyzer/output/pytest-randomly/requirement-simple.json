{
  "name": "pytest-randomly",
  "description": "===============\npytest-randomly\n===============\n\n.. image:: https://img.shields.io/github/workflow/status/pytest-dev/pytest-randomly/CI/main?style=for-the-badge\n   :target: https://github.com/pytest-dev/pytest-randomly/actions?workflow=CI\n\n.. image:: https://img.shields.io/pypi/v/pytest-randomly.svg?style=for-the-badge\n   :target: https://pypi.org/project/pytest-randomly/\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg?style=for-the-badge\n   :target: https://github.com/psf/black\n\n.. image:: https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&logoColor=white&style=for-the-badge\n   :target: https://github.com/pre-commit/pre-commit\n   :alt: pre-commit\n\n.. figure:: https://raw.githubusercontent.com/pytest-dev/pytest-randomly/main/logo.png\n   :scale: 50%\n   :alt: Randomness power.\n\nPytest plugin to randomly order tests and control ``random.seed``.\n\nFeatures\n========\n\nAll of these features are on by default but can be disabled with flags.\n\n* Randomly shuffles the order of test items. This is done first at the level of\n  modules, then at the level of test classes (if you have them), then at the\n  order of functions. This also works with things like doctests.\n* Resets ``random.seed()`` at the start of every test case and test to a fixed\n  number - this defaults to ``time.time()`` from the start of your test run,\n  but you can pass in ``--randomly-seed`` to repeat a randomness-induced\n  failure.\n* If\n  `factory boy <https://factoryboy.readthedocs.io/en/latest/reference.html>`_\n  is installed, its random state is reset at the start of every test. This\n  allows for repeatable use of its random 'fuzzy' features.\n* If `faker <https://pypi.org/project/faker>`_ is installed, its random\n  state is reset at the start of every test. This is also for repeatable fuzzy\n  data in tests - factory boy uses faker for lots of data. This is also done\n  if you're using the ``faker`` pytest fixture, by defining the ``faker_seed``\n  fixture\n  (`docs <https://faker.readthedocs.io/en/master/pytest-fixtures.html#seeding-configuration>`__).\n* If `numpy <http://www.numpy.org/>`_ is installed, its random state is reset\n  at the start of every test.\n* If additional random generators are used, they can be registered under the\n  ``pytest_randomly.random_seeder``\n  `entry point <https://packaging.python.org/specifications/entry-points/>`_ and\n  will have their seed reset at the start of every test. Register a function\n  that takes the current seed value.\n* Works with `pytest-xdist <https://pypi.org/project/pytest-xdist/>`__.\n\nAbout\n=====\n\nRandomness in testing can be quite powerful to discover hidden flaws in the\ntests themselves, as well as giving a little more coverage to your system.\n\nBy randomly ordering the tests, the risk of surprising inter-test dependencies\nis reduced - a technique used in many places, for example Google's C++ test\nrunner `googletest\n<https://code.google.com/p/googletest/wiki/V1_5_AdvancedGuide#Shuffling_the_Tests>`_.\nResearch suggests that \"dependent tests do exist in practice\" and a random\norder of test executions can effectively detect such dependencies [1]_.\nAlternatively, a reverse order of test executions, as provided by `pytest-reverse\n<https://github.com/adamchainz/pytest-reverse>`__, may find less dependent\ntests but can achieve a better benefit/cost ratio.\n\nBy resetting the random seed to a repeatable number for each test, tests can\ncreate data based on random numbers and yet remain repeatable, for example\nfactory boy's fuzzy values. This is good for ensuring that tests specify the\ndata they need and that the tested system is not affected by any data that is\nfilled in randomly due to not being specified.\n\nI have written a `blog post covering the history of\npytest-randomly <https://adamj.eu/tech/2018/01/08/pytest-randomly-history/>`__,\nincluding how it started life as the nose plugin\n`nose-randomly <https://github.com/adamchainz/nose-randomly>`__.\n\nAdditionally, I appeared on the Test and Code podcast to `talk about\npytest-randomly <https://testandcode.com/128>`__.\n\nInstallation\n============\n\nInstall from pip with:\n\n.. code-block:: bash\n\n    python -m pip install pytest-randomly\n\nPython 3.6 to 3.9 supported.\n\n----\n\n**Testing a Django project?**\nCheck out my book `Speed Up Your Django Tests <https://gumroad.com/l/suydt>`__ which covers loads of best practices so you can write faster, more accurate tests.\n\n----\n\nUsage\n=====\n\nPytest will automatically find the plugin and use it when you run ``pytest``.\nThe output will start with an extra line that tells you the random seed that is\nbeing used:\n\n.. code-block:: bash\n\n    $ pytest\n    ...\n    platform darwin -- Python 3.7.2, pytest-4.3.1, py-1.8.0, pluggy-0.9.0\n    Using --randomly-seed=1553614239\n    ...\n\nIf the tests fail due to ordering or randomly created data, you can restart\nthem with that seed using the flag as suggested:\n\n.. code-block:: bash\n\n    pytest --randomly-seed=1234\n\nOr more conveniently, use the special value ``last``:\n\n.. code-block:: bash\n\n    pytest --randomly-seed=last\n\nSince the ordering is by module, then by class, you can debug inter-test\npollution failures by narrowing down which tests are being run to find the bad\ninteraction by rerunning just the module/class:\n\n.. code-block:: bash\n\n    pytest --randomly-seed=1234 tests/module_that_failed/\n\nYou can disable behaviours you don't like with the following flags:\n\n* ``--randomly-dont-reset-seed`` - turn off the reset of ``random.seed()`` at\n  the start of every test\n* ``--randomly-dont-reorganize`` - turn off the shuffling of the order of tests\n\nThe plugin appears to Pytest with the name 'randomly'. To disable it\naltogether, you can use the ``-p`` argument, for example:\n\n.. code-block:: sh\n\n    pytest -p no:randomly\n\nEntry Point\n===========\n\nIf you're using a different randomness generator in your third party package,\nyou can register an entrypoint to be called every time ``pytest-randomly``\nreseeds. Implement the entrypoint ``pytest_randomly.random_seeder``, referring\nto a function/callable that takes one argument, the new seed (int).\n\nFor example in your ``setup.cfg``:\n\n.. code-block:: sh\n\n    [options.entry_points]\n    pytest_randomly.random_seeder =\n        mypackage = mypackage.reseed\n\nThen implement ``reseed(new_seed)``.\n\nReferences\n==========\n\n.. [1] Sai Zhang, Darioush Jalali, Jochen Wuttke, K\u0131van\u00e7 Mu\u015flu, Wing Lam, Michael D. Ernst, and David Notkin. 2014. Empirically revisiting the test independence assumption. In Proceedings of the 2014 International Symposium on Software Testing and Analysis (ISSTA 2014). Association for Computing Machinery, New York, NY, USA, 385\u2013396. doi:https://doi.org/10.1145/2610384.2610404\n\n\n",
  "requires_dist": [
    "pytest",
    "importlib-metadata (>=3.6.0) ; python_version < \"3.10\""
  ],
  "requires_python": ">=3.6",
  "current_version": "3.7.0",
  "released_versions": [
    "1.0.0",
    "1.1.0",
    "1.1.1",
    "1.1.2",
    "1.2.0",
    "1.2.1",
    "1.2.2",
    "1.2.3",
    "2.0.0",
    "2.1.0",
    "2.1.1",
    "3.0.0",
    "3.1.0",
    "3.2.0",
    "3.2.1",
    "3.3.0",
    "3.3.1",
    "3.4.0",
    "3.4.1",
    "3.5.0",
    "3.6.0",
    "3.7.0"
  ]
}