{
  "name": "cached-property",
  "description": "===============================\ncached-property\n===============================\n\n.. image:: https://img.shields.io/pypi/v/cached-property.svg\n    :target: https://pypi.python.org/pypi/cached-property\n\n.. image:: https://github.com/pydanny/cached-property/workflows/Python%20package/badge.svg\n    :target: https://github.com/pydanny/cached-property/actions \n\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n    :target: https://github.com/ambv/black\n    :alt: Code style: black        \n\n\nA decorator for caching properties in classes.\n\nWhy?\n-----\n\n* Makes caching of time or computational expensive properties quick and easy.\n* Because I got tired of copy/pasting this code from non-web project to non-web project.\n* I needed something really simple that worked in Python 2 and 3.\n\nHow to use it\n--------------\n\nLet's define a class with an expensive property. Every time you stay there the\nprice goes up by $50!\n\n.. code-block:: python\n\n    class Monopoly(object):\n\n        def __init__(self):\n            self.boardwalk_price = 500\n\n        @property\n        def boardwalk(self):\n            # In reality, this might represent a database call or time\n            # intensive task like calling a third-party API.\n            self.boardwalk_price += 50\n            return self.boardwalk_price\n\nNow run it:\n\n.. code-block:: python\n\n    >>> monopoly = Monopoly()\n    >>> monopoly.boardwalk\n    550\n    >>> monopoly.boardwalk\n    600\n\nLet's convert the boardwalk property into a ``cached_property``.\n\n.. code-block:: python\n\n    from cached_property import cached_property\n\n    class Monopoly(object):\n\n        def __init__(self):\n            self.boardwalk_price = 500\n\n        @cached_property\n        def boardwalk(self):\n            # Again, this is a silly example. Don't worry about it, this is\n            #   just an example for clarity.\n            self.boardwalk_price += 50\n            return self.boardwalk_price\n\nNow when we run it the price stays at $550.\n\n.. code-block:: python\n\n    >>> monopoly = Monopoly()\n    >>> monopoly.boardwalk\n    550\n    >>> monopoly.boardwalk\n    550\n    >>> monopoly.boardwalk\n    550\n\nWhy doesn't the value of ``monopoly.boardwalk`` change? Because it's a **cached property**!\n\nInvalidating the Cache\n----------------------\n\nResults of cached functions can be invalidated by outside forces. Let's demonstrate how to force the cache to invalidate:\n\n.. code-block:: python\n\n    >>> monopoly = Monopoly()\n    >>> monopoly.boardwalk\n    550\n    >>> monopoly.boardwalk\n    550\n    >>> # invalidate the cache\n    >>> del monopoly.__dict__['boardwalk']\n    >>> # request the boardwalk property again\n    >>> monopoly.boardwalk\n    600\n    >>> monopoly.boardwalk\n    600\n\nWorking with Threads\n---------------------\n\nWhat if a whole bunch of people want to stay at Boardwalk all at once? This means using threads, which\nunfortunately causes problems with the standard ``cached_property``. In this case, switch to using the\n``threaded_cached_property``:\n\n.. code-block:: python\n\n    from cached_property import threaded_cached_property\n\n    class Monopoly(object):\n\n        def __init__(self):\n            self.boardwalk_price = 500\n\n        @threaded_cached_property\n        def boardwalk(self):\n            \"\"\"threaded_cached_property is really nice for when no one waits\n                for other people to finish their turn and rudely start rolling\n                dice and moving their pieces.\"\"\"\n\n            sleep(1)\n            self.boardwalk_price += 50\n            return self.boardwalk_price\n\nNow use it:\n\n.. code-block:: python\n\n    >>> from threading import Thread\n    >>> from monopoly import Monopoly\n    >>> monopoly = Monopoly()\n    >>> threads = []\n    >>> for x in range(10):\n    >>>     thread = Thread(target=lambda: monopoly.boardwalk)\n    >>>     thread.start()\n    >>>     threads.append(thread)\n\n    >>> for thread in threads:\n    >>>     thread.join()\n\n    >>> self.assertEqual(m.boardwalk, 550)\n\n\nWorking with async/await (Python 3.5+)\n--------------------------------------\n\nThe cached property can be async, in which case you have to use await\nas usual to get the value. Because of the caching, the value is only\ncomputed once and then cached:\n\n.. code-block:: python\n\n    from cached_property import cached_property\n\n    class Monopoly(object):\n\n        def __init__(self):\n            self.boardwalk_price = 500\n\n        @cached_property\n        async def boardwalk(self):\n            self.boardwalk_price += 50\n            return self.boardwalk_price\n\nNow use it:\n\n.. code-block:: python\n\n    >>> async def print_boardwalk():\n    ...     monopoly = Monopoly()\n    ...     print(await monopoly.boardwalk)\n    ...     print(await monopoly.boardwalk)\n    ...     print(await monopoly.boardwalk)\n    >>> import asyncio\n    >>> asyncio.get_event_loop().run_until_complete(print_boardwalk())\n    550\n    550\n    550\n\nNote that this does not work with threading either, most asyncio\nobjects are not thread-safe. And if you run separate event loops in\neach thread, the cached version will most likely have the wrong event\nloop. To summarize, either use cooperative multitasking (event loop)\nor threading, but not both at the same time.\n\n\nTiming out the cache\n--------------------\n\nSometimes you want the price of things to reset after a time. Use the ``ttl``\nversions of ``cached_property`` and ``threaded_cached_property``.\n\n.. code-block:: python\n\n    import random\n    from cached_property import cached_property_with_ttl\n\n    class Monopoly(object):\n\n        @cached_property_with_ttl(ttl=5) # cache invalidates after 5 seconds\n        def dice(self):\n            # I dare the reader to implement a game using this method of 'rolling dice'.\n            return random.randint(2,12)\n\nNow use it:\n\n.. code-block:: python\n\n    >>> monopoly = Monopoly()\n    >>> monopoly.dice\n    10\n    >>> monopoly.dice\n    10\n    >>> from time import sleep\n    >>> sleep(6) # Sleeps long enough to expire the cache\n    >>> monopoly.dice\n    3\n    >>> monopoly.dice\n    3\n\n**Note:** The ``ttl`` tools do not reliably allow the clearing of the cache. This\nis why they are broken out into seperate tools. See https://github.com/pydanny/cached-property/issues/16.\n\nCredits\n--------\n\n* Pip, Django, Werkzueg, Bottle, Pyramid, and Zope for having their own implementations. This package originally used an implementation that matched the Bottle version.\n* Reinout Van Rees for pointing out the `cached_property` decorator to me.\n* My awesome wife `@audreyr`_ who created `cookiecutter`_, which meant rolling this out took me just 15 minutes.\n* @tinche for pointing out the threading issue and providing a solution.\n* @bcho for providing the time-to-expire feature\n\n.. _`@audreyr`: https://github.com/audreyr\n.. _`cookiecutter`: https://github.com/audreyr/cookiecutter\n\nSupport This Project\n---------------------------\n\nThis project is maintained by volunteers. Support their efforts by spreading the word about:\n\nDjango Crash Course\n++++++++++++++++++++++++++++++++++++\n\n.. image:: https://cdn.shopify.com/s/files/1/0304/6901/files/Django-Crash-Course-300x436.jpg\n   :name: Django Crash Course: Covers Django 3.0 and Python 3.8\n   :align: center\n   :alt: Django Crash Course\n   :target: https://www.roygreenfeld.com/products/django-crash-course\n\nDjango Crash Course for Django 3.0 and Python 3.8 is the best cheese-themed Django reference in the universe!\n\n\n\n\nHistory\n-------\n\n1.5.2 (2020-09-21)\n++++++++++++++++++\n\n* Add formal support for Python 3.8\n* Remove formal support for Python 3.4\n* Switch from Travis to GitHub actions\n* Made tests pass flake8 for Python 2.7\n\n1.5.1 (2018-08-05)\n++++++++++++++++++\n\n* Added formal support for Python 3.7\n* Removed formal support for Python 3.3\n\n1.4.3  (2018-06-14)\n+++++++++++++++++++\n\n* Catch SyntaxError from asyncio import on older versions of Python, thanks to @asottile\n\n1.4.2 (2018-04-08)\n++++++++++++++++++\n\n* Really fixed tests, thanks to @pydanny\n\n1.4.1 (2018-04-08)\n++++++++++++++++++\n\n* Added conftest.py to manifest so tests work properly off the tarball, thanks to @dotlambda\n* Ensured new asyncio tests didn't break Python 2.7 builds on Debian, thanks to @pydanny\n* Code formatting via black, thanks to @pydanny and @ambv\n\n\n1.4.0 (2018-02-25)\n++++++++++++++++++\n\n* Added asyncio support, thanks to @vbraun\n* Remove Python 2.6 support, whose end of life was 5 years ago, thanks to @pydanny\n\n\n1.3.1 (2017-09-21)\n++++++++++++++++++\n\n* Validate for Python 3.6\n\n\n1.3.0 (2015-11-24)\n++++++++++++++++++\n\n* Drop some non-ASCII characters from HISTORY.rst, thanks to @AdamWill\n* Added official support for Python 3.5, thanks to @pydanny and @audreyr\n* Removed confusingly placed lock from example, thanks to @ionelmc\n* Corrected invalidation cache documentation, thanks to @proofit404\n* Updated to latest Travis-CI environment, thanks to @audreyr\n\n1.2.0 (2015-04-28)\n++++++++++++++++++\n\n* Overall code and test refactoring, thanks to @gsakkis\n* Allow the del statement for resetting cached properties with ttl instead of del obj._cache[attr], thanks to @gsakkis.\n* Uncovered a bug in PyPy, https://bitbucket.org/pypy/pypy/issue/2033/attributeerror-object-attribute-is-read, thanks to @gsakkis\n* Fixed threaded_cached_property_with_ttl to actually be thread-safe, thanks to @gsakkis\n\n1.1.0 (2015-04-04)\n++++++++++++++++++\n\n* Regression: As the cache was not always clearing, we've broken out the time to expire feature to its own set of specific tools, thanks to @pydanny\n* Fixed typo in README, thanks to @zoidbergwill\n\n1.0.0 (2015-02-13)\n++++++++++++++++++\n\n* Added timed to expire feature to ``cached_property`` decorator.\n* **Backwards incompatiblity**: Changed ``del monopoly.boardwalk`` to ``del monopoly['boardwalk']`` in order to support the new TTL feature.\n\n0.1.5 (2014-05-20)\n++++++++++++++++++\n\n* Added threading support with new ``threaded_cached_property`` decorator\n* Documented cache invalidation\n* Updated credits\n* Sourced the bottle implementation\n\n0.1.4 (2014-05-17)\n++++++++++++++++++\n\n* Fix the dang-blarged py_modules argument.\n\n0.1.3 (2014-05-17)\n++++++++++++++++++\n\n* Removed import of package into ``setup.py``\n\n0.1.2 (2014-05-17)\n++++++++++++++++++\n\n* Documentation fixes. Not opening up a RTFD instance for this because it's so simple to use.\n\n0.1.1 (2014-05-17)\n++++++++++++++++++\n\n* setup.py fix. Whoops!\n\n0.1.0 (2014-05-17)\n++++++++++++++++++\n\n* First release on PyPI.\n\n\n",
  "requires_dist": null,
  "requires_python": "",
  "current_version": "1.5.2",
  "released_versions": [
    "0.1.0",
    "0.1.1",
    "0.1.2",
    "0.1.3",
    "0.1.4",
    "0.1.5",
    "1.0.0",
    "1.1.0",
    "1.2.0",
    "1.3.0",
    "1.3.1",
    "1.4.0",
    "1.4.1",
    "1.4.2",
    "1.4.3",
    "1.5.1",
    "1.5.2"
  ]
}