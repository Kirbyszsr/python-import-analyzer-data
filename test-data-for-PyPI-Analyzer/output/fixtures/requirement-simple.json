{
  "name": "fixtures",
  "description": "*************************************************************\nfixtures: Fixtures with cleanups for testing and convenience.\n*************************************************************\n\n  Copyright (c) 2010, Robert Collins <robertc@robertcollins.net>\n  \n  Licensed under either the Apache License, Version 2.0 or the BSD 3-clause\n  license at the users choice. A copy of both licenses are available in the\n  project source as Apache-2.0 and BSD. You may not use this file except in\n  compliance with one of these two licences.\n  \n  Unless required by applicable law or agreed to in writing, software\n  distributed under these licenses is distributed on an \"AS IS\" BASIS, WITHOUT\n  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n  license you chose for the specific language governing permissions and\n  limitations under that license.\n\n\nFixtures defines a Python contract for reusable state / support logic,\nprimarily for unit testing. Helper and adaption logic is included to make it\neasy to write your own fixtures using the fixtures contract. Glue code is\nprovided that makes using fixtures that meet the Fixtures contract in unittest\ncompatible test cases easy and straight forward.\n\nDependencies\n============\n\n* Python 2.6+, or 3.3+\n  This is the base language fixtures is written in and for.\n\n* pbr\n  Used for version and release management of fixtures.\n\n* testtools <https://launchpad.net/testtools> 0.9.22 or newer.\n  testtools provides helpful glue functions for the details API used to report\n  information about a fixture (whether its used in a testing or production\n  environment).\n\nFor use in a unit test suite using the included glue, one of:\n\n* Python 2.7+\n\n* unittest2\n\n* bzrlib.tests\n\n* Or any other test environment that supports TestCase.addCleanup.\n\nWriting your own glue code is easy, or you can simply use Fixtures directly\nwithout any support code.\n\nTo run the test suite for fixtures, testtools is needed.\n\nWhy Fixtures\n============\n\nStandard Python unittest.py provides no obvious method for making and reusing\nstate needed in a test case other than by adding a method on the test class.\nThis scales poorly - complex helper functions propagating up a test class\nhierarchy is a regular pattern when this is done. Mocking while a great tool\ndoesn't itself prevent this (and helpers to mock complex things can accumulate\nin the same way if placed on the test class).\n\nBy defining a uniform contract where helpers have no dependency on the test\nclass we permit all the regular code hygiene activities to take place without\nthe distorting influence of being in a class hierarchy that is modelling an\nentirely different thing - which is what helpers on a TestCase suffer from.\n\nAbout Fixtures\n==============\n\nA Fixture represents some state. Each fixture has attributes on it that are\nspecific to the fixture. For instance, a fixture representing a directory that\ncan be used for temporary files might have a attribute 'path'.\n\nMost fixtures have complete ``pydoc`` documentation, so be sure to check\n``pydoc fixtures`` for usage information.\n\nCreating Fixtures\n=================\n\nMinimally, subclass Fixture, define _setUp to initialize your state and schedule\na cleanup for when cleanUp is called and you're done::\n\n  >>> import unittest\n  >>> import fixtures\n  >>> class NoddyFixture(fixtures.Fixture):\n  ...     def _setUp(self):\n  ...         self.frobnozzle = 42\n  ...         self.addCleanup(delattr, self, 'frobnozzle')\n\nThis will initialize frobnozzle when ``setUp`` is called, and when ``cleanUp``\nis called get rid of the frobnozzle attribute. Prior to version 1.3.0 fixtures\nrecommended overriding ``setUp``. This is still supported, but since it is\nharder to write leak-free fixtures in this fashion, it is not recommended.\n\nIf your fixture has diagnostic data - for instance the log file of an\napplication server, or log messages, it can expose that by creating a content\nobject (``testtools.content.Content``) and calling ``addDetail``.\n\n  >>> from testtools.content import text_content\n  >>> class WithLog(fixtures.Fixture):\n  ...     def _setUp(self):\n  ...         self.addDetail('message', text_content('foo bar baz'))\n\nThe method ``useFixture`` will use another fixture, call ``setUp`` on it, call\n``self.addCleanup(thefixture.cleanUp)``, attach any details from it and return\nthe fixture. This allows simple composition of different fixtures.\n\n  >>> class ReusingFixture(fixtures.Fixture):\n  ...     def _setUp(self):\n  ...         self.noddy = self.useFixture(NoddyFixture())\n\nThere is a helper for adapting a function or function pair into Fixtures. it\nputs the result of the function in fn_result::\n\n  >>> import os.path\n  >>> import shutil\n  >>> import tempfile\n  >>> def setup_function():\n  ...     return tempfile.mkdtemp()\n  >>> def teardown_function(fixture):\n  ...     shutil.rmtree(fixture)\n  >>> fixture = fixtures.FunctionFixture(setup_function, teardown_function)\n  >>> fixture.setUp()\n  >>> print (os.path.isdir(fixture.fn_result))\n  True\n  >>> fixture.cleanUp()\n\nThis can be expressed even more pithily:\n\n  >>> fixture = fixtures.FunctionFixture(tempfile.mkdtemp, shutil.rmtree)\n  >>> fixture.setUp()\n  >>> print (os.path.isdir(fixture.fn_result))\n  True\n  >>> fixture.cleanUp()\n\nAnother variation is MethodFixture which is useful for adapting alternate\nfixture implementations to Fixture::\n\n  >>> class MyServer:\n  ...    def start(self):\n  ...        pass\n  ...    def stop(self):\n  ...        pass\n  >>> server = MyServer()\n  >>> fixture = fixtures.MethodFixture(server, server.start, server.stop)\n\nYou can also combine existing fixtures using ``CompoundFixture``::\n\n  >>> noddy_with_log = fixtures.CompoundFixture([NoddyFixture(),\n  ...                                            WithLog()])\n  >>> with noddy_with_log as x:\n  ...     print (x.fixtures[0].frobnozzle)\n  42\n\nThe Fixture API\n===============\n\nThe example above introduces some of the Fixture API. In order to be able to\nclean up after a fixture has been used, all fixtures define a ``cleanUp``\nmethod which should be called when a fixture is finished with.\n\nBecause it's nice to be able to build a particular set of related fixtures in\nadvance of using them, fixtures also have a ``setUp`` method which should be\ncalled before trying to use them.\n\nOne common desire with fixtures that are expensive to create is to reuse them\nin many test cases; to support this the base Fixture also defines a ``reset``\nwhich calls ``self.cleanUp(); self.setUp()``. Fixtures that can more\nefficiently make themselves reusable should override this method. This can then\nbe used with multiple test state via things like ``testresources``,\n``setUpClass``, or ``setUpModule``.\n\nWhen using a fixture with a test you can manually call the setUp and cleanUp\nmethods. More convenient though is to use the included glue from\n``fixtures.TestWithFixtures`` which provides a mixin defining\n``useFixture`` (camel case because unittest is camel case throughout) method.\nIt will call setUp on the fixture, call self.addCleanup(fixture) to schedule a\ncleanup, and return the fixture. This lets one write::\n\n  >>> import testtools\n  >>> import unittest\n\nNote that we use testtools TestCase here as we need to guarantee a\nTestCase.addCleanup method in this doctest. Unittest2 - Python2.7 and above -\nalso have ``addCleanup``. testtools has it's own implementation of\n``useFixture`` so there is no need to use ``fixtures.TestWithFixtures`` with\n``testtools.TestCase``.\n\n  >>> class NoddyTest(testtools.TestCase, fixtures.TestWithFixtures):\n  ...     def test_example(self):\n  ...         fixture = self.useFixture(NoddyFixture())\n  ...         self.assertEqual(42, fixture.frobnozzle)\n  >>> result = unittest.TestResult()\n  >>> _ = NoddyTest('test_example').run(result)\n  >>> print (result.wasSuccessful())\n  True\n\nFixtures implement the context protocol, so you can also use a fixture as a\ncontext manager::\n\n  >>> with fixtures.FunctionFixture(setup_function, teardown_function) as fixture:\n  ...    print (os.path.isdir(fixture.fn_result))\n  True\n\nWhen multiple cleanups error, fixture.cleanUp() will raise a wrapper exception\nrather than choosing an arbitrary single exception to raise::\n\n  >>> import sys\n  >>> from fixtures.fixture import MultipleExceptions\n  >>> class BrokenFixture(fixtures.Fixture):\n  ...     def _setUp(self):\n  ...         self.addCleanup(lambda:1/0)\n  ...         self.addCleanup(lambda:1/0)\n  >>> fixture = BrokenFixture()\n  >>> fixture.setUp()\n  >>> try:\n  ...    fixture.cleanUp()\n  ... except MultipleExceptions:\n  ...    exc_info = sys.exc_info()\n  >>> print (exc_info[1].args[0][0].__name__)\n  ZeroDivisionError\n\nFixtures often expose diagnostic details that can be useful for tracking down\nissues. The ``getDetails`` method will return a dict of all the attached\ndetails, but can only be called before ``cleanUp`` is called. Each detail\nobject is an instance of ``testtools.content.Content``.\n\n  >>> with WithLog() as l:\n  ...     print(l.getDetails()['message'].as_text())\n  foo bar baz\n\nErrors in setUp\n+++++++++++++++\n\nThe examples above used ``_setUp`` rather than ``setUp`` because the base\nclass implementation of ``setUp`` acts to reduce the chance of leaking\nexternal resources if an error is raised from ``_setUp``. Specifically,\n``setUp`` contains a try:/except: block which catches all exceptions, captures\nany registered detail objects, and calls ``self.cleanUp`` before propagating\nthe error. As long as you take care to register any cleanups before calling\nthe code that may fail, this will cause them to be cleaned up. The captured\ndetail objects are provided to the args of the raised exception.\n\nIf the error that occured was a subclass of ``Exception`` then ``setUp`` will\nraise ``MultipleExceptions`` with the last element being a ``SetupError`` that\ncontains the detail objects. Otherwise, to prevent causing normally\nuncatchable errors like KeyboardInterrupt being caught inappropriately in the\ncalling layer, the original exception will be raised as-is and no diagnostic\ndata other than that from the original exception will be available.\n\nShared Dependencies\n+++++++++++++++++++\n\nA common use case within complex environments is having some fixtures shared by\nother ones.\n\nConsider the case of testing using a ``TempDir`` with two fixtures built on top\nof it; say a small database and a web server. Writing either one is nearly\ntrivial. However handling ``reset()`` correctly is hard: both the database and\nweb server would reasonably expect to be able to discard operating system\nresources they may have open within the temporary directory before its removed.\nA recursive ``reset()`` implementation would work for one, but not both.\nCalling ``reset()`` on the ``TempDir`` instance between each test is probably\ndesirable but we don't want to have to do a complete ``cleanUp`` of the higher\nlayer fixtures (which would make the ``TempDir`` be unused and trivially\nresettable. We have a few options available to us.\n\nImagine that the webserver does not depend on the DB fixture in any way - we\njust want the webserver and DB fixture to coexist in the same tempdir.\n\nA simple option is to just provide an explicit dependency fixture for the\nhigher layer fixtures to use.  This pushes complexity out of the core and onto\nusers of fixtures::\n\n  >>> class WithDep(fixtures.Fixture):\n  ...     def __init__(self, tempdir, dependency_fixture):\n  ...         super(WithDep, self).__init__()\n  ...         self.tempdir = tempdir\n  ...         self.dependency_fixture = dependency_fixture\n  ...     def setUp(self):\n  ...         super(WithDep, self).setUp()\n  ...         self.addCleanup(self.dependency_fixture.cleanUp)\n  ...         self.dependency_fixture.setUp()\n  ...         # we assume that at this point self.tempdir is usable.\n  >>> DB = WithDep\n  >>> WebServer = WithDep\n  >>> tempdir = fixtures.TempDir()\n  >>> db = DB(tempdir, tempdir)\n  >>> server = WebServer(tempdir, db)\n  >>> server.setUp()\n  >>> server.cleanUp()\n\nAnother option is to write the fixtures to gracefully handle a dependency\nbeing reset underneath them. This is insufficient if the fixtures would\nblock the dependency resetting (for instance by holding file locks open\nin a tempdir - on Windows this will prevent the directory being deleted).\n\nAnother approach which ``fixtures`` neither helps nor hinders is to raise\na signal of some sort for each user of a fixture before it is reset. In the\nexample here, ``TempDir`` might offer a subscribers attribute that both the\nDB and web server would be registered in. Calling ``reset`` or ``cleanUp``\non the tempdir would trigger a callback to all the subscribers; the DB and\nweb server reset methods would look something like:\n\n  >>> def reset(self):\n  ...     if not self._cleaned:\n  ...         self._clean()\n\n(Their action on the callback from the tempdir would be to do whatever work\nwas needed and set ``self._cleaned``.) This approach has the (perhaps)\nsuprising effect that resetting the webserver may reset the DB - if the\nwebserver were to be depending on ``tempdir.reset`` as a way to reset the\nwebservers state.\n\nAnother approach which is not currently implemented is to provide an object\ngraph of dependencies and a reset mechanism that can traverse that, along with\na separation between 'reset starting' and 'reset finishing' - the DB and\nwebserver would both have their ``reset_starting`` methods called, then the\ntempdir would be reset, and finally the DB and webserver would have\n``reset_finishing`` called.\n\nStock Fixtures\n==============\n\nIn addition to the Fixture, FunctionFixture and MethodFixture classes fixtures\nincludes a number of precanned fixtures. The API docs for fixtures will list\nthe complete set of these, should the dcs be out of date or not to hand. For\nthe complete feature set of each fixture please see the API docs.\n\nByteStream\n++++++++++\n\nTrivial adapter to make a BytesIO (though it may in future auto-spill to disk\nfor large content) and expose that as a detail object, for automatic inclusion\nin test failure descriptions. Very useful in combination with MonkeyPatch.\n\n  >>> fixture = fixtures.StringStream('my-content')\n  >>> fixture.setUp()\n  >>> with fixtures.MonkeyPatch('sys.something', fixture.stream):\n  ...     pass\n  >>> fixture.cleanUp()\n\nEnvironmentVariable\n+++++++++++++++++++\n\nIsolate your code from environmental variables, delete them or set them to a\nnew value.\n\n  >>> fixture = fixtures.EnvironmentVariable('HOME')\n\nFakeLogger\n++++++++++\n\nIsolate your code from an external logging configuration - so that your test\ngets the output from logged messages, but they don't go to e.g. the console.\n\n  >>> fixture = fixtures.FakeLogger()\n\nFakePopen\n+++++++++\n\nPretend to run an external command rather than needing it to be present to run\ntests.\n\n  >>> from testtools.compat import BytesIO\n  >>> fixture = fixtures.FakePopen(lambda _:{'stdout': BytesIO('foobar')})\n\nMockPatchObject\n+++++++++++++++\n\nAdapts ``mock.patch.object`` to be used as a Fixture.\n\n  >>> class Fred:\n  ...     value = 1\n  >>> fixture = fixtures.MockPatchObject(Fred, 'value', 2)\n  >>> with fixture:\n  ...     Fred().value\n  2\n  >>> Fred().value\n  1\n\nMockPatch\n+++++++++\n\nAdapts ``mock.patch`` to be used as a Fixture.\n\n  >>> fixture = fixtures.MockPatch('subprocess.Popen.returncode', 3)\n\nMockPatchMultiple\n+++++++++++++++++\n\nAdapts ``mock.patch.multiple`` to be used as a Fixture.\n\n  >>> fixture = fixtures.MockPatchMultiple('subprocess.Popen', returncode=3)\n\nMonkeyPatch\n+++++++++++\n\nControl the value of a named python attribute.\n\n  >>> def fake_open(path, mode):\n  ...     pass\n  >>> fixture = fixtures.MonkeyPatch('__builtin__.open', fake_open)\n\nNote that there are some complexities when patching methods - please see the\nAPI documentation for details.\n\nNestedTempfile\n++++++++++++++\n\nChange the default directory that the tempfile module places temporary files\nand directories in. This can be useful for containing the noise created by\ncode which doesn't clean up its temporary files. This does not affect\ntemporary file creation where an explicit containing directory was provided.\n\n  >>> fixture = fixtures.NestedTempfile()\n\nPackagePathEntry\n++++++++++++++++\n\nAdds a single directory to the path for an existing python package. This adds\nto the package.__path__ list. If the directory is already in the path, nothing\nhappens, if it isn't then it is added on setUp and removed on cleanUp.\n\n  >>> fixture = fixtures.PackagePathEntry('package/name', '/foo/bar')\n\nPythonPackage\n+++++++++++++\n\nCreates a python package directory. Particularly useful for testing code that\ndynamically loads packages/modules, or for mocking out the command line entry\npoints to Python programs.\n\n  >>> fixture = fixtures.PythonPackage('foo.bar', [('quux.py', '')])\n\nPythonPathEntry\n+++++++++++++++\n\nAdds a single directory to sys.path. If the directory is already in the path,\nnothing happens, if it isn't then it is added on setUp and removed on cleanUp.\n\n  >>> fixture = fixtures.PythonPathEntry('/foo/bar')\n\nStringStream\n++++++++++++\n\nTrivial adapter to make a StringIO (though it may in future auto-spill to disk\nfor large content) and expose that as a detail object, for automatic inclusion\nin test failure descriptions. Very useful in combination with MonkeyPatch.\n\n  >>> fixture = fixtures.StringStream('stdout')\n  >>> fixture.setUp()\n  >>> with fixtures.MonkeyPatch('sys.stdout', fixture.stream):\n  ...     pass\n  >>> fixture.cleanUp()\n\nTempDir\n+++++++\n\nCreate a temporary directory and clean it up later.\n\n  >>> fixture = fixtures.TempDir()\n\nThe created directory is stored in the ``path`` attribute of the fixture after\nsetUp.\n\nTempHomeDir\n+++++++++++\n\nCreate a temporary directory and set it as $HOME in the environment.\n\n  >>> fixture = fixtures.TempHomeDir()\n\nThe created directory is stored in the ``path`` attribute of the fixture after\nsetUp.\n\nThe environment will now have $HOME set to the same path, and the value\nwill be returned to its previous value after tearDown.\n\nTimeout\n+++++++\n\nAborts if the covered code takes more than a specified number of whole wall-clock\nseconds.\n\nThere are two possibilities, controlled by the 'gentle' argument: when gentle,\nan exception will be raised and the test (or other covered code) will fail.\nWhen not gentle, the entire process will be terminated, which is less clean,\nbut more likely to break hangs where no Python code is running.  \n\n*Caution:* Only one timeout can be active at any time across all threads in a\nsingle process.  Using more than one has undefined results.  (This could be\nimproved by chaining alarms.)\n\n*Note:* Currently supported only on Unix because it relies on the ``alarm``\nsystem call.\n\nContributing\n============\n\nFixtures has its project homepage on Launchpad\n<https://launchpad.net/python-fixtures>. Source code is hosted on GitHub\n<https://github.com/testing-cabal/fixtures>.",
  "requires_dist": null,
  "requires_python": null,
  "current_version": "3.0.0",
  "released_versions": [
    "0.1",
    "0.2",
    "0.3",
    "0.3.1",
    "0.3.10",
    "0.3.11",
    "0.3.12",
    "0.3.13",
    "0.3.14",
    "0.3.15",
    "0.3.16",
    "0.3.17",
    "0.3.2",
    "0.3.3",
    "0.3.4",
    "0.3.5",
    "0.3.6",
    "0.3.7",
    "0.3.8",
    "0.3.9",
    "1.0.0",
    "1.1.0",
    "1.2.0",
    "1.2.1",
    "1.3.0",
    "1.3.1",
    "1.3.2.dev6",
    "1.4.0",
    "2.0.0",
    "3.0.0"
  ]
}